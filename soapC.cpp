/* soapC.cpp
   Generated by gSOAP 2.8.117 for pain.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.117 2021-12-05 18:45:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns1__ISODateTime:
		return soap_in_ns1__ISODateTime(soap, tag, NULL, "ns1:ISODateTime");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__TrueFalseIndicator:
		return soap_in_ns1__TrueFalseIndicator(soap, tag, NULL, "ns1:TrueFalseIndicator");
	case SOAP_TYPE_ns1__TaxRecordPeriod1Code:
		return soap_in_ns1__TaxRecordPeriod1Code(soap, tag, NULL, "ns1:TaxRecordPeriod1Code");
	case SOAP_TYPE_ns1__RemittanceLocationMethod2Code:
		return soap_in_ns1__RemittanceLocationMethod2Code(soap, tag, NULL, "ns1:RemittanceLocationMethod2Code");
	case SOAP_TYPE_ns1__RegulatoryReportingType1Code:
		return soap_in_ns1__RegulatoryReportingType1Code(soap, tag, NULL, "ns1:RegulatoryReportingType1Code");
	case SOAP_TYPE_ns1__Priority2Code:
		return soap_in_ns1__Priority2Code(soap, tag, NULL, "ns1:Priority2Code");
	case SOAP_TYPE_ns1__PreferredContactMethod1Code:
		return soap_in_ns1__PreferredContactMethod1Code(soap, tag, NULL, "ns1:PreferredContactMethod1Code");
	case SOAP_TYPE_ns1__PaymentMethod3Code:
		return soap_in_ns1__PaymentMethod3Code(soap, tag, NULL, "ns1:PaymentMethod3Code");
	case SOAP_TYPE_ns1__NamePrefix2Code:
		return soap_in_ns1__NamePrefix2Code(soap, tag, NULL, "ns1:NamePrefix2Code");
	case SOAP_TYPE_ns1__MandateClassification1Code:
		return soap_in_ns1__MandateClassification1Code(soap, tag, NULL, "ns1:MandateClassification1Code");
	case SOAP_TYPE_ns1__Frequency6Code:
		return soap_in_ns1__Frequency6Code(soap, tag, NULL, "ns1:Frequency6Code");
	case SOAP_TYPE_ns1__ExchangeRateType1Code:
		return soap_in_ns1__ExchangeRateType1Code(soap, tag, NULL, "ns1:ExchangeRateType1Code");
	case SOAP_TYPE_ns1__DocumentType6Code:
		return soap_in_ns1__DocumentType6Code(soap, tag, NULL, "ns1:DocumentType6Code");
	case SOAP_TYPE_ns1__DocumentType3Code:
		return soap_in_ns1__DocumentType3Code(soap, tag, NULL, "ns1:DocumentType3Code");
	case SOAP_TYPE_ns1__CreditDebitCode:
		return soap_in_ns1__CreditDebitCode(soap, tag, NULL, "ns1:CreditDebitCode");
	case SOAP_TYPE_ns1__ChequeType2Code:
		return soap_in_ns1__ChequeType2Code(soap, tag, NULL, "ns1:ChequeType2Code");
	case SOAP_TYPE_ns1__ChequeDelivery1Code:
		return soap_in_ns1__ChequeDelivery1Code(soap, tag, NULL, "ns1:ChequeDelivery1Code");
	case SOAP_TYPE_ns1__ChargeBearerType1Code:
		return soap_in_ns1__ChargeBearerType1Code(soap, tag, NULL, "ns1:ChargeBearerType1Code");
	case SOAP_TYPE_ns1__BatchBookingIndicator:
		return soap_in_ns1__BatchBookingIndicator(soap, tag, NULL, "ns1:BatchBookingIndicator");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__Authorisation1Code:
		return soap_in_ns1__Authorisation1Code(soap, tag, NULL, "ns1:Authorisation1Code");
	case SOAP_TYPE_ns1__AdviceType1Code:
		return soap_in_ns1__AdviceType1Code(soap, tag, NULL, "ns1:AdviceType1Code");
	case SOAP_TYPE_ns1__AddressType2Code:
		return soap_in_ns1__AddressType2Code(soap, tag, NULL, "ns1:AddressType2Code");
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		return soap_in_ns1__UUIDv4Identifier(soap, tag, NULL, "ns1:UUIDv4Identifier");
	case SOAP_TYPE_ns1__PhoneNumber:
		return soap_in_ns1__PhoneNumber(soap, tag, NULL, "ns1:PhoneNumber");
	case SOAP_TYPE_ns1__PercentageRate:
		return soap_in_ns1__PercentageRate(soap, tag, NULL, "ns1:PercentageRate");
	case SOAP_TYPE_ns1__Number:
		return soap_in_ns1__Number(soap, tag, NULL, "ns1:Number");
	case SOAP_TYPE_ns1__Max70Text:
		return soap_in_ns1__Max70Text(soap, tag, NULL, "ns1:Max70Text");
	case SOAP_TYPE_ns1__Max4Text:
		return soap_in_ns1__Max4Text(soap, tag, NULL, "ns1:Max4Text");
	case SOAP_TYPE_ns1__Max35Text:
		return soap_in_ns1__Max35Text(soap, tag, NULL, "ns1:Max35Text");
	case SOAP_TYPE_ns1__Max350Text:
		return soap_in_ns1__Max350Text(soap, tag, NULL, "ns1:Max350Text");
	case SOAP_TYPE_ns1__Max34Text:
		return soap_in_ns1__Max34Text(soap, tag, NULL, "ns1:Max34Text");
	case SOAP_TYPE_ns1__Max2048Text:
		return soap_in_ns1__Max2048Text(soap, tag, NULL, "ns1:Max2048Text");
	case SOAP_TYPE_ns1__Max16Text:
		return soap_in_ns1__Max16Text(soap, tag, NULL, "ns1:Max16Text");
	case SOAP_TYPE_ns1__Max15NumericText:
		return soap_in_ns1__Max15NumericText(soap, tag, NULL, "ns1:Max15NumericText");
	case SOAP_TYPE_ns1__Max140Text:
		return soap_in_ns1__Max140Text(soap, tag, NULL, "ns1:Max140Text");
	case SOAP_TYPE_ns1__Max128Text:
		return soap_in_ns1__Max128Text(soap, tag, NULL, "ns1:Max128Text");
	case SOAP_TYPE_ns1__Max10Text:
		return soap_in_ns1__Max10Text(soap, tag, NULL, "ns1:Max10Text");
	case SOAP_TYPE_ns1__Max10KBinary:
		return soap_in_ns1__Max10KBinary(soap, tag, NULL, "ns1:Max10KBinary");
	case SOAP_TYPE_ns1__LEIIdentifier:
		return soap_in_ns1__LEIIdentifier(soap, tag, NULL, "ns1:LEIIdentifier");
	case SOAP_TYPE_ns1__ISOYear:
		return soap_in_ns1__ISOYear(soap, tag, NULL, "ns1:ISOYear");
	case SOAP_TYPE_ns1__ISODate:
		return soap_in_ns1__ISODate(soap, tag, NULL, "ns1:ISODate");
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		return soap_in_ns1__IBAN2007Identifier(soap, tag, NULL, "ns1:IBAN2007Identifier");
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		return soap_in_ns1__ExternalTaxAmountType1Code(soap, tag, NULL, "ns1:ExternalTaxAmountType1Code");
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		return soap_in_ns1__ExternalServiceLevel1Code(soap, tag, NULL, "ns1:ExternalServiceLevel1Code");
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		return soap_in_ns1__ExternalPurpose1Code(soap, tag, NULL, "ns1:ExternalPurpose1Code");
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		return soap_in_ns1__ExternalProxyAccountType1Code(soap, tag, NULL, "ns1:ExternalProxyAccountType1Code");
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		return soap_in_ns1__ExternalPersonIdentification1Code(soap, tag, NULL, "ns1:ExternalPersonIdentification1Code");
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		return soap_in_ns1__ExternalOrganisationIdentification1Code(soap, tag, NULL, "ns1:ExternalOrganisationIdentification1Code");
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		return soap_in_ns1__ExternalMandateSetupReason1Code(soap, tag, NULL, "ns1:ExternalMandateSetupReason1Code");
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		return soap_in_ns1__ExternalLocalInstrument1Code(soap, tag, NULL, "ns1:ExternalLocalInstrument1Code");
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		return soap_in_ns1__ExternalGarnishmentType1Code(soap, tag, NULL, "ns1:ExternalGarnishmentType1Code");
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		return soap_in_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, NULL, "ns1:ExternalFinancialInstitutionIdentification1Code");
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		return soap_in_ns1__ExternalDocumentLineType1Code(soap, tag, NULL, "ns1:ExternalDocumentLineType1Code");
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		return soap_in_ns1__ExternalDiscountAmountType1Code(soap, tag, NULL, "ns1:ExternalDiscountAmountType1Code");
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		return soap_in_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, NULL, "ns1:ExternalDebtorAgentInstruction1Code");
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		return soap_in_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, NULL, "ns1:ExternalCreditorAgentInstruction1Code");
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		return soap_in_ns1__ExternalClearingSystemIdentification1Code(soap, tag, NULL, "ns1:ExternalClearingSystemIdentification1Code");
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		return soap_in_ns1__ExternalCategoryPurpose1Code(soap, tag, NULL, "ns1:ExternalCategoryPurpose1Code");
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		return soap_in_ns1__ExternalCashAccountType1Code(soap, tag, NULL, "ns1:ExternalCashAccountType1Code");
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		return soap_in_ns1__ExternalAccountIdentification1Code(soap, tag, NULL, "ns1:ExternalAccountIdentification1Code");
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		return soap_in_ns1__Exact4AlphaNumericText(soap, tag, NULL, "ns1:Exact4AlphaNumericText");
	case SOAP_TYPE_ns1__Exact2NumericText:
		return soap_in_ns1__Exact2NumericText(soap, tag, NULL, "ns1:Exact2NumericText");
	case SOAP_TYPE_ns1__DecimalNumber:
		return soap_in_ns1__DecimalNumber(soap, tag, NULL, "ns1:DecimalNumber");
	case SOAP_TYPE_ns1__CountryCode:
		return soap_in_ns1__CountryCode(soap, tag, NULL, "ns1:CountryCode");
	case SOAP_TYPE_ns1__BaseOneRate:
		return soap_in_ns1__BaseOneRate(soap, tag, NULL, "ns1:BaseOneRate");
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		return soap_in_ns1__BICFIDec2014Identifier(soap, tag, NULL, "ns1:BICFIDec2014Identifier");
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		return soap_in_ns1__AnyBICDec2014Identifier(soap, tag, NULL, "ns1:AnyBICDec2014Identifier");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		return soap_in_ns1__ActiveOrHistoricCurrencyCode(soap, tag, NULL, "ns1:ActiveOrHistoricCurrencyCode");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		return soap_in_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, tag, NULL, "ns1:ActiveOrHistoricCurrencyAndAmount_SimpleType");
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		return soap_in_ns1__TaxRecordDetails3(soap, tag, NULL, "ns1:TaxRecordDetails3");
	case SOAP_TYPE_ns1__TaxRecord3:
		return soap_in_ns1__TaxRecord3(soap, tag, NULL, "ns1:TaxRecord3");
	case SOAP_TYPE_ns1__TaxPeriod3:
		return soap_in_ns1__TaxPeriod3(soap, tag, NULL, "ns1:TaxPeriod3");
	case SOAP_TYPE_ns1__TaxParty2:
		return soap_in_ns1__TaxParty2(soap, tag, NULL, "ns1:TaxParty2");
	case SOAP_TYPE_ns1__TaxParty1:
		return soap_in_ns1__TaxParty1(soap, tag, NULL, "ns1:TaxParty1");
	case SOAP_TYPE_ns1__TaxInformation10:
		return soap_in_ns1__TaxInformation10(soap, tag, NULL, "ns1:TaxInformation10");
	case SOAP_TYPE_ns1__TaxData1:
		return soap_in_ns1__TaxData1(soap, tag, NULL, "ns1:TaxData1");
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		return soap_in_ns1__TaxAuthorisation1(soap, tag, NULL, "ns1:TaxAuthorisation1");
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		return soap_in_ns1__TaxAmountType1Choice(soap, tag, NULL, "ns1:TaxAmountType1Choice");
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		return soap_in_ns1__TaxAmountAndType1(soap, tag, NULL, "ns1:TaxAmountAndType1");
	case SOAP_TYPE_ns1__TaxAmount3:
		return soap_in_ns1__TaxAmount3(soap, tag, NULL, "ns1:TaxAmount3");
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		return soap_in_ns1__SupplementaryDataEnvelope1(soap, tag, NULL, "ns1:SupplementaryDataEnvelope1");
	case SOAP_TYPE_ns1__SupplementaryData1:
		return soap_in_ns1__SupplementaryData1(soap, tag, NULL, "ns1:SupplementaryData1");
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		return soap_in_ns1__StructuredRemittanceInformation17(soap, tag, NULL, "ns1:StructuredRemittanceInformation17");
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		return soap_in_ns1__StructuredRegulatoryReporting3(soap, tag, NULL, "ns1:StructuredRegulatoryReporting3");
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		return soap_in_ns1__ServiceLevel8Choice(soap, tag, NULL, "ns1:ServiceLevel8Choice");
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		return soap_in_ns1__RemittanceLocationData1(soap, tag, NULL, "ns1:RemittanceLocationData1");
	case SOAP_TYPE_ns1__RemittanceLocation7:
		return soap_in_ns1__RemittanceLocation7(soap, tag, NULL, "ns1:RemittanceLocation7");
	case SOAP_TYPE_ns1__RemittanceInformation21:
		return soap_in_ns1__RemittanceInformation21(soap, tag, NULL, "ns1:RemittanceInformation21");
	case SOAP_TYPE_ns1__RemittanceAmount3:
		return soap_in_ns1__RemittanceAmount3(soap, tag, NULL, "ns1:RemittanceAmount3");
	case SOAP_TYPE_ns1__RemittanceAmount2:
		return soap_in_ns1__RemittanceAmount2(soap, tag, NULL, "ns1:RemittanceAmount2");
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		return soap_in_ns1__RegulatoryReporting3(soap, tag, NULL, "ns1:RegulatoryReporting3");
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		return soap_in_ns1__RegulatoryAuthority2(soap, tag, NULL, "ns1:RegulatoryAuthority2");
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		return soap_in_ns1__ReferredDocumentType4(soap, tag, NULL, "ns1:ReferredDocumentType4");
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		return soap_in_ns1__ReferredDocumentType3Choice(soap, tag, NULL, "ns1:ReferredDocumentType3Choice");
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		return soap_in_ns1__ReferredDocumentInformation7(soap, tag, NULL, "ns1:ReferredDocumentInformation7");
	case SOAP_TYPE_ns1__Purpose2Choice:
		return soap_in_ns1__Purpose2Choice(soap, tag, NULL, "ns1:Purpose2Choice");
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		return soap_in_ns1__ProxyAccountType1Choice(soap, tag, NULL, "ns1:ProxyAccountType1Choice");
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		return soap_in_ns1__ProxyAccountIdentification1(soap, tag, NULL, "ns1:ProxyAccountIdentification1");
	case SOAP_TYPE_ns1__PostalAddress24:
		return soap_in_ns1__PostalAddress24(soap, tag, NULL, "ns1:PostalAddress24");
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		return soap_in_ns1__PersonIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:PersonIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__PersonIdentification13:
		return soap_in_ns1__PersonIdentification13(soap, tag, NULL, "ns1:PersonIdentification13");
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		return soap_in_ns1__PaymentTypeInformation26(soap, tag, NULL, "ns1:PaymentTypeInformation26");
	case SOAP_TYPE_ns1__PaymentInstruction40:
		return soap_in_ns1__PaymentInstruction40(soap, tag, NULL, "ns1:PaymentInstruction40");
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		return soap_in_ns1__PaymentInitiationSource1(soap, tag, NULL, "ns1:PaymentInitiationSource1");
	case SOAP_TYPE_ns1__PaymentIdentification6:
		return soap_in_ns1__PaymentIdentification6(soap, tag, NULL, "ns1:PaymentIdentification6");
	case SOAP_TYPE_ns1__PartyIdentification135:
		return soap_in_ns1__PartyIdentification135(soap, tag, NULL, "ns1:PartyIdentification135");
	case SOAP_TYPE_ns1__Party38Choice:
		return soap_in_ns1__Party38Choice(soap, tag, NULL, "ns1:Party38Choice");
	case SOAP_TYPE_ns1__OtherContact1:
		return soap_in_ns1__OtherContact1(soap, tag, NULL, "ns1:OtherContact1");
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		return soap_in_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:OrganisationIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		return soap_in_ns1__OrganisationIdentification29(soap, tag, NULL, "ns1:OrganisationIdentification29");
	case SOAP_TYPE_ns1__NameAndAddress16:
		return soap_in_ns1__NameAndAddress16(soap, tag, NULL, "ns1:NameAndAddress16");
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		return soap_in_ns1__MandateTypeInformation2(soap, tag, NULL, "ns1:MandateTypeInformation2");
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		return soap_in_ns1__MandateSetupReason1Choice(soap, tag, NULL, "ns1:MandateSetupReason1Choice");
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		return soap_in_ns1__MandateClassification1Choice(soap, tag, NULL, "ns1:MandateClassification1Choice");
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		return soap_in_ns1__LocalInstrument2Choice(soap, tag, NULL, "ns1:LocalInstrument2Choice");
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		return soap_in_ns1__InstructionForDebtorAgent1(soap, tag, NULL, "ns1:InstructionForDebtorAgent1");
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		return soap_in_ns1__InstructionForCreditorAgent3(soap, tag, NULL, "ns1:InstructionForCreditorAgent3");
	case SOAP_TYPE_ns1__GroupHeader95:
		return soap_in_ns1__GroupHeader95(soap, tag, NULL, "ns1:GroupHeader95");
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		return soap_in_ns1__GenericPersonIdentification1(soap, tag, NULL, "ns1:GenericPersonIdentification1");
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		return soap_in_ns1__GenericOrganisationIdentification1(soap, tag, NULL, "ns1:GenericOrganisationIdentification1");
	case SOAP_TYPE_ns1__GenericIdentification30:
		return soap_in_ns1__GenericIdentification30(soap, tag, NULL, "ns1:GenericIdentification30");
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		return soap_in_ns1__GenericFinancialIdentification1(soap, tag, NULL, "ns1:GenericFinancialIdentification1");
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		return soap_in_ns1__GenericAccountIdentification1(soap, tag, NULL, "ns1:GenericAccountIdentification1");
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		return soap_in_ns1__GarnishmentType1Choice(soap, tag, NULL, "ns1:GarnishmentType1Choice");
	case SOAP_TYPE_ns1__GarnishmentType1:
		return soap_in_ns1__GarnishmentType1(soap, tag, NULL, "ns1:GarnishmentType1");
	case SOAP_TYPE_ns1__Garnishment3:
		return soap_in_ns1__Garnishment3(soap, tag, NULL, "ns1:Garnishment3");
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		return soap_in_ns1__FrequencyPeriod1(soap, tag, NULL, "ns1:FrequencyPeriod1");
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		return soap_in_ns1__FrequencyAndMoment1(soap, tag, NULL, "ns1:FrequencyAndMoment1");
	case SOAP_TYPE_ns1__Frequency36Choice:
		return soap_in_ns1__Frequency36Choice(soap, tag, NULL, "ns1:Frequency36Choice");
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		return soap_in_ns1__FinancialInstitutionIdentification18(soap, tag, NULL, "ns1:FinancialInstitutionIdentification18");
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		return soap_in_ns1__FinancialIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:FinancialIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__ExchangeRate1:
		return soap_in_ns1__ExchangeRate1(soap, tag, NULL, "ns1:ExchangeRate1");
	case SOAP_TYPE_ns1__EquivalentAmount2:
		return soap_in_ns1__EquivalentAmount2(soap, tag, NULL, "ns1:EquivalentAmount2");
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		return soap_in_ns1__DocumentLineType1Choice(soap, tag, NULL, "ns1:DocumentLineType1Choice");
	case SOAP_TYPE_ns1__DocumentLineType1:
		return soap_in_ns1__DocumentLineType1(soap, tag, NULL, "ns1:DocumentLineType1");
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		return soap_in_ns1__DocumentLineInformation1(soap, tag, NULL, "ns1:DocumentLineInformation1");
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		return soap_in_ns1__DocumentLineIdentification1(soap, tag, NULL, "ns1:DocumentLineIdentification1");
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		return soap_in_ns1__DocumentAdjustment1(soap, tag, NULL, "ns1:DocumentAdjustment1");
	case SOAP_TYPE_ns1__Document:
		return soap_in_ns1__Document(soap, tag, NULL, "ns1:Document");
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		return soap_in_ns1__DiscountAmountType1Choice(soap, tag, NULL, "ns1:DiscountAmountType1Choice");
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		return soap_in_ns1__DiscountAmountAndType1(soap, tag, NULL, "ns1:DiscountAmountAndType1");
	case SOAP_TYPE_ns1__DatePeriod2:
		return soap_in_ns1__DatePeriod2(soap, tag, NULL, "ns1:DatePeriod2");
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		return soap_in_ns1__DateAndPlaceOfBirth1(soap, tag, NULL, "ns1:DateAndPlaceOfBirth1");
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		return soap_in_ns1__DateAndDateTime2Choice(soap, tag, NULL, "ns1:DateAndDateTime2Choice");
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		return soap_in_ns1__CustomerCreditTransferInitiationV11(soap, tag, NULL, "ns1:CustomerCreditTransferInitiationV11");
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		return soap_in_ns1__CreditorReferenceType2(soap, tag, NULL, "ns1:CreditorReferenceType2");
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		return soap_in_ns1__CreditorReferenceType1Choice(soap, tag, NULL, "ns1:CreditorReferenceType1Choice");
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		return soap_in_ns1__CreditorReferenceInformation2(soap, tag, NULL, "ns1:CreditorReferenceInformation2");
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		return soap_in_ns1__CreditTransferTransaction54(soap, tag, NULL, "ns1:CreditTransferTransaction54");
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		return soap_in_ns1__CreditTransferMandateData1(soap, tag, NULL, "ns1:CreditTransferMandateData1");
	case SOAP_TYPE_ns1__Contact4:
		return soap_in_ns1__Contact4(soap, tag, NULL, "ns1:Contact4");
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		return soap_in_ns1__ClearingSystemMemberIdentification2(soap, tag, NULL, "ns1:ClearingSystemMemberIdentification2");
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		return soap_in_ns1__ClearingSystemIdentification2Choice(soap, tag, NULL, "ns1:ClearingSystemIdentification2Choice");
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		return soap_in_ns1__ChequeDeliveryMethod1Choice(soap, tag, NULL, "ns1:ChequeDeliveryMethod1Choice");
	case SOAP_TYPE_ns1__Cheque11:
		return soap_in_ns1__Cheque11(soap, tag, NULL, "ns1:Cheque11");
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		return soap_in_ns1__CategoryPurpose1Choice(soap, tag, NULL, "ns1:CategoryPurpose1Choice");
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		return soap_in_ns1__CashAccountType2Choice(soap, tag, NULL, "ns1:CashAccountType2Choice");
	case SOAP_TYPE_ns1__CashAccount40:
		return soap_in_ns1__CashAccount40(soap, tag, NULL, "ns1:CashAccount40");
	case SOAP_TYPE_ns1__BranchData3:
		return soap_in_ns1__BranchData3(soap, tag, NULL, "ns1:BranchData3");
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		return soap_in_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag, NULL, "ns1:BranchAndFinancialInstitutionIdentification6");
	case SOAP_TYPE_ns1__Authorisation1Choice:
		return soap_in_ns1__Authorisation1Choice(soap, tag, NULL, "ns1:Authorisation1Choice");
	case SOAP_TYPE_ns1__AmountType4Choice:
		return soap_in_ns1__AmountType4Choice(soap, tag, NULL, "ns1:AmountType4Choice");
	case SOAP_TYPE_ns1__AdviceType1Choice:
		return soap_in_ns1__AdviceType1Choice(soap, tag, NULL, "ns1:AdviceType1Choice");
	case SOAP_TYPE_ns1__AdviceType1:
		return soap_in_ns1__AdviceType1(soap, tag, NULL, "ns1:AdviceType1");
	case SOAP_TYPE_ns1__AddressType3Choice:
		return soap_in_ns1__AddressType3Choice(soap, tag, NULL, "ns1:AddressType3Choice");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		return soap_in_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag, NULL, "ns1:ActiveOrHistoricCurrencyAndAmount");
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		return soap_in_ns1__AccountSchemeName1Choice(soap, tag, NULL, "ns1:AccountSchemeName1Choice");
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		return soap_in_ns1__AccountIdentification4Choice(soap, tag, NULL, "ns1:AccountIdentification4Choice");
	case SOAP_TYPE_xsd__gYear:
		return soap_in_xsd__gYear(soap, tag, NULL, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, tag, NULL, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__TaxAmount3:
		return soap_in_PointerTons1__TaxAmount3(soap, tag, NULL, "ns1:TaxAmount3");
	case SOAP_TYPE_PointerTons1__TaxPeriod3:
		return soap_in_PointerTons1__TaxPeriod3(soap, tag, NULL, "ns1:TaxPeriod3");
	case SOAP_TYPE_PointerTons1__DatePeriod2:
		return soap_in_PointerTons1__DatePeriod2(soap, tag, NULL, "ns1:DatePeriod2");
	case SOAP_TYPE_PointerTons1__TaxRecordPeriod1Code:
		return soap_in_PointerTons1__TaxRecordPeriod1Code(soap, tag, NULL, "ns1:TaxRecordPeriod1Code");
	case SOAP_TYPE_PointerTons1__ISOYear:
		return soap_in_PointerTons1__ISOYear(soap, tag, NULL, "ns1:ISOYear");
	case SOAP_TYPE_PointerTons1__TaxAuthorisation1:
		return soap_in_PointerTons1__TaxAuthorisation1(soap, tag, NULL, "ns1:TaxAuthorisation1");
	case SOAP_TYPE_PointerTons1__TaxRecord3:
		return soap_in_PointerTons1__TaxRecord3(soap, tag, NULL, "ns1:TaxRecord3");
	case SOAP_TYPE_PointerTons1__Number:
		return soap_in_PointerTons1__Number(soap, tag, NULL, "ns1:Number");
	case SOAP_TYPE_PointerTons1__TaxParty2:
		return soap_in_PointerTons1__TaxParty2(soap, tag, NULL, "ns1:TaxParty2");
	case SOAP_TYPE_PointerTons1__TaxParty1:
		return soap_in_PointerTons1__TaxParty1(soap, tag, NULL, "ns1:TaxParty1");
	case SOAP_TYPE_PointerTons1__ExternalTaxAmountType1Code:
		return soap_in_PointerTons1__ExternalTaxAmountType1Code(soap, tag, NULL, "ns1:ExternalTaxAmountType1Code");
	case SOAP_TYPE_PointerTons1__TaxAmountType1Choice:
		return soap_in_PointerTons1__TaxAmountType1Choice(soap, tag, NULL, "ns1:TaxAmountType1Choice");
	case SOAP_TYPE_PointerTons1__TaxRecordDetails3:
		return soap_in_PointerTons1__TaxRecordDetails3(soap, tag, NULL, "ns1:TaxRecordDetails3");
	case SOAP_TYPE_PointerTons1__PercentageRate:
		return soap_in_PointerTons1__PercentageRate(soap, tag, NULL, "ns1:PercentageRate");
	case SOAP_TYPE_PointerTons1__SupplementaryDataEnvelope1:
		return soap_in_PointerTons1__SupplementaryDataEnvelope1(soap, tag, NULL, "ns1:SupplementaryDataEnvelope1");
	case SOAP_TYPE_PointerTons1__Max350Text:
		return soap_in_PointerTons1__Max350Text(soap, tag, NULL, "ns1:Max350Text");
	case SOAP_TYPE_PointerTons1__Garnishment3:
		return soap_in_PointerTons1__Garnishment3(soap, tag, NULL, "ns1:Garnishment3");
	case SOAP_TYPE_PointerTons1__TaxData1:
		return soap_in_PointerTons1__TaxData1(soap, tag, NULL, "ns1:TaxData1");
	case SOAP_TYPE_PointerTons1__CreditorReferenceInformation2:
		return soap_in_PointerTons1__CreditorReferenceInformation2(soap, tag, NULL, "ns1:CreditorReferenceInformation2");
	case SOAP_TYPE_PointerTons1__RemittanceAmount2:
		return soap_in_PointerTons1__RemittanceAmount2(soap, tag, NULL, "ns1:RemittanceAmount2");
	case SOAP_TYPE_PointerTons1__ReferredDocumentInformation7:
		return soap_in_PointerTons1__ReferredDocumentInformation7(soap, tag, NULL, "ns1:ReferredDocumentInformation7");
	case SOAP_TYPE_PointerTons1__Max10Text:
		return soap_in_PointerTons1__Max10Text(soap, tag, NULL, "ns1:Max10Text");
	case SOAP_TYPE_PointerTons1__ExternalServiceLevel1Code:
		return soap_in_PointerTons1__ExternalServiceLevel1Code(soap, tag, NULL, "ns1:ExternalServiceLevel1Code");
	case SOAP_TYPE_PointerTons1__RemittanceLocationData1:
		return soap_in_PointerTons1__RemittanceLocationData1(soap, tag, NULL, "ns1:RemittanceLocationData1");
	case SOAP_TYPE_PointerTons1__StructuredRemittanceInformation17:
		return soap_in_PointerTons1__StructuredRemittanceInformation17(soap, tag, NULL, "ns1:StructuredRemittanceInformation17");
	case SOAP_TYPE_PointerTons1__DocumentAdjustment1:
		return soap_in_PointerTons1__DocumentAdjustment1(soap, tag, NULL, "ns1:DocumentAdjustment1");
	case SOAP_TYPE_PointerTons1__TaxAmountAndType1:
		return soap_in_PointerTons1__TaxAmountAndType1(soap, tag, NULL, "ns1:TaxAmountAndType1");
	case SOAP_TYPE_PointerTons1__DiscountAmountAndType1:
		return soap_in_PointerTons1__DiscountAmountAndType1(soap, tag, NULL, "ns1:DiscountAmountAndType1");
	case SOAP_TYPE_PointerTons1__StructuredRegulatoryReporting3:
		return soap_in_PointerTons1__StructuredRegulatoryReporting3(soap, tag, NULL, "ns1:StructuredRegulatoryReporting3");
	case SOAP_TYPE_PointerTons1__RegulatoryAuthority2:
		return soap_in_PointerTons1__RegulatoryAuthority2(soap, tag, NULL, "ns1:RegulatoryAuthority2");
	case SOAP_TYPE_PointerTons1__RegulatoryReportingType1Code:
		return soap_in_PointerTons1__RegulatoryReportingType1Code(soap, tag, NULL, "ns1:RegulatoryReportingType1Code");
	case SOAP_TYPE_PointerTons1__ReferredDocumentType3Choice:
		return soap_in_PointerTons1__ReferredDocumentType3Choice(soap, tag, NULL, "ns1:ReferredDocumentType3Choice");
	case SOAP_TYPE_PointerTons1__DocumentLineInformation1:
		return soap_in_PointerTons1__DocumentLineInformation1(soap, tag, NULL, "ns1:DocumentLineInformation1");
	case SOAP_TYPE_PointerTons1__ReferredDocumentType4:
		return soap_in_PointerTons1__ReferredDocumentType4(soap, tag, NULL, "ns1:ReferredDocumentType4");
	case SOAP_TYPE_PointerTons1__ExternalPurpose1Code:
		return soap_in_PointerTons1__ExternalPurpose1Code(soap, tag, NULL, "ns1:ExternalPurpose1Code");
	case SOAP_TYPE_PointerTons1__ExternalProxyAccountType1Code:
		return soap_in_PointerTons1__ExternalProxyAccountType1Code(soap, tag, NULL, "ns1:ExternalProxyAccountType1Code");
	case SOAP_TYPE_PointerTons1__ProxyAccountType1Choice:
		return soap_in_PointerTons1__ProxyAccountType1Choice(soap, tag, NULL, "ns1:ProxyAccountType1Choice");
	case SOAP_TYPE_PointerTons1__Max16Text:
		return soap_in_PointerTons1__Max16Text(soap, tag, NULL, "ns1:Max16Text");
	case SOAP_TYPE_PointerTons1__AddressType3Choice:
		return soap_in_PointerTons1__AddressType3Choice(soap, tag, NULL, "ns1:AddressType3Choice");
	case SOAP_TYPE_PointerTons1__ExternalPersonIdentification1Code:
		return soap_in_PointerTons1__ExternalPersonIdentification1Code(soap, tag, NULL, "ns1:ExternalPersonIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericPersonIdentification1:
		return soap_in_PointerTons1__GenericPersonIdentification1(soap, tag, NULL, "ns1:GenericPersonIdentification1");
	case SOAP_TYPE_PointerTons1__DateAndPlaceOfBirth1:
		return soap_in_PointerTons1__DateAndPlaceOfBirth1(soap, tag, NULL, "ns1:DateAndPlaceOfBirth1");
	case SOAP_TYPE_PointerTons1__CreditTransferTransaction54:
		return soap_in_PointerTons1__CreditTransferTransaction54(soap, tag, NULL, "ns1:CreditTransferTransaction54");
	case SOAP_TYPE_PointerTons1__DateAndDateTime2Choice:
		return soap_in_PointerTons1__DateAndDateTime2Choice(soap, tag, NULL, "ns1:DateAndDateTime2Choice");
	case SOAP_TYPE_PointerTons1__Max15NumericText:
		return soap_in_PointerTons1__Max15NumericText(soap, tag, NULL, "ns1:Max15NumericText");
	case SOAP_TYPE_PointerTons1__BatchBookingIndicator:
		return soap_in_PointerTons1__BatchBookingIndicator(soap, tag, NULL, "ns1:BatchBookingIndicator");
	case SOAP_TYPE_PointerTons1__AdviceType1:
		return soap_in_PointerTons1__AdviceType1(soap, tag, NULL, "ns1:AdviceType1");
	case SOAP_TYPE_PointerTons1__UUIDv4Identifier:
		return soap_in_PointerTons1__UUIDv4Identifier(soap, tag, NULL, "ns1:UUIDv4Identifier");
	case SOAP_TYPE_PointerTons1__Contact4:
		return soap_in_PointerTons1__Contact4(soap, tag, NULL, "ns1:Contact4");
	case SOAP_TYPE_PointerTons1__CountryCode:
		return soap_in_PointerTons1__CountryCode(soap, tag, NULL, "ns1:CountryCode");
	case SOAP_TYPE_PointerTons1__Party38Choice:
		return soap_in_PointerTons1__Party38Choice(soap, tag, NULL, "ns1:Party38Choice");
	case SOAP_TYPE_PointerTons1__PersonIdentification13:
		return soap_in_PointerTons1__PersonIdentification13(soap, tag, NULL, "ns1:PersonIdentification13");
	case SOAP_TYPE_PointerTons1__OrganisationIdentification29:
		return soap_in_PointerTons1__OrganisationIdentification29(soap, tag, NULL, "ns1:OrganisationIdentification29");
	case SOAP_TYPE_PointerTons1__ExternalOrganisationIdentification1Code:
		return soap_in_PointerTons1__ExternalOrganisationIdentification1Code(soap, tag, NULL, "ns1:ExternalOrganisationIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericOrganisationIdentification1:
		return soap_in_PointerTons1__GenericOrganisationIdentification1(soap, tag, NULL, "ns1:GenericOrganisationIdentification1");
	case SOAP_TYPE_PointerTons1__AnyBICDec2014Identifier:
		return soap_in_PointerTons1__AnyBICDec2014Identifier(soap, tag, NULL, "ns1:AnyBICDec2014Identifier");
	case SOAP_TYPE_PointerTons1__MandateClassification1Choice:
		return soap_in_PointerTons1__MandateClassification1Choice(soap, tag, NULL, "ns1:MandateClassification1Choice");
	case SOAP_TYPE_PointerTons1__CategoryPurpose1Choice:
		return soap_in_PointerTons1__CategoryPurpose1Choice(soap, tag, NULL, "ns1:CategoryPurpose1Choice");
	case SOAP_TYPE_PointerTons1__LocalInstrument2Choice:
		return soap_in_PointerTons1__LocalInstrument2Choice(soap, tag, NULL, "ns1:LocalInstrument2Choice");
	case SOAP_TYPE_PointerTons1__ServiceLevel8Choice:
		return soap_in_PointerTons1__ServiceLevel8Choice(soap, tag, NULL, "ns1:ServiceLevel8Choice");
	case SOAP_TYPE_PointerTons1__ExternalMandateSetupReason1Code:
		return soap_in_PointerTons1__ExternalMandateSetupReason1Code(soap, tag, NULL, "ns1:ExternalMandateSetupReason1Code");
	case SOAP_TYPE_PointerTons1__ExternalLocalInstrument1Code:
		return soap_in_PointerTons1__ExternalLocalInstrument1Code(soap, tag, NULL, "ns1:ExternalLocalInstrument1Code");
	case SOAP_TYPE_PointerTons1__ExternalDebtorAgentInstruction1Code:
		return soap_in_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, tag, NULL, "ns1:ExternalDebtorAgentInstruction1Code");
	case SOAP_TYPE_PointerTons1__ExternalCreditorAgentInstruction1Code:
		return soap_in_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, tag, NULL, "ns1:ExternalCreditorAgentInstruction1Code");
	case SOAP_TYPE_PointerTons1__PaymentInitiationSource1:
		return soap_in_PointerTons1__PaymentInitiationSource1(soap, tag, NULL, "ns1:PaymentInitiationSource1");
	case SOAP_TYPE_PointerTons1__DecimalNumber:
		return soap_in_PointerTons1__DecimalNumber(soap, tag, NULL, "ns1:DecimalNumber");
	case SOAP_TYPE_PointerTons1__Authorisation1Choice:
		return soap_in_PointerTons1__Authorisation1Choice(soap, tag, NULL, "ns1:Authorisation1Choice");
	case SOAP_TYPE_PointerTons1__PersonIdentificationSchemeName1Choice:
		return soap_in_PointerTons1__PersonIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:PersonIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__OrganisationIdentificationSchemeName1Choice:
		return soap_in_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:OrganisationIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__FinancialIdentificationSchemeName1Choice:
		return soap_in_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, tag, NULL, "ns1:FinancialIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__AccountSchemeName1Choice:
		return soap_in_PointerTons1__AccountSchemeName1Choice(soap, tag, NULL, "ns1:AccountSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__ExternalGarnishmentType1Code:
		return soap_in_PointerTons1__ExternalGarnishmentType1Code(soap, tag, NULL, "ns1:ExternalGarnishmentType1Code");
	case SOAP_TYPE_PointerTons1__GarnishmentType1Choice:
		return soap_in_PointerTons1__GarnishmentType1Choice(soap, tag, NULL, "ns1:GarnishmentType1Choice");
	case SOAP_TYPE_PointerTons1__TrueFalseIndicator:
		return soap_in_PointerTons1__TrueFalseIndicator(soap, tag, NULL, "ns1:TrueFalseIndicator");
	case SOAP_TYPE_PointerTons1__GarnishmentType1:
		return soap_in_PointerTons1__GarnishmentType1(soap, tag, NULL, "ns1:GarnishmentType1");
	case SOAP_TYPE_PointerTons1__FrequencyAndMoment1:
		return soap_in_PointerTons1__FrequencyAndMoment1(soap, tag, NULL, "ns1:FrequencyAndMoment1");
	case SOAP_TYPE_PointerTons1__FrequencyPeriod1:
		return soap_in_PointerTons1__FrequencyPeriod1(soap, tag, NULL, "ns1:FrequencyPeriod1");
	case SOAP_TYPE_PointerTons1__GenericFinancialIdentification1:
		return soap_in_PointerTons1__GenericFinancialIdentification1(soap, tag, NULL, "ns1:GenericFinancialIdentification1");
	case SOAP_TYPE_PointerTons1__ClearingSystemMemberIdentification2:
		return soap_in_PointerTons1__ClearingSystemMemberIdentification2(soap, tag, NULL, "ns1:ClearingSystemMemberIdentification2");
	case SOAP_TYPE_PointerTons1__BICFIDec2014Identifier:
		return soap_in_PointerTons1__BICFIDec2014Identifier(soap, tag, NULL, "ns1:BICFIDec2014Identifier");
	case SOAP_TYPE_PointerTons1__ExternalFinancialInstitutionIdentification1Code:
		return soap_in_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, tag, NULL, "ns1:ExternalFinancialInstitutionIdentification1Code");
	case SOAP_TYPE_PointerTons1__ExchangeRateType1Code:
		return soap_in_PointerTons1__ExchangeRateType1Code(soap, tag, NULL, "ns1:ExchangeRateType1Code");
	case SOAP_TYPE_PointerTons1__BaseOneRate:
		return soap_in_PointerTons1__BaseOneRate(soap, tag, NULL, "ns1:BaseOneRate");
	case SOAP_TYPE_PointerTons1__ExternalDocumentLineType1Code:
		return soap_in_PointerTons1__ExternalDocumentLineType1Code(soap, tag, NULL, "ns1:ExternalDocumentLineType1Code");
	case SOAP_TYPE_PointerTons1__DocumentLineType1Choice:
		return soap_in_PointerTons1__DocumentLineType1Choice(soap, tag, NULL, "ns1:DocumentLineType1Choice");
	case SOAP_TYPE_PointerTons1__RemittanceAmount3:
		return soap_in_PointerTons1__RemittanceAmount3(soap, tag, NULL, "ns1:RemittanceAmount3");
	case SOAP_TYPE_PointerTons1__DocumentLineIdentification1:
		return soap_in_PointerTons1__DocumentLineIdentification1(soap, tag, NULL, "ns1:DocumentLineIdentification1");
	case SOAP_TYPE_PointerTons1__DocumentLineType1:
		return soap_in_PointerTons1__DocumentLineType1(soap, tag, NULL, "ns1:DocumentLineType1");
	case SOAP_TYPE_PointerTons1__Max4Text:
		return soap_in_PointerTons1__Max4Text(soap, tag, NULL, "ns1:Max4Text");
	case SOAP_TYPE_PointerTons1__CreditDebitCode:
		return soap_in_PointerTons1__CreditDebitCode(soap, tag, NULL, "ns1:CreditDebitCode");
	case SOAP_TYPE_PointerTons1__CustomerCreditTransferInitiationV11:
		return soap_in_PointerTons1__CustomerCreditTransferInitiationV11(soap, tag, NULL, "ns1:CustomerCreditTransferInitiationV11");
	case SOAP_TYPE_PointerTons1__ExternalDiscountAmountType1Code:
		return soap_in_PointerTons1__ExternalDiscountAmountType1Code(soap, tag, NULL, "ns1:ExternalDiscountAmountType1Code");
	case SOAP_TYPE_PointerTons1__DiscountAmountType1Choice:
		return soap_in_PointerTons1__DiscountAmountType1Choice(soap, tag, NULL, "ns1:DiscountAmountType1Choice");
	case SOAP_TYPE_PointerTons1__PaymentInstruction40:
		return soap_in_PointerTons1__PaymentInstruction40(soap, tag, NULL, "ns1:PaymentInstruction40");
	case SOAP_TYPE_PointerTons1__GroupHeader95:
		return soap_in_PointerTons1__GroupHeader95(soap, tag, NULL, "ns1:GroupHeader95");
	case SOAP_TYPE_PointerTons1__CreditorReferenceType1Choice:
		return soap_in_PointerTons1__CreditorReferenceType1Choice(soap, tag, NULL, "ns1:CreditorReferenceType1Choice");
	case SOAP_TYPE_PointerTons1__CreditorReferenceType2:
		return soap_in_PointerTons1__CreditorReferenceType2(soap, tag, NULL, "ns1:CreditorReferenceType2");
	case SOAP_TYPE_PointerTons1__SupplementaryData1:
		return soap_in_PointerTons1__SupplementaryData1(soap, tag, NULL, "ns1:SupplementaryData1");
	case SOAP_TYPE_PointerTons1__RemittanceInformation21:
		return soap_in_PointerTons1__RemittanceInformation21(soap, tag, NULL, "ns1:RemittanceInformation21");
	case SOAP_TYPE_PointerTons1__RemittanceLocation7:
		return soap_in_PointerTons1__RemittanceLocation7(soap, tag, NULL, "ns1:RemittanceLocation7");
	case SOAP_TYPE_PointerTons1__TaxInformation10:
		return soap_in_PointerTons1__TaxInformation10(soap, tag, NULL, "ns1:TaxInformation10");
	case SOAP_TYPE_PointerTons1__RegulatoryReporting3:
		return soap_in_PointerTons1__RegulatoryReporting3(soap, tag, NULL, "ns1:RegulatoryReporting3");
	case SOAP_TYPE_PointerTons1__Purpose2Choice:
		return soap_in_PointerTons1__Purpose2Choice(soap, tag, NULL, "ns1:Purpose2Choice");
	case SOAP_TYPE_PointerTons1__InstructionForDebtorAgent1:
		return soap_in_PointerTons1__InstructionForDebtorAgent1(soap, tag, NULL, "ns1:InstructionForDebtorAgent1");
	case SOAP_TYPE_PointerTons1__InstructionForCreditorAgent3:
		return soap_in_PointerTons1__InstructionForCreditorAgent3(soap, tag, NULL, "ns1:InstructionForCreditorAgent3");
	case SOAP_TYPE_PointerTons1__CashAccount40:
		return soap_in_PointerTons1__CashAccount40(soap, tag, NULL, "ns1:CashAccount40");
	case SOAP_TYPE_PointerTons1__BranchAndFinancialInstitutionIdentification6:
		return soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, tag, NULL, "ns1:BranchAndFinancialInstitutionIdentification6");
	case SOAP_TYPE_PointerTons1__PartyIdentification135:
		return soap_in_PointerTons1__PartyIdentification135(soap, tag, NULL, "ns1:PartyIdentification135");
	case SOAP_TYPE_PointerTons1__Cheque11:
		return soap_in_PointerTons1__Cheque11(soap, tag, NULL, "ns1:Cheque11");
	case SOAP_TYPE_PointerTons1__CreditTransferMandateData1:
		return soap_in_PointerTons1__CreditTransferMandateData1(soap, tag, NULL, "ns1:CreditTransferMandateData1");
	case SOAP_TYPE_PointerTons1__ChargeBearerType1Code:
		return soap_in_PointerTons1__ChargeBearerType1Code(soap, tag, NULL, "ns1:ChargeBearerType1Code");
	case SOAP_TYPE_PointerTons1__ExchangeRate1:
		return soap_in_PointerTons1__ExchangeRate1(soap, tag, NULL, "ns1:ExchangeRate1");
	case SOAP_TYPE_PointerTons1__AmountType4Choice:
		return soap_in_PointerTons1__AmountType4Choice(soap, tag, NULL, "ns1:AmountType4Choice");
	case SOAP_TYPE_PointerTons1__PaymentTypeInformation26:
		return soap_in_PointerTons1__PaymentTypeInformation26(soap, tag, NULL, "ns1:PaymentTypeInformation26");
	case SOAP_TYPE_PointerTons1__PaymentIdentification6:
		return soap_in_PointerTons1__PaymentIdentification6(soap, tag, NULL, "ns1:PaymentIdentification6");
	case SOAP_TYPE_PointerTons1__MandateSetupReason1Choice:
		return soap_in_PointerTons1__MandateSetupReason1Choice(soap, tag, NULL, "ns1:MandateSetupReason1Choice");
	case SOAP_TYPE_PointerTons1__Frequency36Choice:
		return soap_in_PointerTons1__Frequency36Choice(soap, tag, NULL, "ns1:Frequency36Choice");
	case SOAP_TYPE_PointerTons1__Max10KBinary:
		return soap_in_PointerTons1__Max10KBinary(soap, tag, NULL, "ns1:Max10KBinary");
	case SOAP_TYPE_PointerTons1__ISODateTime:
		return soap_in_PointerTons1__ISODateTime(soap, tag, NULL, "ns1:ISODateTime");
	case SOAP_TYPE_PointerTons1__MandateTypeInformation2:
		return soap_in_PointerTons1__MandateTypeInformation2(soap, tag, NULL, "ns1:MandateTypeInformation2");
	case SOAP_TYPE_PointerTons1__PreferredContactMethod1Code:
		return soap_in_PointerTons1__PreferredContactMethod1Code(soap, tag, NULL, "ns1:PreferredContactMethod1Code");
	case SOAP_TYPE_PointerTons1__OtherContact1:
		return soap_in_PointerTons1__OtherContact1(soap, tag, NULL, "ns1:OtherContact1");
	case SOAP_TYPE_PointerTons1__Max2048Text:
		return soap_in_PointerTons1__Max2048Text(soap, tag, NULL, "ns1:Max2048Text");
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		return soap_in_PointerTons1__PhoneNumber(soap, tag, NULL, "ns1:PhoneNumber");
	case SOAP_TYPE_PointerTons1__NamePrefix2Code:
		return soap_in_PointerTons1__NamePrefix2Code(soap, tag, NULL, "ns1:NamePrefix2Code");
	case SOAP_TYPE_PointerTons1__ClearingSystemIdentification2Choice:
		return soap_in_PointerTons1__ClearingSystemIdentification2Choice(soap, tag, NULL, "ns1:ClearingSystemIdentification2Choice");
	case SOAP_TYPE_PointerTons1__ExternalClearingSystemIdentification1Code:
		return soap_in_PointerTons1__ExternalClearingSystemIdentification1Code(soap, tag, NULL, "ns1:ExternalClearingSystemIdentification1Code");
	case SOAP_TYPE_PointerTons1__ISODate:
		return soap_in_PointerTons1__ISODate(soap, tag, NULL, "ns1:ISODate");
	case SOAP_TYPE_PointerTons1__Priority2Code:
		return soap_in_PointerTons1__Priority2Code(soap, tag, NULL, "ns1:Priority2Code");
	case SOAP_TYPE_PointerTons1__ChequeDeliveryMethod1Choice:
		return soap_in_PointerTons1__ChequeDeliveryMethod1Choice(soap, tag, NULL, "ns1:ChequeDeliveryMethod1Choice");
	case SOAP_TYPE_PointerTons1__NameAndAddress16:
		return soap_in_PointerTons1__NameAndAddress16(soap, tag, NULL, "ns1:NameAndAddress16");
	case SOAP_TYPE_PointerTons1__ChequeType2Code:
		return soap_in_PointerTons1__ChequeType2Code(soap, tag, NULL, "ns1:ChequeType2Code");
	case SOAP_TYPE_PointerTons1__ExternalCategoryPurpose1Code:
		return soap_in_PointerTons1__ExternalCategoryPurpose1Code(soap, tag, NULL, "ns1:ExternalCategoryPurpose1Code");
	case SOAP_TYPE_PointerTons1__ExternalCashAccountType1Code:
		return soap_in_PointerTons1__ExternalCashAccountType1Code(soap, tag, NULL, "ns1:ExternalCashAccountType1Code");
	case SOAP_TYPE_PointerTons1__ProxyAccountIdentification1:
		return soap_in_PointerTons1__ProxyAccountIdentification1(soap, tag, NULL, "ns1:ProxyAccountIdentification1");
	case SOAP_TYPE_PointerTons1__Max70Text:
		return soap_in_PointerTons1__Max70Text(soap, tag, NULL, "ns1:Max70Text");
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyCode:
		return soap_in_PointerTons1__ActiveOrHistoricCurrencyCode(soap, tag, NULL, "ns1:ActiveOrHistoricCurrencyCode");
	case SOAP_TYPE_PointerTons1__CashAccountType2Choice:
		return soap_in_PointerTons1__CashAccountType2Choice(soap, tag, NULL, "ns1:CashAccountType2Choice");
	case SOAP_TYPE_PointerTons1__AccountIdentification4Choice:
		return soap_in_PointerTons1__AccountIdentification4Choice(soap, tag, NULL, "ns1:AccountIdentification4Choice");
	case SOAP_TYPE_PointerTons1__PostalAddress24:
		return soap_in_PointerTons1__PostalAddress24(soap, tag, NULL, "ns1:PostalAddress24");
	case SOAP_TYPE_PointerTons1__Max140Text:
		return soap_in_PointerTons1__Max140Text(soap, tag, NULL, "ns1:Max140Text");
	case SOAP_TYPE_PointerTons1__LEIIdentifier:
		return soap_in_PointerTons1__LEIIdentifier(soap, tag, NULL, "ns1:LEIIdentifier");
	case SOAP_TYPE_PointerTons1__BranchData3:
		return soap_in_PointerTons1__BranchData3(soap, tag, NULL, "ns1:BranchData3");
	case SOAP_TYPE_PointerTons1__FinancialInstitutionIdentification18:
		return soap_in_PointerTons1__FinancialInstitutionIdentification18(soap, tag, NULL, "ns1:FinancialInstitutionIdentification18");
	case SOAP_TYPE_PointerTons1__Max128Text:
		return soap_in_PointerTons1__Max128Text(soap, tag, NULL, "ns1:Max128Text");
	case SOAP_TYPE_PointerTons1__EquivalentAmount2:
		return soap_in_PointerTons1__EquivalentAmount2(soap, tag, NULL, "ns1:EquivalentAmount2");
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyAndAmount:
		return soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, tag, NULL, "ns1:ActiveOrHistoricCurrencyAndAmount");
	case SOAP_TYPE_PointerTons1__AdviceType1Choice:
		return soap_in_PointerTons1__AdviceType1Choice(soap, tag, NULL, "ns1:AdviceType1Choice");
	case SOAP_TYPE_PointerTons1__GenericIdentification30:
		return soap_in_PointerTons1__GenericIdentification30(soap, tag, NULL, "ns1:GenericIdentification30");
	case SOAP_TYPE_PointerTons1__Max35Text:
		return soap_in_PointerTons1__Max35Text(soap, tag, NULL, "ns1:Max35Text");
	case SOAP_TYPE_PointerTons1__ExternalAccountIdentification1Code:
		return soap_in_PointerTons1__ExternalAccountIdentification1Code(soap, tag, NULL, "ns1:ExternalAccountIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericAccountIdentification1:
		return soap_in_PointerTons1__GenericAccountIdentification1(soap, tag, NULL, "ns1:GenericAccountIdentification1");
	case SOAP_TYPE_PointerTons1__IBAN2007Identifier:
		return soap_in_PointerTons1__IBAN2007Identifier(soap, tag, NULL, "ns1:IBAN2007Identifier");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:UUIDv4Identifier"))
		{	*type = SOAP_TYPE_ns1__UUIDv4Identifier;
			return soap_in_ns1__UUIDv4Identifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneNumber"))
		{	*type = SOAP_TYPE_ns1__PhoneNumber;
			return soap_in_ns1__PhoneNumber(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PercentageRate"))
		{	*type = SOAP_TYPE_ns1__PercentageRate;
			return soap_in_ns1__PercentageRate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Number"))
		{	*type = SOAP_TYPE_ns1__Number;
			return soap_in_ns1__Number(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max70Text"))
		{	*type = SOAP_TYPE_ns1__Max70Text;
			return soap_in_ns1__Max70Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max4Text"))
		{	*type = SOAP_TYPE_ns1__Max4Text;
			return soap_in_ns1__Max4Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max35Text"))
		{	*type = SOAP_TYPE_ns1__Max35Text;
			return soap_in_ns1__Max35Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max350Text"))
		{	*type = SOAP_TYPE_ns1__Max350Text;
			return soap_in_ns1__Max350Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max34Text"))
		{	*type = SOAP_TYPE_ns1__Max34Text;
			return soap_in_ns1__Max34Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max2048Text"))
		{	*type = SOAP_TYPE_ns1__Max2048Text;
			return soap_in_ns1__Max2048Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max16Text"))
		{	*type = SOAP_TYPE_ns1__Max16Text;
			return soap_in_ns1__Max16Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max15NumericText"))
		{	*type = SOAP_TYPE_ns1__Max15NumericText;
			return soap_in_ns1__Max15NumericText(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max140Text"))
		{	*type = SOAP_TYPE_ns1__Max140Text;
			return soap_in_ns1__Max140Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max128Text"))
		{	*type = SOAP_TYPE_ns1__Max128Text;
			return soap_in_ns1__Max128Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max10Text"))
		{	*type = SOAP_TYPE_ns1__Max10Text;
			return soap_in_ns1__Max10Text(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Max10KBinary"))
		{	*type = SOAP_TYPE_ns1__Max10KBinary;
			return soap_in_ns1__Max10KBinary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LEIIdentifier"))
		{	*type = SOAP_TYPE_ns1__LEIIdentifier;
			return soap_in_ns1__LEIIdentifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ISOYear"))
		{	*type = SOAP_TYPE_ns1__ISOYear;
			return soap_in_ns1__ISOYear(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ISODate"))
		{	*type = SOAP_TYPE_ns1__ISODate;
			return soap_in_ns1__ISODate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IBAN2007Identifier"))
		{	*type = SOAP_TYPE_ns1__IBAN2007Identifier;
			return soap_in_ns1__IBAN2007Identifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalTaxAmountType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalTaxAmountType1Code;
			return soap_in_ns1__ExternalTaxAmountType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalServiceLevel1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalServiceLevel1Code;
			return soap_in_ns1__ExternalServiceLevel1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalPurpose1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalPurpose1Code;
			return soap_in_ns1__ExternalPurpose1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalProxyAccountType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalProxyAccountType1Code;
			return soap_in_ns1__ExternalProxyAccountType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalPersonIdentification1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalPersonIdentification1Code;
			return soap_in_ns1__ExternalPersonIdentification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalOrganisationIdentification1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code;
			return soap_in_ns1__ExternalOrganisationIdentification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalMandateSetupReason1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalMandateSetupReason1Code;
			return soap_in_ns1__ExternalMandateSetupReason1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalLocalInstrument1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalLocalInstrument1Code;
			return soap_in_ns1__ExternalLocalInstrument1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalGarnishmentType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalGarnishmentType1Code;
			return soap_in_ns1__ExternalGarnishmentType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalFinancialInstitutionIdentification1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code;
			return soap_in_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalDocumentLineType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalDocumentLineType1Code;
			return soap_in_ns1__ExternalDocumentLineType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalDiscountAmountType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalDiscountAmountType1Code;
			return soap_in_ns1__ExternalDiscountAmountType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalDebtorAgentInstruction1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code;
			return soap_in_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalCreditorAgentInstruction1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code;
			return soap_in_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalClearingSystemIdentification1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code;
			return soap_in_ns1__ExternalClearingSystemIdentification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalCategoryPurpose1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalCategoryPurpose1Code;
			return soap_in_ns1__ExternalCategoryPurpose1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalCashAccountType1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalCashAccountType1Code;
			return soap_in_ns1__ExternalCashAccountType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExternalAccountIdentification1Code"))
		{	*type = SOAP_TYPE_ns1__ExternalAccountIdentification1Code;
			return soap_in_ns1__ExternalAccountIdentification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Exact4AlphaNumericText"))
		{	*type = SOAP_TYPE_ns1__Exact4AlphaNumericText;
			return soap_in_ns1__Exact4AlphaNumericText(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Exact2NumericText"))
		{	*type = SOAP_TYPE_ns1__Exact2NumericText;
			return soap_in_ns1__Exact2NumericText(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DecimalNumber"))
		{	*type = SOAP_TYPE_ns1__DecimalNumber;
			return soap_in_ns1__DecimalNumber(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryCode"))
		{	*type = SOAP_TYPE_ns1__CountryCode;
			return soap_in_ns1__CountryCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BaseOneRate"))
		{	*type = SOAP_TYPE_ns1__BaseOneRate;
			return soap_in_ns1__BaseOneRate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BICFIDec2014Identifier"))
		{	*type = SOAP_TYPE_ns1__BICFIDec2014Identifier;
			return soap_in_ns1__BICFIDec2014Identifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AnyBICDec2014Identifier"))
		{	*type = SOAP_TYPE_ns1__AnyBICDec2014Identifier;
			return soap_in_ns1__AnyBICDec2014Identifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActiveOrHistoricCurrencyCode"))
		{	*type = SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode;
			return soap_in_ns1__ActiveOrHistoricCurrencyCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActiveOrHistoricCurrencyAndAmount_SimpleType"))
		{	*type = SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType;
			return soap_in_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxRecordDetails3"))
		{	*type = SOAP_TYPE_ns1__TaxRecordDetails3;
			return soap_in_ns1__TaxRecordDetails3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxRecord3"))
		{	*type = SOAP_TYPE_ns1__TaxRecord3;
			return soap_in_ns1__TaxRecord3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxPeriod3"))
		{	*type = SOAP_TYPE_ns1__TaxPeriod3;
			return soap_in_ns1__TaxPeriod3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxParty2"))
		{	*type = SOAP_TYPE_ns1__TaxParty2;
			return soap_in_ns1__TaxParty2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxParty1"))
		{	*type = SOAP_TYPE_ns1__TaxParty1;
			return soap_in_ns1__TaxParty1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxInformation10"))
		{	*type = SOAP_TYPE_ns1__TaxInformation10;
			return soap_in_ns1__TaxInformation10(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxData1"))
		{	*type = SOAP_TYPE_ns1__TaxData1;
			return soap_in_ns1__TaxData1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxAuthorisation1"))
		{	*type = SOAP_TYPE_ns1__TaxAuthorisation1;
			return soap_in_ns1__TaxAuthorisation1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxAmountType1Choice"))
		{	*type = SOAP_TYPE_ns1__TaxAmountType1Choice;
			return soap_in_ns1__TaxAmountType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxAmountAndType1"))
		{	*type = SOAP_TYPE_ns1__TaxAmountAndType1;
			return soap_in_ns1__TaxAmountAndType1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxAmount3"))
		{	*type = SOAP_TYPE_ns1__TaxAmount3;
			return soap_in_ns1__TaxAmount3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SupplementaryDataEnvelope1"))
		{	*type = SOAP_TYPE_ns1__SupplementaryDataEnvelope1;
			return soap_in_ns1__SupplementaryDataEnvelope1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SupplementaryData1"))
		{	*type = SOAP_TYPE_ns1__SupplementaryData1;
			return soap_in_ns1__SupplementaryData1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StructuredRemittanceInformation17"))
		{	*type = SOAP_TYPE_ns1__StructuredRemittanceInformation17;
			return soap_in_ns1__StructuredRemittanceInformation17(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StructuredRegulatoryReporting3"))
		{	*type = SOAP_TYPE_ns1__StructuredRegulatoryReporting3;
			return soap_in_ns1__StructuredRegulatoryReporting3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServiceLevel8Choice"))
		{	*type = SOAP_TYPE_ns1__ServiceLevel8Choice;
			return soap_in_ns1__ServiceLevel8Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceLocationData1"))
		{	*type = SOAP_TYPE_ns1__RemittanceLocationData1;
			return soap_in_ns1__RemittanceLocationData1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceLocation7"))
		{	*type = SOAP_TYPE_ns1__RemittanceLocation7;
			return soap_in_ns1__RemittanceLocation7(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceInformation21"))
		{	*type = SOAP_TYPE_ns1__RemittanceInformation21;
			return soap_in_ns1__RemittanceInformation21(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceAmount3"))
		{	*type = SOAP_TYPE_ns1__RemittanceAmount3;
			return soap_in_ns1__RemittanceAmount3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceAmount2"))
		{	*type = SOAP_TYPE_ns1__RemittanceAmount2;
			return soap_in_ns1__RemittanceAmount2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegulatoryReporting3"))
		{	*type = SOAP_TYPE_ns1__RegulatoryReporting3;
			return soap_in_ns1__RegulatoryReporting3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegulatoryAuthority2"))
		{	*type = SOAP_TYPE_ns1__RegulatoryAuthority2;
			return soap_in_ns1__RegulatoryAuthority2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReferredDocumentType4"))
		{	*type = SOAP_TYPE_ns1__ReferredDocumentType4;
			return soap_in_ns1__ReferredDocumentType4(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReferredDocumentType3Choice"))
		{	*type = SOAP_TYPE_ns1__ReferredDocumentType3Choice;
			return soap_in_ns1__ReferredDocumentType3Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReferredDocumentInformation7"))
		{	*type = SOAP_TYPE_ns1__ReferredDocumentInformation7;
			return soap_in_ns1__ReferredDocumentInformation7(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Purpose2Choice"))
		{	*type = SOAP_TYPE_ns1__Purpose2Choice;
			return soap_in_ns1__Purpose2Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProxyAccountType1Choice"))
		{	*type = SOAP_TYPE_ns1__ProxyAccountType1Choice;
			return soap_in_ns1__ProxyAccountType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProxyAccountIdentification1"))
		{	*type = SOAP_TYPE_ns1__ProxyAccountIdentification1;
			return soap_in_ns1__ProxyAccountIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PostalAddress24"))
		{	*type = SOAP_TYPE_ns1__PostalAddress24;
			return soap_in_ns1__PostalAddress24(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PersonIdentificationSchemeName1Choice"))
		{	*type = SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice;
			return soap_in_ns1__PersonIdentificationSchemeName1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PersonIdentification13"))
		{	*type = SOAP_TYPE_ns1__PersonIdentification13;
			return soap_in_ns1__PersonIdentification13(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentTypeInformation26"))
		{	*type = SOAP_TYPE_ns1__PaymentTypeInformation26;
			return soap_in_ns1__PaymentTypeInformation26(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentInstruction40"))
		{	*type = SOAP_TYPE_ns1__PaymentInstruction40;
			return soap_in_ns1__PaymentInstruction40(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentInitiationSource1"))
		{	*type = SOAP_TYPE_ns1__PaymentInitiationSource1;
			return soap_in_ns1__PaymentInitiationSource1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentIdentification6"))
		{	*type = SOAP_TYPE_ns1__PaymentIdentification6;
			return soap_in_ns1__PaymentIdentification6(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PartyIdentification135"))
		{	*type = SOAP_TYPE_ns1__PartyIdentification135;
			return soap_in_ns1__PartyIdentification135(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Party38Choice"))
		{	*type = SOAP_TYPE_ns1__Party38Choice;
			return soap_in_ns1__Party38Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtherContact1"))
		{	*type = SOAP_TYPE_ns1__OtherContact1;
			return soap_in_ns1__OtherContact1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrganisationIdentificationSchemeName1Choice"))
		{	*type = SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice;
			return soap_in_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrganisationIdentification29"))
		{	*type = SOAP_TYPE_ns1__OrganisationIdentification29;
			return soap_in_ns1__OrganisationIdentification29(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NameAndAddress16"))
		{	*type = SOAP_TYPE_ns1__NameAndAddress16;
			return soap_in_ns1__NameAndAddress16(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MandateTypeInformation2"))
		{	*type = SOAP_TYPE_ns1__MandateTypeInformation2;
			return soap_in_ns1__MandateTypeInformation2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MandateSetupReason1Choice"))
		{	*type = SOAP_TYPE_ns1__MandateSetupReason1Choice;
			return soap_in_ns1__MandateSetupReason1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MandateClassification1Choice"))
		{	*type = SOAP_TYPE_ns1__MandateClassification1Choice;
			return soap_in_ns1__MandateClassification1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocalInstrument2Choice"))
		{	*type = SOAP_TYPE_ns1__LocalInstrument2Choice;
			return soap_in_ns1__LocalInstrument2Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InstructionForDebtorAgent1"))
		{	*type = SOAP_TYPE_ns1__InstructionForDebtorAgent1;
			return soap_in_ns1__InstructionForDebtorAgent1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InstructionForCreditorAgent3"))
		{	*type = SOAP_TYPE_ns1__InstructionForCreditorAgent3;
			return soap_in_ns1__InstructionForCreditorAgent3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GroupHeader95"))
		{	*type = SOAP_TYPE_ns1__GroupHeader95;
			return soap_in_ns1__GroupHeader95(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericPersonIdentification1"))
		{	*type = SOAP_TYPE_ns1__GenericPersonIdentification1;
			return soap_in_ns1__GenericPersonIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericOrganisationIdentification1"))
		{	*type = SOAP_TYPE_ns1__GenericOrganisationIdentification1;
			return soap_in_ns1__GenericOrganisationIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericIdentification30"))
		{	*type = SOAP_TYPE_ns1__GenericIdentification30;
			return soap_in_ns1__GenericIdentification30(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericFinancialIdentification1"))
		{	*type = SOAP_TYPE_ns1__GenericFinancialIdentification1;
			return soap_in_ns1__GenericFinancialIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericAccountIdentification1"))
		{	*type = SOAP_TYPE_ns1__GenericAccountIdentification1;
			return soap_in_ns1__GenericAccountIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GarnishmentType1Choice"))
		{	*type = SOAP_TYPE_ns1__GarnishmentType1Choice;
			return soap_in_ns1__GarnishmentType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GarnishmentType1"))
		{	*type = SOAP_TYPE_ns1__GarnishmentType1;
			return soap_in_ns1__GarnishmentType1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Garnishment3"))
		{	*type = SOAP_TYPE_ns1__Garnishment3;
			return soap_in_ns1__Garnishment3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FrequencyPeriod1"))
		{	*type = SOAP_TYPE_ns1__FrequencyPeriod1;
			return soap_in_ns1__FrequencyPeriod1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FrequencyAndMoment1"))
		{	*type = SOAP_TYPE_ns1__FrequencyAndMoment1;
			return soap_in_ns1__FrequencyAndMoment1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Frequency36Choice"))
		{	*type = SOAP_TYPE_ns1__Frequency36Choice;
			return soap_in_ns1__Frequency36Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FinancialInstitutionIdentification18"))
		{	*type = SOAP_TYPE_ns1__FinancialInstitutionIdentification18;
			return soap_in_ns1__FinancialInstitutionIdentification18(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FinancialIdentificationSchemeName1Choice"))
		{	*type = SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice;
			return soap_in_ns1__FinancialIdentificationSchemeName1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeRate1"))
		{	*type = SOAP_TYPE_ns1__ExchangeRate1;
			return soap_in_ns1__ExchangeRate1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquivalentAmount2"))
		{	*type = SOAP_TYPE_ns1__EquivalentAmount2;
			return soap_in_ns1__EquivalentAmount2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentLineType1Choice"))
		{	*type = SOAP_TYPE_ns1__DocumentLineType1Choice;
			return soap_in_ns1__DocumentLineType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentLineType1"))
		{	*type = SOAP_TYPE_ns1__DocumentLineType1;
			return soap_in_ns1__DocumentLineType1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentLineInformation1"))
		{	*type = SOAP_TYPE_ns1__DocumentLineInformation1;
			return soap_in_ns1__DocumentLineInformation1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentLineIdentification1"))
		{	*type = SOAP_TYPE_ns1__DocumentLineIdentification1;
			return soap_in_ns1__DocumentLineIdentification1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentAdjustment1"))
		{	*type = SOAP_TYPE_ns1__DocumentAdjustment1;
			return soap_in_ns1__DocumentAdjustment1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Document"))
		{	*type = SOAP_TYPE_ns1__Document;
			return soap_in_ns1__Document(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiscountAmountType1Choice"))
		{	*type = SOAP_TYPE_ns1__DiscountAmountType1Choice;
			return soap_in_ns1__DiscountAmountType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiscountAmountAndType1"))
		{	*type = SOAP_TYPE_ns1__DiscountAmountAndType1;
			return soap_in_ns1__DiscountAmountAndType1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DatePeriod2"))
		{	*type = SOAP_TYPE_ns1__DatePeriod2;
			return soap_in_ns1__DatePeriod2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateAndPlaceOfBirth1"))
		{	*type = SOAP_TYPE_ns1__DateAndPlaceOfBirth1;
			return soap_in_ns1__DateAndPlaceOfBirth1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateAndDateTime2Choice"))
		{	*type = SOAP_TYPE_ns1__DateAndDateTime2Choice;
			return soap_in_ns1__DateAndDateTime2Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomerCreditTransferInitiationV11"))
		{	*type = SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11;
			return soap_in_ns1__CustomerCreditTransferInitiationV11(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditorReferenceType2"))
		{	*type = SOAP_TYPE_ns1__CreditorReferenceType2;
			return soap_in_ns1__CreditorReferenceType2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditorReferenceType1Choice"))
		{	*type = SOAP_TYPE_ns1__CreditorReferenceType1Choice;
			return soap_in_ns1__CreditorReferenceType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditorReferenceInformation2"))
		{	*type = SOAP_TYPE_ns1__CreditorReferenceInformation2;
			return soap_in_ns1__CreditorReferenceInformation2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditTransferTransaction54"))
		{	*type = SOAP_TYPE_ns1__CreditTransferTransaction54;
			return soap_in_ns1__CreditTransferTransaction54(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditTransferMandateData1"))
		{	*type = SOAP_TYPE_ns1__CreditTransferMandateData1;
			return soap_in_ns1__CreditTransferMandateData1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Contact4"))
		{	*type = SOAP_TYPE_ns1__Contact4;
			return soap_in_ns1__Contact4(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearingSystemMemberIdentification2"))
		{	*type = SOAP_TYPE_ns1__ClearingSystemMemberIdentification2;
			return soap_in_ns1__ClearingSystemMemberIdentification2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearingSystemIdentification2Choice"))
		{	*type = SOAP_TYPE_ns1__ClearingSystemIdentification2Choice;
			return soap_in_ns1__ClearingSystemIdentification2Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChequeDeliveryMethod1Choice"))
		{	*type = SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice;
			return soap_in_ns1__ChequeDeliveryMethod1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Cheque11"))
		{	*type = SOAP_TYPE_ns1__Cheque11;
			return soap_in_ns1__Cheque11(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CategoryPurpose1Choice"))
		{	*type = SOAP_TYPE_ns1__CategoryPurpose1Choice;
			return soap_in_ns1__CategoryPurpose1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CashAccountType2Choice"))
		{	*type = SOAP_TYPE_ns1__CashAccountType2Choice;
			return soap_in_ns1__CashAccountType2Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CashAccount40"))
		{	*type = SOAP_TYPE_ns1__CashAccount40;
			return soap_in_ns1__CashAccount40(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BranchData3"))
		{	*type = SOAP_TYPE_ns1__BranchData3;
			return soap_in_ns1__BranchData3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BranchAndFinancialInstitutionIdentification6"))
		{	*type = SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6;
			return soap_in_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Authorisation1Choice"))
		{	*type = SOAP_TYPE_ns1__Authorisation1Choice;
			return soap_in_ns1__Authorisation1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AmountType4Choice"))
		{	*type = SOAP_TYPE_ns1__AmountType4Choice;
			return soap_in_ns1__AmountType4Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AdviceType1Choice"))
		{	*type = SOAP_TYPE_ns1__AdviceType1Choice;
			return soap_in_ns1__AdviceType1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AdviceType1"))
		{	*type = SOAP_TYPE_ns1__AdviceType1;
			return soap_in_ns1__AdviceType1(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddressType3Choice"))
		{	*type = SOAP_TYPE_ns1__AddressType3Choice;
			return soap_in_ns1__AddressType3Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActiveOrHistoricCurrencyAndAmount"))
		{	*type = SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount;
			return soap_in_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccountSchemeName1Choice"))
		{	*type = SOAP_TYPE_ns1__AccountSchemeName1Choice;
			return soap_in_ns1__AccountSchemeName1Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccountIdentification4Choice"))
		{	*type = SOAP_TYPE_ns1__AccountIdentification4Choice;
			return soap_in_ns1__AccountIdentification4Choice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:gYear"))
		{	*type = SOAP_TYPE_xsd__gYear;
			return soap_in_xsd__gYear(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ISODateTime"))
		{	*type = SOAP_TYPE_ns1__ISODateTime;
			return soap_in_ns1__ISODateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrueFalseIndicator"))
		{	*type = SOAP_TYPE_ns1__TrueFalseIndicator;
			return soap_in_ns1__TrueFalseIndicator(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaxRecordPeriod1Code"))
		{	*type = SOAP_TYPE_ns1__TaxRecordPeriod1Code;
			return soap_in_ns1__TaxRecordPeriod1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemittanceLocationMethod2Code"))
		{	*type = SOAP_TYPE_ns1__RemittanceLocationMethod2Code;
			return soap_in_ns1__RemittanceLocationMethod2Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegulatoryReportingType1Code"))
		{	*type = SOAP_TYPE_ns1__RegulatoryReportingType1Code;
			return soap_in_ns1__RegulatoryReportingType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Priority2Code"))
		{	*type = SOAP_TYPE_ns1__Priority2Code;
			return soap_in_ns1__Priority2Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PreferredContactMethod1Code"))
		{	*type = SOAP_TYPE_ns1__PreferredContactMethod1Code;
			return soap_in_ns1__PreferredContactMethod1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentMethod3Code"))
		{	*type = SOAP_TYPE_ns1__PaymentMethod3Code;
			return soap_in_ns1__PaymentMethod3Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NamePrefix2Code"))
		{	*type = SOAP_TYPE_ns1__NamePrefix2Code;
			return soap_in_ns1__NamePrefix2Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MandateClassification1Code"))
		{	*type = SOAP_TYPE_ns1__MandateClassification1Code;
			return soap_in_ns1__MandateClassification1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Frequency6Code"))
		{	*type = SOAP_TYPE_ns1__Frequency6Code;
			return soap_in_ns1__Frequency6Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeRateType1Code"))
		{	*type = SOAP_TYPE_ns1__ExchangeRateType1Code;
			return soap_in_ns1__ExchangeRateType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentType6Code"))
		{	*type = SOAP_TYPE_ns1__DocumentType6Code;
			return soap_in_ns1__DocumentType6Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentType3Code"))
		{	*type = SOAP_TYPE_ns1__DocumentType3Code;
			return soap_in_ns1__DocumentType3Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreditDebitCode"))
		{	*type = SOAP_TYPE_ns1__CreditDebitCode;
			return soap_in_ns1__CreditDebitCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChequeType2Code"))
		{	*type = SOAP_TYPE_ns1__ChequeType2Code;
			return soap_in_ns1__ChequeType2Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChequeDelivery1Code"))
		{	*type = SOAP_TYPE_ns1__ChequeDelivery1Code;
			return soap_in_ns1__ChequeDelivery1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChargeBearerType1Code"))
		{	*type = SOAP_TYPE_ns1__ChargeBearerType1Code;
			return soap_in_ns1__ChargeBearerType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchBookingIndicator"))
		{	*type = SOAP_TYPE_ns1__BatchBookingIndicator;
			return soap_in_ns1__BatchBookingIndicator(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Authorisation1Code"))
		{	*type = SOAP_TYPE_ns1__Authorisation1Code;
			return soap_in_ns1__Authorisation1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AdviceType1Code"))
		{	*type = SOAP_TYPE_ns1__AdviceType1Code;
			return soap_in_ns1__AdviceType1Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddressType2Code"))
		{	*type = SOAP_TYPE_ns1__AddressType2Code;
			return soap_in_ns1__AddressType2Code(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ns1__ISODateTime:
		return soap_out_ns1__ISODateTime(soap, tag, id, (const time_t *)ptr, "ns1:ISODateTime");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__TrueFalseIndicator:
		return soap_out_ns1__TrueFalseIndicator(soap, tag, id, (const bool *)ptr, "ns1:TrueFalseIndicator");
	case SOAP_TYPE_ns1__TaxRecordPeriod1Code:
		return soap_out_ns1__TaxRecordPeriod1Code(soap, tag, id, (const enum ns1__TaxRecordPeriod1Code *)ptr, "ns1:TaxRecordPeriod1Code");
	case SOAP_TYPE_ns1__RemittanceLocationMethod2Code:
		return soap_out_ns1__RemittanceLocationMethod2Code(soap, tag, id, (const enum ns1__RemittanceLocationMethod2Code *)ptr, "ns1:RemittanceLocationMethod2Code");
	case SOAP_TYPE_ns1__RegulatoryReportingType1Code:
		return soap_out_ns1__RegulatoryReportingType1Code(soap, tag, id, (const enum ns1__RegulatoryReportingType1Code *)ptr, "ns1:RegulatoryReportingType1Code");
	case SOAP_TYPE_ns1__Priority2Code:
		return soap_out_ns1__Priority2Code(soap, tag, id, (const enum ns1__Priority2Code *)ptr, "ns1:Priority2Code");
	case SOAP_TYPE_ns1__PreferredContactMethod1Code:
		return soap_out_ns1__PreferredContactMethod1Code(soap, tag, id, (const enum ns1__PreferredContactMethod1Code *)ptr, "ns1:PreferredContactMethod1Code");
	case SOAP_TYPE_ns1__PaymentMethod3Code:
		return soap_out_ns1__PaymentMethod3Code(soap, tag, id, (const enum ns1__PaymentMethod3Code *)ptr, "ns1:PaymentMethod3Code");
	case SOAP_TYPE_ns1__NamePrefix2Code:
		return soap_out_ns1__NamePrefix2Code(soap, tag, id, (const enum ns1__NamePrefix2Code *)ptr, "ns1:NamePrefix2Code");
	case SOAP_TYPE_ns1__MandateClassification1Code:
		return soap_out_ns1__MandateClassification1Code(soap, tag, id, (const enum ns1__MandateClassification1Code *)ptr, "ns1:MandateClassification1Code");
	case SOAP_TYPE_ns1__Frequency6Code:
		return soap_out_ns1__Frequency6Code(soap, tag, id, (const enum ns1__Frequency6Code *)ptr, "ns1:Frequency6Code");
	case SOAP_TYPE_ns1__ExchangeRateType1Code:
		return soap_out_ns1__ExchangeRateType1Code(soap, tag, id, (const enum ns1__ExchangeRateType1Code *)ptr, "ns1:ExchangeRateType1Code");
	case SOAP_TYPE_ns1__DocumentType6Code:
		return soap_out_ns1__DocumentType6Code(soap, tag, id, (const enum ns1__DocumentType6Code *)ptr, "ns1:DocumentType6Code");
	case SOAP_TYPE_ns1__DocumentType3Code:
		return soap_out_ns1__DocumentType3Code(soap, tag, id, (const enum ns1__DocumentType3Code *)ptr, "ns1:DocumentType3Code");
	case SOAP_TYPE_ns1__CreditDebitCode:
		return soap_out_ns1__CreditDebitCode(soap, tag, id, (const enum ns1__CreditDebitCode *)ptr, "ns1:CreditDebitCode");
	case SOAP_TYPE_ns1__ChequeType2Code:
		return soap_out_ns1__ChequeType2Code(soap, tag, id, (const enum ns1__ChequeType2Code *)ptr, "ns1:ChequeType2Code");
	case SOAP_TYPE_ns1__ChequeDelivery1Code:
		return soap_out_ns1__ChequeDelivery1Code(soap, tag, id, (const enum ns1__ChequeDelivery1Code *)ptr, "ns1:ChequeDelivery1Code");
	case SOAP_TYPE_ns1__ChargeBearerType1Code:
		return soap_out_ns1__ChargeBearerType1Code(soap, tag, id, (const enum ns1__ChargeBearerType1Code *)ptr, "ns1:ChargeBearerType1Code");
	case SOAP_TYPE_ns1__BatchBookingIndicator:
		return soap_out_ns1__BatchBookingIndicator(soap, tag, id, (const bool *)ptr, "ns1:BatchBookingIndicator");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__Authorisation1Code:
		return soap_out_ns1__Authorisation1Code(soap, tag, id, (const enum ns1__Authorisation1Code *)ptr, "ns1:Authorisation1Code");
	case SOAP_TYPE_ns1__AdviceType1Code:
		return soap_out_ns1__AdviceType1Code(soap, tag, id, (const enum ns1__AdviceType1Code *)ptr, "ns1:AdviceType1Code");
	case SOAP_TYPE_ns1__AddressType2Code:
		return soap_out_ns1__AddressType2Code(soap, tag, id, (const enum ns1__AddressType2Code *)ptr, "ns1:AddressType2Code");
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		return soap_out_ns1__UUIDv4Identifier(soap, tag, id, (const std::string *)ptr, "ns1:UUIDv4Identifier");
	case SOAP_TYPE_ns1__PhoneNumber:
		return soap_out_ns1__PhoneNumber(soap, tag, id, (const std::string *)ptr, "ns1:PhoneNumber");
	case SOAP_TYPE_ns1__PercentageRate:
		return soap_out_ns1__PercentageRate(soap, tag, id, (const std::string *)ptr, "ns1:PercentageRate");
	case SOAP_TYPE_ns1__Number:
		return soap_out_ns1__Number(soap, tag, id, (const std::string *)ptr, "ns1:Number");
	case SOAP_TYPE_ns1__Max70Text:
		return soap_out_ns1__Max70Text(soap, tag, id, (const std::string *)ptr, "ns1:Max70Text");
	case SOAP_TYPE_ns1__Max4Text:
		return soap_out_ns1__Max4Text(soap, tag, id, (const std::string *)ptr, "ns1:Max4Text");
	case SOAP_TYPE_ns1__Max35Text:
		return soap_out_ns1__Max35Text(soap, tag, id, (const std::string *)ptr, "ns1:Max35Text");
	case SOAP_TYPE_ns1__Max350Text:
		return soap_out_ns1__Max350Text(soap, tag, id, (const std::string *)ptr, "ns1:Max350Text");
	case SOAP_TYPE_ns1__Max34Text:
		return soap_out_ns1__Max34Text(soap, tag, id, (const std::string *)ptr, "ns1:Max34Text");
	case SOAP_TYPE_ns1__Max2048Text:
		return soap_out_ns1__Max2048Text(soap, tag, id, (const std::string *)ptr, "ns1:Max2048Text");
	case SOAP_TYPE_ns1__Max16Text:
		return soap_out_ns1__Max16Text(soap, tag, id, (const std::string *)ptr, "ns1:Max16Text");
	case SOAP_TYPE_ns1__Max15NumericText:
		return soap_out_ns1__Max15NumericText(soap, tag, id, (const std::string *)ptr, "ns1:Max15NumericText");
	case SOAP_TYPE_ns1__Max140Text:
		return soap_out_ns1__Max140Text(soap, tag, id, (const std::string *)ptr, "ns1:Max140Text");
	case SOAP_TYPE_ns1__Max128Text:
		return soap_out_ns1__Max128Text(soap, tag, id, (const std::string *)ptr, "ns1:Max128Text");
	case SOAP_TYPE_ns1__Max10Text:
		return soap_out_ns1__Max10Text(soap, tag, id, (const std::string *)ptr, "ns1:Max10Text");
	case SOAP_TYPE_ns1__Max10KBinary:
		return soap_out_ns1__Max10KBinary(soap, tag, id, (const xsd__base64Binary *)ptr, "ns1:Max10KBinary");
	case SOAP_TYPE_ns1__LEIIdentifier:
		return soap_out_ns1__LEIIdentifier(soap, tag, id, (const std::string *)ptr, "ns1:LEIIdentifier");
	case SOAP_TYPE_ns1__ISOYear:
		return soap_out_ns1__ISOYear(soap, tag, id, (const std::string *)ptr, "ns1:ISOYear");
	case SOAP_TYPE_ns1__ISODate:
		return soap_out_ns1__ISODate(soap, tag, id, (const std::string *)ptr, "ns1:ISODate");
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		return soap_out_ns1__IBAN2007Identifier(soap, tag, id, (const std::string *)ptr, "ns1:IBAN2007Identifier");
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		return soap_out_ns1__ExternalTaxAmountType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalTaxAmountType1Code");
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		return soap_out_ns1__ExternalServiceLevel1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalServiceLevel1Code");
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		return soap_out_ns1__ExternalPurpose1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalPurpose1Code");
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		return soap_out_ns1__ExternalProxyAccountType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalProxyAccountType1Code");
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		return soap_out_ns1__ExternalPersonIdentification1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalPersonIdentification1Code");
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		return soap_out_ns1__ExternalOrganisationIdentification1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalOrganisationIdentification1Code");
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		return soap_out_ns1__ExternalMandateSetupReason1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalMandateSetupReason1Code");
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		return soap_out_ns1__ExternalLocalInstrument1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalLocalInstrument1Code");
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		return soap_out_ns1__ExternalGarnishmentType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalGarnishmentType1Code");
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		return soap_out_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalFinancialInstitutionIdentification1Code");
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		return soap_out_ns1__ExternalDocumentLineType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalDocumentLineType1Code");
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		return soap_out_ns1__ExternalDiscountAmountType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalDiscountAmountType1Code");
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		return soap_out_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalDebtorAgentInstruction1Code");
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		return soap_out_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalCreditorAgentInstruction1Code");
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		return soap_out_ns1__ExternalClearingSystemIdentification1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalClearingSystemIdentification1Code");
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		return soap_out_ns1__ExternalCategoryPurpose1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalCategoryPurpose1Code");
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		return soap_out_ns1__ExternalCashAccountType1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalCashAccountType1Code");
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		return soap_out_ns1__ExternalAccountIdentification1Code(soap, tag, id, (const std::string *)ptr, "ns1:ExternalAccountIdentification1Code");
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		return soap_out_ns1__Exact4AlphaNumericText(soap, tag, id, (const std::string *)ptr, "ns1:Exact4AlphaNumericText");
	case SOAP_TYPE_ns1__Exact2NumericText:
		return soap_out_ns1__Exact2NumericText(soap, tag, id, (const std::string *)ptr, "ns1:Exact2NumericText");
	case SOAP_TYPE_ns1__DecimalNumber:
		return soap_out_ns1__DecimalNumber(soap, tag, id, (const std::string *)ptr, "ns1:DecimalNumber");
	case SOAP_TYPE_ns1__CountryCode:
		return soap_out_ns1__CountryCode(soap, tag, id, (const std::string *)ptr, "ns1:CountryCode");
	case SOAP_TYPE_ns1__BaseOneRate:
		return soap_out_ns1__BaseOneRate(soap, tag, id, (const std::string *)ptr, "ns1:BaseOneRate");
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		return soap_out_ns1__BICFIDec2014Identifier(soap, tag, id, (const std::string *)ptr, "ns1:BICFIDec2014Identifier");
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		return soap_out_ns1__AnyBICDec2014Identifier(soap, tag, id, (const std::string *)ptr, "ns1:AnyBICDec2014Identifier");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		return soap_out_ns1__ActiveOrHistoricCurrencyCode(soap, tag, id, (const std::string *)ptr, "ns1:ActiveOrHistoricCurrencyCode");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		return soap_out_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, tag, id, (const std::string *)ptr, "ns1:ActiveOrHistoricCurrencyAndAmount_SimpleType");
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		return ((ns1__TaxRecordDetails3 *)ptr)->soap_out(soap, tag, id, "ns1:TaxRecordDetails3");
	case SOAP_TYPE_ns1__TaxRecord3:
		return ((ns1__TaxRecord3 *)ptr)->soap_out(soap, tag, id, "ns1:TaxRecord3");
	case SOAP_TYPE_ns1__TaxPeriod3:
		return ((ns1__TaxPeriod3 *)ptr)->soap_out(soap, tag, id, "ns1:TaxPeriod3");
	case SOAP_TYPE_ns1__TaxParty2:
		return ((ns1__TaxParty2 *)ptr)->soap_out(soap, tag, id, "ns1:TaxParty2");
	case SOAP_TYPE_ns1__TaxParty1:
		return ((ns1__TaxParty1 *)ptr)->soap_out(soap, tag, id, "ns1:TaxParty1");
	case SOAP_TYPE_ns1__TaxInformation10:
		return ((ns1__TaxInformation10 *)ptr)->soap_out(soap, tag, id, "ns1:TaxInformation10");
	case SOAP_TYPE_ns1__TaxData1:
		return ((ns1__TaxData1 *)ptr)->soap_out(soap, tag, id, "ns1:TaxData1");
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		return ((ns1__TaxAuthorisation1 *)ptr)->soap_out(soap, tag, id, "ns1:TaxAuthorisation1");
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		return ((ns1__TaxAmountType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:TaxAmountType1Choice");
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		return ((ns1__TaxAmountAndType1 *)ptr)->soap_out(soap, tag, id, "ns1:TaxAmountAndType1");
	case SOAP_TYPE_ns1__TaxAmount3:
		return ((ns1__TaxAmount3 *)ptr)->soap_out(soap, tag, id, "ns1:TaxAmount3");
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		return ((ns1__SupplementaryDataEnvelope1 *)ptr)->soap_out(soap, tag, id, "ns1:SupplementaryDataEnvelope1");
	case SOAP_TYPE_ns1__SupplementaryData1:
		return ((ns1__SupplementaryData1 *)ptr)->soap_out(soap, tag, id, "ns1:SupplementaryData1");
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		return ((ns1__StructuredRemittanceInformation17 *)ptr)->soap_out(soap, tag, id, "ns1:StructuredRemittanceInformation17");
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		return ((ns1__StructuredRegulatoryReporting3 *)ptr)->soap_out(soap, tag, id, "ns1:StructuredRegulatoryReporting3");
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		return ((ns1__ServiceLevel8Choice *)ptr)->soap_out(soap, tag, id, "ns1:ServiceLevel8Choice");
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		return ((ns1__RemittanceLocationData1 *)ptr)->soap_out(soap, tag, id, "ns1:RemittanceLocationData1");
	case SOAP_TYPE_ns1__RemittanceLocation7:
		return ((ns1__RemittanceLocation7 *)ptr)->soap_out(soap, tag, id, "ns1:RemittanceLocation7");
	case SOAP_TYPE_ns1__RemittanceInformation21:
		return ((ns1__RemittanceInformation21 *)ptr)->soap_out(soap, tag, id, "ns1:RemittanceInformation21");
	case SOAP_TYPE_ns1__RemittanceAmount3:
		return ((ns1__RemittanceAmount3 *)ptr)->soap_out(soap, tag, id, "ns1:RemittanceAmount3");
	case SOAP_TYPE_ns1__RemittanceAmount2:
		return ((ns1__RemittanceAmount2 *)ptr)->soap_out(soap, tag, id, "ns1:RemittanceAmount2");
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		return ((ns1__RegulatoryReporting3 *)ptr)->soap_out(soap, tag, id, "ns1:RegulatoryReporting3");
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		return ((ns1__RegulatoryAuthority2 *)ptr)->soap_out(soap, tag, id, "ns1:RegulatoryAuthority2");
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		return ((ns1__ReferredDocumentType4 *)ptr)->soap_out(soap, tag, id, "ns1:ReferredDocumentType4");
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		return ((ns1__ReferredDocumentType3Choice *)ptr)->soap_out(soap, tag, id, "ns1:ReferredDocumentType3Choice");
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		return ((ns1__ReferredDocumentInformation7 *)ptr)->soap_out(soap, tag, id, "ns1:ReferredDocumentInformation7");
	case SOAP_TYPE_ns1__Purpose2Choice:
		return ((ns1__Purpose2Choice *)ptr)->soap_out(soap, tag, id, "ns1:Purpose2Choice");
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		return ((ns1__ProxyAccountType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:ProxyAccountType1Choice");
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		return ((ns1__ProxyAccountIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:ProxyAccountIdentification1");
	case SOAP_TYPE_ns1__PostalAddress24:
		return ((ns1__PostalAddress24 *)ptr)->soap_out(soap, tag, id, "ns1:PostalAddress24");
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		return ((ns1__PersonIdentificationSchemeName1Choice *)ptr)->soap_out(soap, tag, id, "ns1:PersonIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__PersonIdentification13:
		return ((ns1__PersonIdentification13 *)ptr)->soap_out(soap, tag, id, "ns1:PersonIdentification13");
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		return ((ns1__PaymentTypeInformation26 *)ptr)->soap_out(soap, tag, id, "ns1:PaymentTypeInformation26");
	case SOAP_TYPE_ns1__PaymentInstruction40:
		return ((ns1__PaymentInstruction40 *)ptr)->soap_out(soap, tag, id, "ns1:PaymentInstruction40");
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		return ((ns1__PaymentInitiationSource1 *)ptr)->soap_out(soap, tag, id, "ns1:PaymentInitiationSource1");
	case SOAP_TYPE_ns1__PaymentIdentification6:
		return ((ns1__PaymentIdentification6 *)ptr)->soap_out(soap, tag, id, "ns1:PaymentIdentification6");
	case SOAP_TYPE_ns1__PartyIdentification135:
		return ((ns1__PartyIdentification135 *)ptr)->soap_out(soap, tag, id, "ns1:PartyIdentification135");
	case SOAP_TYPE_ns1__Party38Choice:
		return ((ns1__Party38Choice *)ptr)->soap_out(soap, tag, id, "ns1:Party38Choice");
	case SOAP_TYPE_ns1__OtherContact1:
		return ((ns1__OtherContact1 *)ptr)->soap_out(soap, tag, id, "ns1:OtherContact1");
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		return ((ns1__OrganisationIdentificationSchemeName1Choice *)ptr)->soap_out(soap, tag, id, "ns1:OrganisationIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		return ((ns1__OrganisationIdentification29 *)ptr)->soap_out(soap, tag, id, "ns1:OrganisationIdentification29");
	case SOAP_TYPE_ns1__NameAndAddress16:
		return ((ns1__NameAndAddress16 *)ptr)->soap_out(soap, tag, id, "ns1:NameAndAddress16");
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		return ((ns1__MandateTypeInformation2 *)ptr)->soap_out(soap, tag, id, "ns1:MandateTypeInformation2");
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		return ((ns1__MandateSetupReason1Choice *)ptr)->soap_out(soap, tag, id, "ns1:MandateSetupReason1Choice");
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		return ((ns1__MandateClassification1Choice *)ptr)->soap_out(soap, tag, id, "ns1:MandateClassification1Choice");
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		return ((ns1__LocalInstrument2Choice *)ptr)->soap_out(soap, tag, id, "ns1:LocalInstrument2Choice");
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		return ((ns1__InstructionForDebtorAgent1 *)ptr)->soap_out(soap, tag, id, "ns1:InstructionForDebtorAgent1");
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		return ((ns1__InstructionForCreditorAgent3 *)ptr)->soap_out(soap, tag, id, "ns1:InstructionForCreditorAgent3");
	case SOAP_TYPE_ns1__GroupHeader95:
		return ((ns1__GroupHeader95 *)ptr)->soap_out(soap, tag, id, "ns1:GroupHeader95");
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		return ((ns1__GenericPersonIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:GenericPersonIdentification1");
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		return ((ns1__GenericOrganisationIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:GenericOrganisationIdentification1");
	case SOAP_TYPE_ns1__GenericIdentification30:
		return ((ns1__GenericIdentification30 *)ptr)->soap_out(soap, tag, id, "ns1:GenericIdentification30");
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		return ((ns1__GenericFinancialIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:GenericFinancialIdentification1");
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		return ((ns1__GenericAccountIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:GenericAccountIdentification1");
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		return ((ns1__GarnishmentType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:GarnishmentType1Choice");
	case SOAP_TYPE_ns1__GarnishmentType1:
		return ((ns1__GarnishmentType1 *)ptr)->soap_out(soap, tag, id, "ns1:GarnishmentType1");
	case SOAP_TYPE_ns1__Garnishment3:
		return ((ns1__Garnishment3 *)ptr)->soap_out(soap, tag, id, "ns1:Garnishment3");
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		return ((ns1__FrequencyPeriod1 *)ptr)->soap_out(soap, tag, id, "ns1:FrequencyPeriod1");
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		return ((ns1__FrequencyAndMoment1 *)ptr)->soap_out(soap, tag, id, "ns1:FrequencyAndMoment1");
	case SOAP_TYPE_ns1__Frequency36Choice:
		return ((ns1__Frequency36Choice *)ptr)->soap_out(soap, tag, id, "ns1:Frequency36Choice");
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		return ((ns1__FinancialInstitutionIdentification18 *)ptr)->soap_out(soap, tag, id, "ns1:FinancialInstitutionIdentification18");
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		return ((ns1__FinancialIdentificationSchemeName1Choice *)ptr)->soap_out(soap, tag, id, "ns1:FinancialIdentificationSchemeName1Choice");
	case SOAP_TYPE_ns1__ExchangeRate1:
		return ((ns1__ExchangeRate1 *)ptr)->soap_out(soap, tag, id, "ns1:ExchangeRate1");
	case SOAP_TYPE_ns1__EquivalentAmount2:
		return ((ns1__EquivalentAmount2 *)ptr)->soap_out(soap, tag, id, "ns1:EquivalentAmount2");
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		return ((ns1__DocumentLineType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:DocumentLineType1Choice");
	case SOAP_TYPE_ns1__DocumentLineType1:
		return ((ns1__DocumentLineType1 *)ptr)->soap_out(soap, tag, id, "ns1:DocumentLineType1");
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		return ((ns1__DocumentLineInformation1 *)ptr)->soap_out(soap, tag, id, "ns1:DocumentLineInformation1");
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		return ((ns1__DocumentLineIdentification1 *)ptr)->soap_out(soap, tag, id, "ns1:DocumentLineIdentification1");
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		return ((ns1__DocumentAdjustment1 *)ptr)->soap_out(soap, tag, id, "ns1:DocumentAdjustment1");
	case SOAP_TYPE_ns1__Document:
		return ((ns1__Document *)ptr)->soap_out(soap, tag, id, "ns1:Document");
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		return ((ns1__DiscountAmountType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:DiscountAmountType1Choice");
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		return ((ns1__DiscountAmountAndType1 *)ptr)->soap_out(soap, tag, id, "ns1:DiscountAmountAndType1");
	case SOAP_TYPE_ns1__DatePeriod2:
		return ((ns1__DatePeriod2 *)ptr)->soap_out(soap, tag, id, "ns1:DatePeriod2");
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		return ((ns1__DateAndPlaceOfBirth1 *)ptr)->soap_out(soap, tag, id, "ns1:DateAndPlaceOfBirth1");
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		return ((ns1__DateAndDateTime2Choice *)ptr)->soap_out(soap, tag, id, "ns1:DateAndDateTime2Choice");
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		return ((ns1__CustomerCreditTransferInitiationV11 *)ptr)->soap_out(soap, tag, id, "ns1:CustomerCreditTransferInitiationV11");
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		return ((ns1__CreditorReferenceType2 *)ptr)->soap_out(soap, tag, id, "ns1:CreditorReferenceType2");
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		return ((ns1__CreditorReferenceType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:CreditorReferenceType1Choice");
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		return ((ns1__CreditorReferenceInformation2 *)ptr)->soap_out(soap, tag, id, "ns1:CreditorReferenceInformation2");
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		return ((ns1__CreditTransferTransaction54 *)ptr)->soap_out(soap, tag, id, "ns1:CreditTransferTransaction54");
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		return ((ns1__CreditTransferMandateData1 *)ptr)->soap_out(soap, tag, id, "ns1:CreditTransferMandateData1");
	case SOAP_TYPE_ns1__Contact4:
		return ((ns1__Contact4 *)ptr)->soap_out(soap, tag, id, "ns1:Contact4");
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		return ((ns1__ClearingSystemMemberIdentification2 *)ptr)->soap_out(soap, tag, id, "ns1:ClearingSystemMemberIdentification2");
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		return ((ns1__ClearingSystemIdentification2Choice *)ptr)->soap_out(soap, tag, id, "ns1:ClearingSystemIdentification2Choice");
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		return ((ns1__ChequeDeliveryMethod1Choice *)ptr)->soap_out(soap, tag, id, "ns1:ChequeDeliveryMethod1Choice");
	case SOAP_TYPE_ns1__Cheque11:
		return ((ns1__Cheque11 *)ptr)->soap_out(soap, tag, id, "ns1:Cheque11");
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		return ((ns1__CategoryPurpose1Choice *)ptr)->soap_out(soap, tag, id, "ns1:CategoryPurpose1Choice");
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		return ((ns1__CashAccountType2Choice *)ptr)->soap_out(soap, tag, id, "ns1:CashAccountType2Choice");
	case SOAP_TYPE_ns1__CashAccount40:
		return ((ns1__CashAccount40 *)ptr)->soap_out(soap, tag, id, "ns1:CashAccount40");
	case SOAP_TYPE_ns1__BranchData3:
		return ((ns1__BranchData3 *)ptr)->soap_out(soap, tag, id, "ns1:BranchData3");
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		return ((ns1__BranchAndFinancialInstitutionIdentification6 *)ptr)->soap_out(soap, tag, id, "ns1:BranchAndFinancialInstitutionIdentification6");
	case SOAP_TYPE_ns1__Authorisation1Choice:
		return ((ns1__Authorisation1Choice *)ptr)->soap_out(soap, tag, id, "ns1:Authorisation1Choice");
	case SOAP_TYPE_ns1__AmountType4Choice:
		return ((ns1__AmountType4Choice *)ptr)->soap_out(soap, tag, id, "ns1:AmountType4Choice");
	case SOAP_TYPE_ns1__AdviceType1Choice:
		return ((ns1__AdviceType1Choice *)ptr)->soap_out(soap, tag, id, "ns1:AdviceType1Choice");
	case SOAP_TYPE_ns1__AdviceType1:
		return ((ns1__AdviceType1 *)ptr)->soap_out(soap, tag, id, "ns1:AdviceType1");
	case SOAP_TYPE_ns1__AddressType3Choice:
		return ((ns1__AddressType3Choice *)ptr)->soap_out(soap, tag, id, "ns1:AddressType3Choice");
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		return ((ns1__ActiveOrHistoricCurrencyAndAmount *)ptr)->soap_out(soap, tag, id, "ns1:ActiveOrHistoricCurrencyAndAmount");
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		return ((ns1__AccountSchemeName1Choice *)ptr)->soap_out(soap, tag, id, "ns1:AccountSchemeName1Choice");
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		return ((ns1__AccountIdentification4Choice *)ptr)->soap_out(soap, tag, id, "ns1:AccountIdentification4Choice");
	case SOAP_TYPE_xsd__gYear:
		return soap_out_xsd__gYear(soap, tag, id, (const std::string *)ptr, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__TaxAmount3:
		return soap_out_PointerTons1__TaxAmount3(soap, tag, id, (ns1__TaxAmount3 *const*)ptr, "ns1:TaxAmount3");
	case SOAP_TYPE_PointerTons1__TaxPeriod3:
		return soap_out_PointerTons1__TaxPeriod3(soap, tag, id, (ns1__TaxPeriod3 *const*)ptr, "ns1:TaxPeriod3");
	case SOAP_TYPE_PointerTons1__DatePeriod2:
		return soap_out_PointerTons1__DatePeriod2(soap, tag, id, (ns1__DatePeriod2 *const*)ptr, "ns1:DatePeriod2");
	case SOAP_TYPE_PointerTons1__TaxRecordPeriod1Code:
		return soap_out_PointerTons1__TaxRecordPeriod1Code(soap, tag, id, (enum ns1__TaxRecordPeriod1Code *const*)ptr, "ns1:TaxRecordPeriod1Code");
	case SOAP_TYPE_PointerTons1__ISOYear:
		return soap_out_PointerTons1__ISOYear(soap, tag, id, (std::string *const*)ptr, "ns1:ISOYear");
	case SOAP_TYPE_PointerTons1__TaxAuthorisation1:
		return soap_out_PointerTons1__TaxAuthorisation1(soap, tag, id, (ns1__TaxAuthorisation1 *const*)ptr, "ns1:TaxAuthorisation1");
	case SOAP_TYPE_PointerTons1__TaxRecord3:
		return soap_out_PointerTons1__TaxRecord3(soap, tag, id, (ns1__TaxRecord3 *const*)ptr, "ns1:TaxRecord3");
	case SOAP_TYPE_PointerTons1__Number:
		return soap_out_PointerTons1__Number(soap, tag, id, (std::string *const*)ptr, "ns1:Number");
	case SOAP_TYPE_PointerTons1__TaxParty2:
		return soap_out_PointerTons1__TaxParty2(soap, tag, id, (ns1__TaxParty2 *const*)ptr, "ns1:TaxParty2");
	case SOAP_TYPE_PointerTons1__TaxParty1:
		return soap_out_PointerTons1__TaxParty1(soap, tag, id, (ns1__TaxParty1 *const*)ptr, "ns1:TaxParty1");
	case SOAP_TYPE_PointerTons1__ExternalTaxAmountType1Code:
		return soap_out_PointerTons1__ExternalTaxAmountType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalTaxAmountType1Code");
	case SOAP_TYPE_PointerTons1__TaxAmountType1Choice:
		return soap_out_PointerTons1__TaxAmountType1Choice(soap, tag, id, (ns1__TaxAmountType1Choice *const*)ptr, "ns1:TaxAmountType1Choice");
	case SOAP_TYPE_PointerTons1__TaxRecordDetails3:
		return soap_out_PointerTons1__TaxRecordDetails3(soap, tag, id, (ns1__TaxRecordDetails3 *const*)ptr, "ns1:TaxRecordDetails3");
	case SOAP_TYPE_PointerTons1__PercentageRate:
		return soap_out_PointerTons1__PercentageRate(soap, tag, id, (std::string *const*)ptr, "ns1:PercentageRate");
	case SOAP_TYPE_PointerTons1__SupplementaryDataEnvelope1:
		return soap_out_PointerTons1__SupplementaryDataEnvelope1(soap, tag, id, (ns1__SupplementaryDataEnvelope1 *const*)ptr, "ns1:SupplementaryDataEnvelope1");
	case SOAP_TYPE_PointerTons1__Max350Text:
		return soap_out_PointerTons1__Max350Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max350Text");
	case SOAP_TYPE_PointerTons1__Garnishment3:
		return soap_out_PointerTons1__Garnishment3(soap, tag, id, (ns1__Garnishment3 *const*)ptr, "ns1:Garnishment3");
	case SOAP_TYPE_PointerTons1__TaxData1:
		return soap_out_PointerTons1__TaxData1(soap, tag, id, (ns1__TaxData1 *const*)ptr, "ns1:TaxData1");
	case SOAP_TYPE_PointerTons1__CreditorReferenceInformation2:
		return soap_out_PointerTons1__CreditorReferenceInformation2(soap, tag, id, (ns1__CreditorReferenceInformation2 *const*)ptr, "ns1:CreditorReferenceInformation2");
	case SOAP_TYPE_PointerTons1__RemittanceAmount2:
		return soap_out_PointerTons1__RemittanceAmount2(soap, tag, id, (ns1__RemittanceAmount2 *const*)ptr, "ns1:RemittanceAmount2");
	case SOAP_TYPE_PointerTons1__ReferredDocumentInformation7:
		return soap_out_PointerTons1__ReferredDocumentInformation7(soap, tag, id, (ns1__ReferredDocumentInformation7 *const*)ptr, "ns1:ReferredDocumentInformation7");
	case SOAP_TYPE_PointerTons1__Max10Text:
		return soap_out_PointerTons1__Max10Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max10Text");
	case SOAP_TYPE_PointerTons1__ExternalServiceLevel1Code:
		return soap_out_PointerTons1__ExternalServiceLevel1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalServiceLevel1Code");
	case SOAP_TYPE_PointerTons1__RemittanceLocationData1:
		return soap_out_PointerTons1__RemittanceLocationData1(soap, tag, id, (ns1__RemittanceLocationData1 *const*)ptr, "ns1:RemittanceLocationData1");
	case SOAP_TYPE_PointerTons1__StructuredRemittanceInformation17:
		return soap_out_PointerTons1__StructuredRemittanceInformation17(soap, tag, id, (ns1__StructuredRemittanceInformation17 *const*)ptr, "ns1:StructuredRemittanceInformation17");
	case SOAP_TYPE_PointerTons1__DocumentAdjustment1:
		return soap_out_PointerTons1__DocumentAdjustment1(soap, tag, id, (ns1__DocumentAdjustment1 *const*)ptr, "ns1:DocumentAdjustment1");
	case SOAP_TYPE_PointerTons1__TaxAmountAndType1:
		return soap_out_PointerTons1__TaxAmountAndType1(soap, tag, id, (ns1__TaxAmountAndType1 *const*)ptr, "ns1:TaxAmountAndType1");
	case SOAP_TYPE_PointerTons1__DiscountAmountAndType1:
		return soap_out_PointerTons1__DiscountAmountAndType1(soap, tag, id, (ns1__DiscountAmountAndType1 *const*)ptr, "ns1:DiscountAmountAndType1");
	case SOAP_TYPE_PointerTons1__StructuredRegulatoryReporting3:
		return soap_out_PointerTons1__StructuredRegulatoryReporting3(soap, tag, id, (ns1__StructuredRegulatoryReporting3 *const*)ptr, "ns1:StructuredRegulatoryReporting3");
	case SOAP_TYPE_PointerTons1__RegulatoryAuthority2:
		return soap_out_PointerTons1__RegulatoryAuthority2(soap, tag, id, (ns1__RegulatoryAuthority2 *const*)ptr, "ns1:RegulatoryAuthority2");
	case SOAP_TYPE_PointerTons1__RegulatoryReportingType1Code:
		return soap_out_PointerTons1__RegulatoryReportingType1Code(soap, tag, id, (enum ns1__RegulatoryReportingType1Code *const*)ptr, "ns1:RegulatoryReportingType1Code");
	case SOAP_TYPE_PointerTons1__ReferredDocumentType3Choice:
		return soap_out_PointerTons1__ReferredDocumentType3Choice(soap, tag, id, (ns1__ReferredDocumentType3Choice *const*)ptr, "ns1:ReferredDocumentType3Choice");
	case SOAP_TYPE_PointerTons1__DocumentLineInformation1:
		return soap_out_PointerTons1__DocumentLineInformation1(soap, tag, id, (ns1__DocumentLineInformation1 *const*)ptr, "ns1:DocumentLineInformation1");
	case SOAP_TYPE_PointerTons1__ReferredDocumentType4:
		return soap_out_PointerTons1__ReferredDocumentType4(soap, tag, id, (ns1__ReferredDocumentType4 *const*)ptr, "ns1:ReferredDocumentType4");
	case SOAP_TYPE_PointerTons1__ExternalPurpose1Code:
		return soap_out_PointerTons1__ExternalPurpose1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalPurpose1Code");
	case SOAP_TYPE_PointerTons1__ExternalProxyAccountType1Code:
		return soap_out_PointerTons1__ExternalProxyAccountType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalProxyAccountType1Code");
	case SOAP_TYPE_PointerTons1__ProxyAccountType1Choice:
		return soap_out_PointerTons1__ProxyAccountType1Choice(soap, tag, id, (ns1__ProxyAccountType1Choice *const*)ptr, "ns1:ProxyAccountType1Choice");
	case SOAP_TYPE_PointerTons1__Max16Text:
		return soap_out_PointerTons1__Max16Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max16Text");
	case SOAP_TYPE_PointerTons1__AddressType3Choice:
		return soap_out_PointerTons1__AddressType3Choice(soap, tag, id, (ns1__AddressType3Choice *const*)ptr, "ns1:AddressType3Choice");
	case SOAP_TYPE_PointerTons1__ExternalPersonIdentification1Code:
		return soap_out_PointerTons1__ExternalPersonIdentification1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalPersonIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericPersonIdentification1:
		return soap_out_PointerTons1__GenericPersonIdentification1(soap, tag, id, (ns1__GenericPersonIdentification1 *const*)ptr, "ns1:GenericPersonIdentification1");
	case SOAP_TYPE_PointerTons1__DateAndPlaceOfBirth1:
		return soap_out_PointerTons1__DateAndPlaceOfBirth1(soap, tag, id, (ns1__DateAndPlaceOfBirth1 *const*)ptr, "ns1:DateAndPlaceOfBirth1");
	case SOAP_TYPE_PointerTons1__CreditTransferTransaction54:
		return soap_out_PointerTons1__CreditTransferTransaction54(soap, tag, id, (ns1__CreditTransferTransaction54 *const*)ptr, "ns1:CreditTransferTransaction54");
	case SOAP_TYPE_PointerTons1__DateAndDateTime2Choice:
		return soap_out_PointerTons1__DateAndDateTime2Choice(soap, tag, id, (ns1__DateAndDateTime2Choice *const*)ptr, "ns1:DateAndDateTime2Choice");
	case SOAP_TYPE_PointerTons1__Max15NumericText:
		return soap_out_PointerTons1__Max15NumericText(soap, tag, id, (std::string *const*)ptr, "ns1:Max15NumericText");
	case SOAP_TYPE_PointerTons1__BatchBookingIndicator:
		return soap_out_PointerTons1__BatchBookingIndicator(soap, tag, id, (bool *const*)ptr, "ns1:BatchBookingIndicator");
	case SOAP_TYPE_PointerTons1__AdviceType1:
		return soap_out_PointerTons1__AdviceType1(soap, tag, id, (ns1__AdviceType1 *const*)ptr, "ns1:AdviceType1");
	case SOAP_TYPE_PointerTons1__UUIDv4Identifier:
		return soap_out_PointerTons1__UUIDv4Identifier(soap, tag, id, (std::string *const*)ptr, "ns1:UUIDv4Identifier");
	case SOAP_TYPE_PointerTons1__Contact4:
		return soap_out_PointerTons1__Contact4(soap, tag, id, (ns1__Contact4 *const*)ptr, "ns1:Contact4");
	case SOAP_TYPE_PointerTons1__CountryCode:
		return soap_out_PointerTons1__CountryCode(soap, tag, id, (std::string *const*)ptr, "ns1:CountryCode");
	case SOAP_TYPE_PointerTons1__Party38Choice:
		return soap_out_PointerTons1__Party38Choice(soap, tag, id, (ns1__Party38Choice *const*)ptr, "ns1:Party38Choice");
	case SOAP_TYPE_PointerTons1__PersonIdentification13:
		return soap_out_PointerTons1__PersonIdentification13(soap, tag, id, (ns1__PersonIdentification13 *const*)ptr, "ns1:PersonIdentification13");
	case SOAP_TYPE_PointerTons1__OrganisationIdentification29:
		return soap_out_PointerTons1__OrganisationIdentification29(soap, tag, id, (ns1__OrganisationIdentification29 *const*)ptr, "ns1:OrganisationIdentification29");
	case SOAP_TYPE_PointerTons1__ExternalOrganisationIdentification1Code:
		return soap_out_PointerTons1__ExternalOrganisationIdentification1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalOrganisationIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericOrganisationIdentification1:
		return soap_out_PointerTons1__GenericOrganisationIdentification1(soap, tag, id, (ns1__GenericOrganisationIdentification1 *const*)ptr, "ns1:GenericOrganisationIdentification1");
	case SOAP_TYPE_PointerTons1__AnyBICDec2014Identifier:
		return soap_out_PointerTons1__AnyBICDec2014Identifier(soap, tag, id, (std::string *const*)ptr, "ns1:AnyBICDec2014Identifier");
	case SOAP_TYPE_PointerTons1__MandateClassification1Choice:
		return soap_out_PointerTons1__MandateClassification1Choice(soap, tag, id, (ns1__MandateClassification1Choice *const*)ptr, "ns1:MandateClassification1Choice");
	case SOAP_TYPE_PointerTons1__CategoryPurpose1Choice:
		return soap_out_PointerTons1__CategoryPurpose1Choice(soap, tag, id, (ns1__CategoryPurpose1Choice *const*)ptr, "ns1:CategoryPurpose1Choice");
	case SOAP_TYPE_PointerTons1__LocalInstrument2Choice:
		return soap_out_PointerTons1__LocalInstrument2Choice(soap, tag, id, (ns1__LocalInstrument2Choice *const*)ptr, "ns1:LocalInstrument2Choice");
	case SOAP_TYPE_PointerTons1__ServiceLevel8Choice:
		return soap_out_PointerTons1__ServiceLevel8Choice(soap, tag, id, (ns1__ServiceLevel8Choice *const*)ptr, "ns1:ServiceLevel8Choice");
	case SOAP_TYPE_PointerTons1__ExternalMandateSetupReason1Code:
		return soap_out_PointerTons1__ExternalMandateSetupReason1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalMandateSetupReason1Code");
	case SOAP_TYPE_PointerTons1__ExternalLocalInstrument1Code:
		return soap_out_PointerTons1__ExternalLocalInstrument1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalLocalInstrument1Code");
	case SOAP_TYPE_PointerTons1__ExternalDebtorAgentInstruction1Code:
		return soap_out_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalDebtorAgentInstruction1Code");
	case SOAP_TYPE_PointerTons1__ExternalCreditorAgentInstruction1Code:
		return soap_out_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalCreditorAgentInstruction1Code");
	case SOAP_TYPE_PointerTons1__PaymentInitiationSource1:
		return soap_out_PointerTons1__PaymentInitiationSource1(soap, tag, id, (ns1__PaymentInitiationSource1 *const*)ptr, "ns1:PaymentInitiationSource1");
	case SOAP_TYPE_PointerTons1__DecimalNumber:
		return soap_out_PointerTons1__DecimalNumber(soap, tag, id, (std::string *const*)ptr, "ns1:DecimalNumber");
	case SOAP_TYPE_PointerTons1__Authorisation1Choice:
		return soap_out_PointerTons1__Authorisation1Choice(soap, tag, id, (ns1__Authorisation1Choice *const*)ptr, "ns1:Authorisation1Choice");
	case SOAP_TYPE_PointerTons1__PersonIdentificationSchemeName1Choice:
		return soap_out_PointerTons1__PersonIdentificationSchemeName1Choice(soap, tag, id, (ns1__PersonIdentificationSchemeName1Choice *const*)ptr, "ns1:PersonIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__OrganisationIdentificationSchemeName1Choice:
		return soap_out_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, tag, id, (ns1__OrganisationIdentificationSchemeName1Choice *const*)ptr, "ns1:OrganisationIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__FinancialIdentificationSchemeName1Choice:
		return soap_out_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, tag, id, (ns1__FinancialIdentificationSchemeName1Choice *const*)ptr, "ns1:FinancialIdentificationSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__AccountSchemeName1Choice:
		return soap_out_PointerTons1__AccountSchemeName1Choice(soap, tag, id, (ns1__AccountSchemeName1Choice *const*)ptr, "ns1:AccountSchemeName1Choice");
	case SOAP_TYPE_PointerTons1__ExternalGarnishmentType1Code:
		return soap_out_PointerTons1__ExternalGarnishmentType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalGarnishmentType1Code");
	case SOAP_TYPE_PointerTons1__GarnishmentType1Choice:
		return soap_out_PointerTons1__GarnishmentType1Choice(soap, tag, id, (ns1__GarnishmentType1Choice *const*)ptr, "ns1:GarnishmentType1Choice");
	case SOAP_TYPE_PointerTons1__TrueFalseIndicator:
		return soap_out_PointerTons1__TrueFalseIndicator(soap, tag, id, (bool *const*)ptr, "ns1:TrueFalseIndicator");
	case SOAP_TYPE_PointerTons1__GarnishmentType1:
		return soap_out_PointerTons1__GarnishmentType1(soap, tag, id, (ns1__GarnishmentType1 *const*)ptr, "ns1:GarnishmentType1");
	case SOAP_TYPE_PointerTons1__FrequencyAndMoment1:
		return soap_out_PointerTons1__FrequencyAndMoment1(soap, tag, id, (ns1__FrequencyAndMoment1 *const*)ptr, "ns1:FrequencyAndMoment1");
	case SOAP_TYPE_PointerTons1__FrequencyPeriod1:
		return soap_out_PointerTons1__FrequencyPeriod1(soap, tag, id, (ns1__FrequencyPeriod1 *const*)ptr, "ns1:FrequencyPeriod1");
	case SOAP_TYPE_PointerTons1__GenericFinancialIdentification1:
		return soap_out_PointerTons1__GenericFinancialIdentification1(soap, tag, id, (ns1__GenericFinancialIdentification1 *const*)ptr, "ns1:GenericFinancialIdentification1");
	case SOAP_TYPE_PointerTons1__ClearingSystemMemberIdentification2:
		return soap_out_PointerTons1__ClearingSystemMemberIdentification2(soap, tag, id, (ns1__ClearingSystemMemberIdentification2 *const*)ptr, "ns1:ClearingSystemMemberIdentification2");
	case SOAP_TYPE_PointerTons1__BICFIDec2014Identifier:
		return soap_out_PointerTons1__BICFIDec2014Identifier(soap, tag, id, (std::string *const*)ptr, "ns1:BICFIDec2014Identifier");
	case SOAP_TYPE_PointerTons1__ExternalFinancialInstitutionIdentification1Code:
		return soap_out_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalFinancialInstitutionIdentification1Code");
	case SOAP_TYPE_PointerTons1__ExchangeRateType1Code:
		return soap_out_PointerTons1__ExchangeRateType1Code(soap, tag, id, (enum ns1__ExchangeRateType1Code *const*)ptr, "ns1:ExchangeRateType1Code");
	case SOAP_TYPE_PointerTons1__BaseOneRate:
		return soap_out_PointerTons1__BaseOneRate(soap, tag, id, (std::string *const*)ptr, "ns1:BaseOneRate");
	case SOAP_TYPE_PointerTons1__ExternalDocumentLineType1Code:
		return soap_out_PointerTons1__ExternalDocumentLineType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalDocumentLineType1Code");
	case SOAP_TYPE_PointerTons1__DocumentLineType1Choice:
		return soap_out_PointerTons1__DocumentLineType1Choice(soap, tag, id, (ns1__DocumentLineType1Choice *const*)ptr, "ns1:DocumentLineType1Choice");
	case SOAP_TYPE_PointerTons1__RemittanceAmount3:
		return soap_out_PointerTons1__RemittanceAmount3(soap, tag, id, (ns1__RemittanceAmount3 *const*)ptr, "ns1:RemittanceAmount3");
	case SOAP_TYPE_PointerTons1__DocumentLineIdentification1:
		return soap_out_PointerTons1__DocumentLineIdentification1(soap, tag, id, (ns1__DocumentLineIdentification1 *const*)ptr, "ns1:DocumentLineIdentification1");
	case SOAP_TYPE_PointerTons1__DocumentLineType1:
		return soap_out_PointerTons1__DocumentLineType1(soap, tag, id, (ns1__DocumentLineType1 *const*)ptr, "ns1:DocumentLineType1");
	case SOAP_TYPE_PointerTons1__Max4Text:
		return soap_out_PointerTons1__Max4Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max4Text");
	case SOAP_TYPE_PointerTons1__CreditDebitCode:
		return soap_out_PointerTons1__CreditDebitCode(soap, tag, id, (enum ns1__CreditDebitCode *const*)ptr, "ns1:CreditDebitCode");
	case SOAP_TYPE_PointerTons1__CustomerCreditTransferInitiationV11:
		return soap_out_PointerTons1__CustomerCreditTransferInitiationV11(soap, tag, id, (ns1__CustomerCreditTransferInitiationV11 *const*)ptr, "ns1:CustomerCreditTransferInitiationV11");
	case SOAP_TYPE_PointerTons1__ExternalDiscountAmountType1Code:
		return soap_out_PointerTons1__ExternalDiscountAmountType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalDiscountAmountType1Code");
	case SOAP_TYPE_PointerTons1__DiscountAmountType1Choice:
		return soap_out_PointerTons1__DiscountAmountType1Choice(soap, tag, id, (ns1__DiscountAmountType1Choice *const*)ptr, "ns1:DiscountAmountType1Choice");
	case SOAP_TYPE_PointerTons1__PaymentInstruction40:
		return soap_out_PointerTons1__PaymentInstruction40(soap, tag, id, (ns1__PaymentInstruction40 *const*)ptr, "ns1:PaymentInstruction40");
	case SOAP_TYPE_PointerTons1__GroupHeader95:
		return soap_out_PointerTons1__GroupHeader95(soap, tag, id, (ns1__GroupHeader95 *const*)ptr, "ns1:GroupHeader95");
	case SOAP_TYPE_PointerTons1__CreditorReferenceType1Choice:
		return soap_out_PointerTons1__CreditorReferenceType1Choice(soap, tag, id, (ns1__CreditorReferenceType1Choice *const*)ptr, "ns1:CreditorReferenceType1Choice");
	case SOAP_TYPE_PointerTons1__CreditorReferenceType2:
		return soap_out_PointerTons1__CreditorReferenceType2(soap, tag, id, (ns1__CreditorReferenceType2 *const*)ptr, "ns1:CreditorReferenceType2");
	case SOAP_TYPE_PointerTons1__SupplementaryData1:
		return soap_out_PointerTons1__SupplementaryData1(soap, tag, id, (ns1__SupplementaryData1 *const*)ptr, "ns1:SupplementaryData1");
	case SOAP_TYPE_PointerTons1__RemittanceInformation21:
		return soap_out_PointerTons1__RemittanceInformation21(soap, tag, id, (ns1__RemittanceInformation21 *const*)ptr, "ns1:RemittanceInformation21");
	case SOAP_TYPE_PointerTons1__RemittanceLocation7:
		return soap_out_PointerTons1__RemittanceLocation7(soap, tag, id, (ns1__RemittanceLocation7 *const*)ptr, "ns1:RemittanceLocation7");
	case SOAP_TYPE_PointerTons1__TaxInformation10:
		return soap_out_PointerTons1__TaxInformation10(soap, tag, id, (ns1__TaxInformation10 *const*)ptr, "ns1:TaxInformation10");
	case SOAP_TYPE_PointerTons1__RegulatoryReporting3:
		return soap_out_PointerTons1__RegulatoryReporting3(soap, tag, id, (ns1__RegulatoryReporting3 *const*)ptr, "ns1:RegulatoryReporting3");
	case SOAP_TYPE_PointerTons1__Purpose2Choice:
		return soap_out_PointerTons1__Purpose2Choice(soap, tag, id, (ns1__Purpose2Choice *const*)ptr, "ns1:Purpose2Choice");
	case SOAP_TYPE_PointerTons1__InstructionForDebtorAgent1:
		return soap_out_PointerTons1__InstructionForDebtorAgent1(soap, tag, id, (ns1__InstructionForDebtorAgent1 *const*)ptr, "ns1:InstructionForDebtorAgent1");
	case SOAP_TYPE_PointerTons1__InstructionForCreditorAgent3:
		return soap_out_PointerTons1__InstructionForCreditorAgent3(soap, tag, id, (ns1__InstructionForCreditorAgent3 *const*)ptr, "ns1:InstructionForCreditorAgent3");
	case SOAP_TYPE_PointerTons1__CashAccount40:
		return soap_out_PointerTons1__CashAccount40(soap, tag, id, (ns1__CashAccount40 *const*)ptr, "ns1:CashAccount40");
	case SOAP_TYPE_PointerTons1__BranchAndFinancialInstitutionIdentification6:
		return soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, tag, id, (ns1__BranchAndFinancialInstitutionIdentification6 *const*)ptr, "ns1:BranchAndFinancialInstitutionIdentification6");
	case SOAP_TYPE_PointerTons1__PartyIdentification135:
		return soap_out_PointerTons1__PartyIdentification135(soap, tag, id, (ns1__PartyIdentification135 *const*)ptr, "ns1:PartyIdentification135");
	case SOAP_TYPE_PointerTons1__Cheque11:
		return soap_out_PointerTons1__Cheque11(soap, tag, id, (ns1__Cheque11 *const*)ptr, "ns1:Cheque11");
	case SOAP_TYPE_PointerTons1__CreditTransferMandateData1:
		return soap_out_PointerTons1__CreditTransferMandateData1(soap, tag, id, (ns1__CreditTransferMandateData1 *const*)ptr, "ns1:CreditTransferMandateData1");
	case SOAP_TYPE_PointerTons1__ChargeBearerType1Code:
		return soap_out_PointerTons1__ChargeBearerType1Code(soap, tag, id, (enum ns1__ChargeBearerType1Code *const*)ptr, "ns1:ChargeBearerType1Code");
	case SOAP_TYPE_PointerTons1__ExchangeRate1:
		return soap_out_PointerTons1__ExchangeRate1(soap, tag, id, (ns1__ExchangeRate1 *const*)ptr, "ns1:ExchangeRate1");
	case SOAP_TYPE_PointerTons1__AmountType4Choice:
		return soap_out_PointerTons1__AmountType4Choice(soap, tag, id, (ns1__AmountType4Choice *const*)ptr, "ns1:AmountType4Choice");
	case SOAP_TYPE_PointerTons1__PaymentTypeInformation26:
		return soap_out_PointerTons1__PaymentTypeInformation26(soap, tag, id, (ns1__PaymentTypeInformation26 *const*)ptr, "ns1:PaymentTypeInformation26");
	case SOAP_TYPE_PointerTons1__PaymentIdentification6:
		return soap_out_PointerTons1__PaymentIdentification6(soap, tag, id, (ns1__PaymentIdentification6 *const*)ptr, "ns1:PaymentIdentification6");
	case SOAP_TYPE_PointerTons1__MandateSetupReason1Choice:
		return soap_out_PointerTons1__MandateSetupReason1Choice(soap, tag, id, (ns1__MandateSetupReason1Choice *const*)ptr, "ns1:MandateSetupReason1Choice");
	case SOAP_TYPE_PointerTons1__Frequency36Choice:
		return soap_out_PointerTons1__Frequency36Choice(soap, tag, id, (ns1__Frequency36Choice *const*)ptr, "ns1:Frequency36Choice");
	case SOAP_TYPE_PointerTons1__Max10KBinary:
		return soap_out_PointerTons1__Max10KBinary(soap, tag, id, (xsd__base64Binary *const*)ptr, "ns1:Max10KBinary");
	case SOAP_TYPE_PointerTons1__ISODateTime:
		return soap_out_PointerTons1__ISODateTime(soap, tag, id, (time_t *const*)ptr, "ns1:ISODateTime");
	case SOAP_TYPE_PointerTons1__MandateTypeInformation2:
		return soap_out_PointerTons1__MandateTypeInformation2(soap, tag, id, (ns1__MandateTypeInformation2 *const*)ptr, "ns1:MandateTypeInformation2");
	case SOAP_TYPE_PointerTons1__PreferredContactMethod1Code:
		return soap_out_PointerTons1__PreferredContactMethod1Code(soap, tag, id, (enum ns1__PreferredContactMethod1Code *const*)ptr, "ns1:PreferredContactMethod1Code");
	case SOAP_TYPE_PointerTons1__OtherContact1:
		return soap_out_PointerTons1__OtherContact1(soap, tag, id, (ns1__OtherContact1 *const*)ptr, "ns1:OtherContact1");
	case SOAP_TYPE_PointerTons1__Max2048Text:
		return soap_out_PointerTons1__Max2048Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max2048Text");
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		return soap_out_PointerTons1__PhoneNumber(soap, tag, id, (std::string *const*)ptr, "ns1:PhoneNumber");
	case SOAP_TYPE_PointerTons1__NamePrefix2Code:
		return soap_out_PointerTons1__NamePrefix2Code(soap, tag, id, (enum ns1__NamePrefix2Code *const*)ptr, "ns1:NamePrefix2Code");
	case SOAP_TYPE_PointerTons1__ClearingSystemIdentification2Choice:
		return soap_out_PointerTons1__ClearingSystemIdentification2Choice(soap, tag, id, (ns1__ClearingSystemIdentification2Choice *const*)ptr, "ns1:ClearingSystemIdentification2Choice");
	case SOAP_TYPE_PointerTons1__ExternalClearingSystemIdentification1Code:
		return soap_out_PointerTons1__ExternalClearingSystemIdentification1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalClearingSystemIdentification1Code");
	case SOAP_TYPE_PointerTons1__ISODate:
		return soap_out_PointerTons1__ISODate(soap, tag, id, (std::string *const*)ptr, "ns1:ISODate");
	case SOAP_TYPE_PointerTons1__Priority2Code:
		return soap_out_PointerTons1__Priority2Code(soap, tag, id, (enum ns1__Priority2Code *const*)ptr, "ns1:Priority2Code");
	case SOAP_TYPE_PointerTons1__ChequeDeliveryMethod1Choice:
		return soap_out_PointerTons1__ChequeDeliveryMethod1Choice(soap, tag, id, (ns1__ChequeDeliveryMethod1Choice *const*)ptr, "ns1:ChequeDeliveryMethod1Choice");
	case SOAP_TYPE_PointerTons1__NameAndAddress16:
		return soap_out_PointerTons1__NameAndAddress16(soap, tag, id, (ns1__NameAndAddress16 *const*)ptr, "ns1:NameAndAddress16");
	case SOAP_TYPE_PointerTons1__ChequeType2Code:
		return soap_out_PointerTons1__ChequeType2Code(soap, tag, id, (enum ns1__ChequeType2Code *const*)ptr, "ns1:ChequeType2Code");
	case SOAP_TYPE_PointerTons1__ExternalCategoryPurpose1Code:
		return soap_out_PointerTons1__ExternalCategoryPurpose1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalCategoryPurpose1Code");
	case SOAP_TYPE_PointerTons1__ExternalCashAccountType1Code:
		return soap_out_PointerTons1__ExternalCashAccountType1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalCashAccountType1Code");
	case SOAP_TYPE_PointerTons1__ProxyAccountIdentification1:
		return soap_out_PointerTons1__ProxyAccountIdentification1(soap, tag, id, (ns1__ProxyAccountIdentification1 *const*)ptr, "ns1:ProxyAccountIdentification1");
	case SOAP_TYPE_PointerTons1__Max70Text:
		return soap_out_PointerTons1__Max70Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max70Text");
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyCode:
		return soap_out_PointerTons1__ActiveOrHistoricCurrencyCode(soap, tag, id, (std::string *const*)ptr, "ns1:ActiveOrHistoricCurrencyCode");
	case SOAP_TYPE_PointerTons1__CashAccountType2Choice:
		return soap_out_PointerTons1__CashAccountType2Choice(soap, tag, id, (ns1__CashAccountType2Choice *const*)ptr, "ns1:CashAccountType2Choice");
	case SOAP_TYPE_PointerTons1__AccountIdentification4Choice:
		return soap_out_PointerTons1__AccountIdentification4Choice(soap, tag, id, (ns1__AccountIdentification4Choice *const*)ptr, "ns1:AccountIdentification4Choice");
	case SOAP_TYPE_PointerTons1__PostalAddress24:
		return soap_out_PointerTons1__PostalAddress24(soap, tag, id, (ns1__PostalAddress24 *const*)ptr, "ns1:PostalAddress24");
	case SOAP_TYPE_PointerTons1__Max140Text:
		return soap_out_PointerTons1__Max140Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max140Text");
	case SOAP_TYPE_PointerTons1__LEIIdentifier:
		return soap_out_PointerTons1__LEIIdentifier(soap, tag, id, (std::string *const*)ptr, "ns1:LEIIdentifier");
	case SOAP_TYPE_PointerTons1__BranchData3:
		return soap_out_PointerTons1__BranchData3(soap, tag, id, (ns1__BranchData3 *const*)ptr, "ns1:BranchData3");
	case SOAP_TYPE_PointerTons1__FinancialInstitutionIdentification18:
		return soap_out_PointerTons1__FinancialInstitutionIdentification18(soap, tag, id, (ns1__FinancialInstitutionIdentification18 *const*)ptr, "ns1:FinancialInstitutionIdentification18");
	case SOAP_TYPE_PointerTons1__Max128Text:
		return soap_out_PointerTons1__Max128Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max128Text");
	case SOAP_TYPE_PointerTons1__EquivalentAmount2:
		return soap_out_PointerTons1__EquivalentAmount2(soap, tag, id, (ns1__EquivalentAmount2 *const*)ptr, "ns1:EquivalentAmount2");
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyAndAmount:
		return soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, tag, id, (ns1__ActiveOrHistoricCurrencyAndAmount *const*)ptr, "ns1:ActiveOrHistoricCurrencyAndAmount");
	case SOAP_TYPE_PointerTons1__AdviceType1Choice:
		return soap_out_PointerTons1__AdviceType1Choice(soap, tag, id, (ns1__AdviceType1Choice *const*)ptr, "ns1:AdviceType1Choice");
	case SOAP_TYPE_PointerTons1__GenericIdentification30:
		return soap_out_PointerTons1__GenericIdentification30(soap, tag, id, (ns1__GenericIdentification30 *const*)ptr, "ns1:GenericIdentification30");
	case SOAP_TYPE_PointerTons1__Max35Text:
		return soap_out_PointerTons1__Max35Text(soap, tag, id, (std::string *const*)ptr, "ns1:Max35Text");
	case SOAP_TYPE_PointerTons1__ExternalAccountIdentification1Code:
		return soap_out_PointerTons1__ExternalAccountIdentification1Code(soap, tag, id, (std::string *const*)ptr, "ns1:ExternalAccountIdentification1Code");
	case SOAP_TYPE_PointerTons1__GenericAccountIdentification1:
		return soap_out_PointerTons1__GenericAccountIdentification1(soap, tag, id, (ns1__GenericAccountIdentification1 *const*)ptr, "ns1:GenericAccountIdentification1");
	case SOAP_TYPE_PointerTons1__IBAN2007Identifier:
		return soap_out_PointerTons1__IBAN2007Identifier(soap, tag, id, (std::string *const*)ptr, "ns1:IBAN2007Identifier");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		soap_serialize_ns1__UUIDv4Identifier(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__PhoneNumber:
		soap_serialize_ns1__PhoneNumber(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__PercentageRate:
		soap_serialize_ns1__PercentageRate(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Number:
		soap_serialize_ns1__Number(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max70Text:
		soap_serialize_ns1__Max70Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max4Text:
		soap_serialize_ns1__Max4Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max35Text:
		soap_serialize_ns1__Max35Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max350Text:
		soap_serialize_ns1__Max350Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max34Text:
		soap_serialize_ns1__Max34Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max2048Text:
		soap_serialize_ns1__Max2048Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max16Text:
		soap_serialize_ns1__Max16Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max15NumericText:
		soap_serialize_ns1__Max15NumericText(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max140Text:
		soap_serialize_ns1__Max140Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max128Text:
		soap_serialize_ns1__Max128Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max10Text:
		soap_serialize_ns1__Max10Text(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Max10KBinary:
		soap_serialize_ns1__Max10KBinary(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_ns1__LEIIdentifier:
		soap_serialize_ns1__LEIIdentifier(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ISOYear:
		soap_serialize_ns1__ISOYear(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ISODate:
		soap_serialize_ns1__ISODate(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		soap_serialize_ns1__IBAN2007Identifier(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		soap_serialize_ns1__ExternalTaxAmountType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		soap_serialize_ns1__ExternalServiceLevel1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		soap_serialize_ns1__ExternalPurpose1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		soap_serialize_ns1__ExternalProxyAccountType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		soap_serialize_ns1__ExternalPersonIdentification1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		soap_serialize_ns1__ExternalOrganisationIdentification1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		soap_serialize_ns1__ExternalMandateSetupReason1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		soap_serialize_ns1__ExternalLocalInstrument1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		soap_serialize_ns1__ExternalGarnishmentType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		soap_serialize_ns1__ExternalFinancialInstitutionIdentification1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		soap_serialize_ns1__ExternalDocumentLineType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		soap_serialize_ns1__ExternalDiscountAmountType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		soap_serialize_ns1__ExternalDebtorAgentInstruction1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		soap_serialize_ns1__ExternalCreditorAgentInstruction1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		soap_serialize_ns1__ExternalClearingSystemIdentification1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		soap_serialize_ns1__ExternalCategoryPurpose1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		soap_serialize_ns1__ExternalCashAccountType1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		soap_serialize_ns1__ExternalAccountIdentification1Code(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		soap_serialize_ns1__Exact4AlphaNumericText(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Exact2NumericText:
		soap_serialize_ns1__Exact2NumericText(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__DecimalNumber:
		soap_serialize_ns1__DecimalNumber(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__CountryCode:
		soap_serialize_ns1__CountryCode(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__BaseOneRate:
		soap_serialize_ns1__BaseOneRate(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		soap_serialize_ns1__BICFIDec2014Identifier(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		soap_serialize_ns1__AnyBICDec2014Identifier(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		soap_serialize_ns1__ActiveOrHistoricCurrencyCode(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		soap_serialize_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		((ns1__TaxRecordDetails3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxRecord3:
		((ns1__TaxRecord3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxPeriod3:
		((ns1__TaxPeriod3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxParty2:
		((ns1__TaxParty2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxParty1:
		((ns1__TaxParty1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxInformation10:
		((ns1__TaxInformation10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxData1:
		((ns1__TaxData1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		((ns1__TaxAuthorisation1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		((ns1__TaxAmountType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		((ns1__TaxAmountAndType1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaxAmount3:
		((ns1__TaxAmount3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		((ns1__SupplementaryDataEnvelope1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SupplementaryData1:
		((ns1__SupplementaryData1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		((ns1__StructuredRemittanceInformation17 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		((ns1__StructuredRegulatoryReporting3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		((ns1__ServiceLevel8Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		((ns1__RemittanceLocationData1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemittanceLocation7:
		((ns1__RemittanceLocation7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemittanceInformation21:
		((ns1__RemittanceInformation21 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemittanceAmount3:
		((ns1__RemittanceAmount3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemittanceAmount2:
		((ns1__RemittanceAmount2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		((ns1__RegulatoryReporting3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		((ns1__RegulatoryAuthority2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		((ns1__ReferredDocumentType4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		((ns1__ReferredDocumentType3Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		((ns1__ReferredDocumentInformation7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Purpose2Choice:
		((ns1__Purpose2Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		((ns1__ProxyAccountType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		((ns1__ProxyAccountIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PostalAddress24:
		((ns1__PostalAddress24 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		((ns1__PersonIdentificationSchemeName1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PersonIdentification13:
		((ns1__PersonIdentification13 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		((ns1__PaymentTypeInformation26 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PaymentInstruction40:
		((ns1__PaymentInstruction40 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		((ns1__PaymentInitiationSource1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PaymentIdentification6:
		((ns1__PaymentIdentification6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PartyIdentification135:
		((ns1__PartyIdentification135 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Party38Choice:
		((ns1__Party38Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OtherContact1:
		((ns1__OtherContact1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		((ns1__OrganisationIdentificationSchemeName1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		((ns1__OrganisationIdentification29 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NameAndAddress16:
		((ns1__NameAndAddress16 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		((ns1__MandateTypeInformation2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		((ns1__MandateSetupReason1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		((ns1__MandateClassification1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		((ns1__LocalInstrument2Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		((ns1__InstructionForDebtorAgent1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		((ns1__InstructionForCreditorAgent3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GroupHeader95:
		((ns1__GroupHeader95 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		((ns1__GenericPersonIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		((ns1__GenericOrganisationIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericIdentification30:
		((ns1__GenericIdentification30 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		((ns1__GenericFinancialIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		((ns1__GenericAccountIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		((ns1__GarnishmentType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GarnishmentType1:
		((ns1__GarnishmentType1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Garnishment3:
		((ns1__Garnishment3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		((ns1__FrequencyPeriod1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		((ns1__FrequencyAndMoment1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Frequency36Choice:
		((ns1__Frequency36Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		((ns1__FinancialInstitutionIdentification18 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		((ns1__FinancialIdentificationSchemeName1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ExchangeRate1:
		((ns1__ExchangeRate1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EquivalentAmount2:
		((ns1__EquivalentAmount2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		((ns1__DocumentLineType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DocumentLineType1:
		((ns1__DocumentLineType1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		((ns1__DocumentLineInformation1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		((ns1__DocumentLineIdentification1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		((ns1__DocumentAdjustment1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Document:
		((ns1__Document *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		((ns1__DiscountAmountType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		((ns1__DiscountAmountAndType1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DatePeriod2:
		((ns1__DatePeriod2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		((ns1__DateAndPlaceOfBirth1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		((ns1__DateAndDateTime2Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		((ns1__CustomerCreditTransferInitiationV11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		((ns1__CreditorReferenceType2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		((ns1__CreditorReferenceType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		((ns1__CreditorReferenceInformation2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		((ns1__CreditTransferTransaction54 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		((ns1__CreditTransferMandateData1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Contact4:
		((ns1__Contact4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		((ns1__ClearingSystemMemberIdentification2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		((ns1__ClearingSystemIdentification2Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		((ns1__ChequeDeliveryMethod1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Cheque11:
		((ns1__Cheque11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		((ns1__CategoryPurpose1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		((ns1__CashAccountType2Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CashAccount40:
		((ns1__CashAccount40 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BranchData3:
		((ns1__BranchData3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		((ns1__BranchAndFinancialInstitutionIdentification6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Authorisation1Choice:
		((ns1__Authorisation1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AmountType4Choice:
		((ns1__AmountType4Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AdviceType1Choice:
		((ns1__AdviceType1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AdviceType1:
		((ns1__AdviceType1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AddressType3Choice:
		((ns1__AddressType3Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		((ns1__ActiveOrHistoricCurrencyAndAmount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		((ns1__AccountSchemeName1Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		((ns1__AccountIdentification4Choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__gYear:
		soap_serialize_xsd__gYear(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_PointerTons1__TaxAmount3:
		soap_serialize_PointerTons1__TaxAmount3(soap, (ns1__TaxAmount3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxPeriod3:
		soap_serialize_PointerTons1__TaxPeriod3(soap, (ns1__TaxPeriod3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DatePeriod2:
		soap_serialize_PointerTons1__DatePeriod2(soap, (ns1__DatePeriod2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxRecordPeriod1Code:
		soap_serialize_PointerTons1__TaxRecordPeriod1Code(soap, (enum ns1__TaxRecordPeriod1Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ISOYear:
		soap_serialize_PointerTons1__ISOYear(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxAuthorisation1:
		soap_serialize_PointerTons1__TaxAuthorisation1(soap, (ns1__TaxAuthorisation1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxRecord3:
		soap_serialize_PointerTons1__TaxRecord3(soap, (ns1__TaxRecord3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Number:
		soap_serialize_PointerTons1__Number(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxParty2:
		soap_serialize_PointerTons1__TaxParty2(soap, (ns1__TaxParty2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxParty1:
		soap_serialize_PointerTons1__TaxParty1(soap, (ns1__TaxParty1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalTaxAmountType1Code:
		soap_serialize_PointerTons1__ExternalTaxAmountType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxAmountType1Choice:
		soap_serialize_PointerTons1__TaxAmountType1Choice(soap, (ns1__TaxAmountType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxRecordDetails3:
		soap_serialize_PointerTons1__TaxRecordDetails3(soap, (ns1__TaxRecordDetails3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PercentageRate:
		soap_serialize_PointerTons1__PercentageRate(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SupplementaryDataEnvelope1:
		soap_serialize_PointerTons1__SupplementaryDataEnvelope1(soap, (ns1__SupplementaryDataEnvelope1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max350Text:
		soap_serialize_PointerTons1__Max350Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Garnishment3:
		soap_serialize_PointerTons1__Garnishment3(soap, (ns1__Garnishment3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxData1:
		soap_serialize_PointerTons1__TaxData1(soap, (ns1__TaxData1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditorReferenceInformation2:
		soap_serialize_PointerTons1__CreditorReferenceInformation2(soap, (ns1__CreditorReferenceInformation2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemittanceAmount2:
		soap_serialize_PointerTons1__RemittanceAmount2(soap, (ns1__RemittanceAmount2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReferredDocumentInformation7:
		soap_serialize_PointerTons1__ReferredDocumentInformation7(soap, (ns1__ReferredDocumentInformation7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max10Text:
		soap_serialize_PointerTons1__Max10Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalServiceLevel1Code:
		soap_serialize_PointerTons1__ExternalServiceLevel1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemittanceLocationData1:
		soap_serialize_PointerTons1__RemittanceLocationData1(soap, (ns1__RemittanceLocationData1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StructuredRemittanceInformation17:
		soap_serialize_PointerTons1__StructuredRemittanceInformation17(soap, (ns1__StructuredRemittanceInformation17 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentAdjustment1:
		soap_serialize_PointerTons1__DocumentAdjustment1(soap, (ns1__DocumentAdjustment1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxAmountAndType1:
		soap_serialize_PointerTons1__TaxAmountAndType1(soap, (ns1__TaxAmountAndType1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DiscountAmountAndType1:
		soap_serialize_PointerTons1__DiscountAmountAndType1(soap, (ns1__DiscountAmountAndType1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StructuredRegulatoryReporting3:
		soap_serialize_PointerTons1__StructuredRegulatoryReporting3(soap, (ns1__StructuredRegulatoryReporting3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegulatoryAuthority2:
		soap_serialize_PointerTons1__RegulatoryAuthority2(soap, (ns1__RegulatoryAuthority2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegulatoryReportingType1Code:
		soap_serialize_PointerTons1__RegulatoryReportingType1Code(soap, (enum ns1__RegulatoryReportingType1Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReferredDocumentType3Choice:
		soap_serialize_PointerTons1__ReferredDocumentType3Choice(soap, (ns1__ReferredDocumentType3Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentLineInformation1:
		soap_serialize_PointerTons1__DocumentLineInformation1(soap, (ns1__DocumentLineInformation1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReferredDocumentType4:
		soap_serialize_PointerTons1__ReferredDocumentType4(soap, (ns1__ReferredDocumentType4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalPurpose1Code:
		soap_serialize_PointerTons1__ExternalPurpose1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalProxyAccountType1Code:
		soap_serialize_PointerTons1__ExternalProxyAccountType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProxyAccountType1Choice:
		soap_serialize_PointerTons1__ProxyAccountType1Choice(soap, (ns1__ProxyAccountType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max16Text:
		soap_serialize_PointerTons1__Max16Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddressType3Choice:
		soap_serialize_PointerTons1__AddressType3Choice(soap, (ns1__AddressType3Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalPersonIdentification1Code:
		soap_serialize_PointerTons1__ExternalPersonIdentification1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericPersonIdentification1:
		soap_serialize_PointerTons1__GenericPersonIdentification1(soap, (ns1__GenericPersonIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateAndPlaceOfBirth1:
		soap_serialize_PointerTons1__DateAndPlaceOfBirth1(soap, (ns1__DateAndPlaceOfBirth1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditTransferTransaction54:
		soap_serialize_PointerTons1__CreditTransferTransaction54(soap, (ns1__CreditTransferTransaction54 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateAndDateTime2Choice:
		soap_serialize_PointerTons1__DateAndDateTime2Choice(soap, (ns1__DateAndDateTime2Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max15NumericText:
		soap_serialize_PointerTons1__Max15NumericText(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BatchBookingIndicator:
		soap_serialize_PointerTons1__BatchBookingIndicator(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AdviceType1:
		soap_serialize_PointerTons1__AdviceType1(soap, (ns1__AdviceType1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UUIDv4Identifier:
		soap_serialize_PointerTons1__UUIDv4Identifier(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Contact4:
		soap_serialize_PointerTons1__Contact4(soap, (ns1__Contact4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryCode:
		soap_serialize_PointerTons1__CountryCode(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Party38Choice:
		soap_serialize_PointerTons1__Party38Choice(soap, (ns1__Party38Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PersonIdentification13:
		soap_serialize_PointerTons1__PersonIdentification13(soap, (ns1__PersonIdentification13 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrganisationIdentification29:
		soap_serialize_PointerTons1__OrganisationIdentification29(soap, (ns1__OrganisationIdentification29 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalOrganisationIdentification1Code:
		soap_serialize_PointerTons1__ExternalOrganisationIdentification1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericOrganisationIdentification1:
		soap_serialize_PointerTons1__GenericOrganisationIdentification1(soap, (ns1__GenericOrganisationIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AnyBICDec2014Identifier:
		soap_serialize_PointerTons1__AnyBICDec2014Identifier(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MandateClassification1Choice:
		soap_serialize_PointerTons1__MandateClassification1Choice(soap, (ns1__MandateClassification1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CategoryPurpose1Choice:
		soap_serialize_PointerTons1__CategoryPurpose1Choice(soap, (ns1__CategoryPurpose1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LocalInstrument2Choice:
		soap_serialize_PointerTons1__LocalInstrument2Choice(soap, (ns1__LocalInstrument2Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ServiceLevel8Choice:
		soap_serialize_PointerTons1__ServiceLevel8Choice(soap, (ns1__ServiceLevel8Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalMandateSetupReason1Code:
		soap_serialize_PointerTons1__ExternalMandateSetupReason1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalLocalInstrument1Code:
		soap_serialize_PointerTons1__ExternalLocalInstrument1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalDebtorAgentInstruction1Code:
		soap_serialize_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalCreditorAgentInstruction1Code:
		soap_serialize_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PaymentInitiationSource1:
		soap_serialize_PointerTons1__PaymentInitiationSource1(soap, (ns1__PaymentInitiationSource1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DecimalNumber:
		soap_serialize_PointerTons1__DecimalNumber(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Authorisation1Choice:
		soap_serialize_PointerTons1__Authorisation1Choice(soap, (ns1__Authorisation1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PersonIdentificationSchemeName1Choice:
		soap_serialize_PointerTons1__PersonIdentificationSchemeName1Choice(soap, (ns1__PersonIdentificationSchemeName1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrganisationIdentificationSchemeName1Choice:
		soap_serialize_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, (ns1__OrganisationIdentificationSchemeName1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FinancialIdentificationSchemeName1Choice:
		soap_serialize_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, (ns1__FinancialIdentificationSchemeName1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccountSchemeName1Choice:
		soap_serialize_PointerTons1__AccountSchemeName1Choice(soap, (ns1__AccountSchemeName1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalGarnishmentType1Code:
		soap_serialize_PointerTons1__ExternalGarnishmentType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GarnishmentType1Choice:
		soap_serialize_PointerTons1__GarnishmentType1Choice(soap, (ns1__GarnishmentType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrueFalseIndicator:
		soap_serialize_PointerTons1__TrueFalseIndicator(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GarnishmentType1:
		soap_serialize_PointerTons1__GarnishmentType1(soap, (ns1__GarnishmentType1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FrequencyAndMoment1:
		soap_serialize_PointerTons1__FrequencyAndMoment1(soap, (ns1__FrequencyAndMoment1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FrequencyPeriod1:
		soap_serialize_PointerTons1__FrequencyPeriod1(soap, (ns1__FrequencyPeriod1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericFinancialIdentification1:
		soap_serialize_PointerTons1__GenericFinancialIdentification1(soap, (ns1__GenericFinancialIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ClearingSystemMemberIdentification2:
		soap_serialize_PointerTons1__ClearingSystemMemberIdentification2(soap, (ns1__ClearingSystemMemberIdentification2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BICFIDec2014Identifier:
		soap_serialize_PointerTons1__BICFIDec2014Identifier(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalFinancialInstitutionIdentification1Code:
		soap_serialize_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExchangeRateType1Code:
		soap_serialize_PointerTons1__ExchangeRateType1Code(soap, (enum ns1__ExchangeRateType1Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BaseOneRate:
		soap_serialize_PointerTons1__BaseOneRate(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalDocumentLineType1Code:
		soap_serialize_PointerTons1__ExternalDocumentLineType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentLineType1Choice:
		soap_serialize_PointerTons1__DocumentLineType1Choice(soap, (ns1__DocumentLineType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemittanceAmount3:
		soap_serialize_PointerTons1__RemittanceAmount3(soap, (ns1__RemittanceAmount3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentLineIdentification1:
		soap_serialize_PointerTons1__DocumentLineIdentification1(soap, (ns1__DocumentLineIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentLineType1:
		soap_serialize_PointerTons1__DocumentLineType1(soap, (ns1__DocumentLineType1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max4Text:
		soap_serialize_PointerTons1__Max4Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditDebitCode:
		soap_serialize_PointerTons1__CreditDebitCode(soap, (enum ns1__CreditDebitCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomerCreditTransferInitiationV11:
		soap_serialize_PointerTons1__CustomerCreditTransferInitiationV11(soap, (ns1__CustomerCreditTransferInitiationV11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalDiscountAmountType1Code:
		soap_serialize_PointerTons1__ExternalDiscountAmountType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DiscountAmountType1Choice:
		soap_serialize_PointerTons1__DiscountAmountType1Choice(soap, (ns1__DiscountAmountType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PaymentInstruction40:
		soap_serialize_PointerTons1__PaymentInstruction40(soap, (ns1__PaymentInstruction40 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GroupHeader95:
		soap_serialize_PointerTons1__GroupHeader95(soap, (ns1__GroupHeader95 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditorReferenceType1Choice:
		soap_serialize_PointerTons1__CreditorReferenceType1Choice(soap, (ns1__CreditorReferenceType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditorReferenceType2:
		soap_serialize_PointerTons1__CreditorReferenceType2(soap, (ns1__CreditorReferenceType2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SupplementaryData1:
		soap_serialize_PointerTons1__SupplementaryData1(soap, (ns1__SupplementaryData1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemittanceInformation21:
		soap_serialize_PointerTons1__RemittanceInformation21(soap, (ns1__RemittanceInformation21 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemittanceLocation7:
		soap_serialize_PointerTons1__RemittanceLocation7(soap, (ns1__RemittanceLocation7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaxInformation10:
		soap_serialize_PointerTons1__TaxInformation10(soap, (ns1__TaxInformation10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegulatoryReporting3:
		soap_serialize_PointerTons1__RegulatoryReporting3(soap, (ns1__RegulatoryReporting3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Purpose2Choice:
		soap_serialize_PointerTons1__Purpose2Choice(soap, (ns1__Purpose2Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InstructionForDebtorAgent1:
		soap_serialize_PointerTons1__InstructionForDebtorAgent1(soap, (ns1__InstructionForDebtorAgent1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InstructionForCreditorAgent3:
		soap_serialize_PointerTons1__InstructionForCreditorAgent3(soap, (ns1__InstructionForCreditorAgent3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CashAccount40:
		soap_serialize_PointerTons1__CashAccount40(soap, (ns1__CashAccount40 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BranchAndFinancialInstitutionIdentification6:
		soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, (ns1__BranchAndFinancialInstitutionIdentification6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PartyIdentification135:
		soap_serialize_PointerTons1__PartyIdentification135(soap, (ns1__PartyIdentification135 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Cheque11:
		soap_serialize_PointerTons1__Cheque11(soap, (ns1__Cheque11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreditTransferMandateData1:
		soap_serialize_PointerTons1__CreditTransferMandateData1(soap, (ns1__CreditTransferMandateData1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChargeBearerType1Code:
		soap_serialize_PointerTons1__ChargeBearerType1Code(soap, (enum ns1__ChargeBearerType1Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExchangeRate1:
		soap_serialize_PointerTons1__ExchangeRate1(soap, (ns1__ExchangeRate1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AmountType4Choice:
		soap_serialize_PointerTons1__AmountType4Choice(soap, (ns1__AmountType4Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PaymentTypeInformation26:
		soap_serialize_PointerTons1__PaymentTypeInformation26(soap, (ns1__PaymentTypeInformation26 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PaymentIdentification6:
		soap_serialize_PointerTons1__PaymentIdentification6(soap, (ns1__PaymentIdentification6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MandateSetupReason1Choice:
		soap_serialize_PointerTons1__MandateSetupReason1Choice(soap, (ns1__MandateSetupReason1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Frequency36Choice:
		soap_serialize_PointerTons1__Frequency36Choice(soap, (ns1__Frequency36Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max10KBinary:
		soap_serialize_PointerTons1__Max10KBinary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ISODateTime:
		soap_serialize_PointerTons1__ISODateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MandateTypeInformation2:
		soap_serialize_PointerTons1__MandateTypeInformation2(soap, (ns1__MandateTypeInformation2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PreferredContactMethod1Code:
		soap_serialize_PointerTons1__PreferredContactMethod1Code(soap, (enum ns1__PreferredContactMethod1Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtherContact1:
		soap_serialize_PointerTons1__OtherContact1(soap, (ns1__OtherContact1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max2048Text:
		soap_serialize_PointerTons1__Max2048Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		soap_serialize_PointerTons1__PhoneNumber(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NamePrefix2Code:
		soap_serialize_PointerTons1__NamePrefix2Code(soap, (enum ns1__NamePrefix2Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ClearingSystemIdentification2Choice:
		soap_serialize_PointerTons1__ClearingSystemIdentification2Choice(soap, (ns1__ClearingSystemIdentification2Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalClearingSystemIdentification1Code:
		soap_serialize_PointerTons1__ExternalClearingSystemIdentification1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ISODate:
		soap_serialize_PointerTons1__ISODate(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Priority2Code:
		soap_serialize_PointerTons1__Priority2Code(soap, (enum ns1__Priority2Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChequeDeliveryMethod1Choice:
		soap_serialize_PointerTons1__ChequeDeliveryMethod1Choice(soap, (ns1__ChequeDeliveryMethod1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NameAndAddress16:
		soap_serialize_PointerTons1__NameAndAddress16(soap, (ns1__NameAndAddress16 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChequeType2Code:
		soap_serialize_PointerTons1__ChequeType2Code(soap, (enum ns1__ChequeType2Code *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalCategoryPurpose1Code:
		soap_serialize_PointerTons1__ExternalCategoryPurpose1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalCashAccountType1Code:
		soap_serialize_PointerTons1__ExternalCashAccountType1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProxyAccountIdentification1:
		soap_serialize_PointerTons1__ProxyAccountIdentification1(soap, (ns1__ProxyAccountIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max70Text:
		soap_serialize_PointerTons1__Max70Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyCode:
		soap_serialize_PointerTons1__ActiveOrHistoricCurrencyCode(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CashAccountType2Choice:
		soap_serialize_PointerTons1__CashAccountType2Choice(soap, (ns1__CashAccountType2Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccountIdentification4Choice:
		soap_serialize_PointerTons1__AccountIdentification4Choice(soap, (ns1__AccountIdentification4Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PostalAddress24:
		soap_serialize_PointerTons1__PostalAddress24(soap, (ns1__PostalAddress24 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max140Text:
		soap_serialize_PointerTons1__Max140Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LEIIdentifier:
		soap_serialize_PointerTons1__LEIIdentifier(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BranchData3:
		soap_serialize_PointerTons1__BranchData3(soap, (ns1__BranchData3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FinancialInstitutionIdentification18:
		soap_serialize_PointerTons1__FinancialInstitutionIdentification18(soap, (ns1__FinancialInstitutionIdentification18 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max128Text:
		soap_serialize_PointerTons1__Max128Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EquivalentAmount2:
		soap_serialize_PointerTons1__EquivalentAmount2(soap, (ns1__EquivalentAmount2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyAndAmount:
		soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, (ns1__ActiveOrHistoricCurrencyAndAmount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AdviceType1Choice:
		soap_serialize_PointerTons1__AdviceType1Choice(soap, (ns1__AdviceType1Choice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericIdentification30:
		soap_serialize_PointerTons1__GenericIdentification30(soap, (ns1__GenericIdentification30 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Max35Text:
		soap_serialize_PointerTons1__Max35Text(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExternalAccountIdentification1Code:
		soap_serialize_PointerTons1__ExternalAccountIdentification1Code(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericAccountIdentification1:
		soap_serialize_PointerTons1__GenericAccountIdentification1(soap, (ns1__GenericAccountIdentification1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IBAN2007Identifier:
		soap_serialize_PointerTons1__IBAN2007Identifier(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		return (void*)soap_instantiate_ns1__AccountIdentification4Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		return (void*)soap_instantiate_ns1__AccountSchemeName1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddressType3Choice:
		return (void*)soap_instantiate_ns1__AddressType3Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AdviceType1:
		return (void*)soap_instantiate_ns1__AdviceType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AdviceType1Choice:
		return (void*)soap_instantiate_ns1__AdviceType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AmountType4Choice:
		return (void*)soap_instantiate_ns1__AmountType4Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Authorisation1Choice:
		return (void*)soap_instantiate_ns1__Authorisation1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		return (void*)soap_instantiate_ns1__BranchAndFinancialInstitutionIdentification6(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BranchData3:
		return (void*)soap_instantiate_ns1__BranchData3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CashAccount40:
		return (void*)soap_instantiate_ns1__CashAccount40(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		return (void*)soap_instantiate_ns1__CashAccountType2Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		return (void*)soap_instantiate_ns1__CategoryPurpose1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Cheque11:
		return (void*)soap_instantiate_ns1__Cheque11(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		return (void*)soap_instantiate_ns1__ChequeDeliveryMethod1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		return (void*)soap_instantiate_ns1__ClearingSystemIdentification2Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		return (void*)soap_instantiate_ns1__ClearingSystemMemberIdentification2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Contact4:
		return (void*)soap_instantiate_ns1__Contact4(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		return (void*)soap_instantiate_ns1__CreditTransferMandateData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		return (void*)soap_instantiate_ns1__CreditTransferTransaction54(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		return (void*)soap_instantiate_ns1__CreditorReferenceInformation2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		return (void*)soap_instantiate_ns1__CreditorReferenceType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		return (void*)soap_instantiate_ns1__CreditorReferenceType2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		return (void*)soap_instantiate_ns1__CustomerCreditTransferInitiationV11(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		return (void*)soap_instantiate_ns1__DateAndDateTime2Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		return (void*)soap_instantiate_ns1__DateAndPlaceOfBirth1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DatePeriod2:
		return (void*)soap_instantiate_ns1__DatePeriod2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		return (void*)soap_instantiate_ns1__DiscountAmountAndType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		return (void*)soap_instantiate_ns1__DiscountAmountType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Document:
		return (void*)soap_instantiate_ns1__Document(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		return (void*)soap_instantiate_ns1__DocumentAdjustment1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		return (void*)soap_instantiate_ns1__DocumentLineIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		return (void*)soap_instantiate_ns1__DocumentLineInformation1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentLineType1:
		return (void*)soap_instantiate_ns1__DocumentLineType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		return (void*)soap_instantiate_ns1__DocumentLineType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EquivalentAmount2:
		return (void*)soap_instantiate_ns1__EquivalentAmount2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExchangeRate1:
		return (void*)soap_instantiate_ns1__ExchangeRate1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		return (void*)soap_instantiate_ns1__FinancialIdentificationSchemeName1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		return (void*)soap_instantiate_ns1__FinancialInstitutionIdentification18(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Frequency36Choice:
		return (void*)soap_instantiate_ns1__Frequency36Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		return (void*)soap_instantiate_ns1__FrequencyAndMoment1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		return (void*)soap_instantiate_ns1__FrequencyPeriod1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Garnishment3:
		return (void*)soap_instantiate_ns1__Garnishment3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GarnishmentType1:
		return (void*)soap_instantiate_ns1__GarnishmentType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		return (void*)soap_instantiate_ns1__GarnishmentType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		return (void*)soap_instantiate_ns1__GenericAccountIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		return (void*)soap_instantiate_ns1__GenericFinancialIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericIdentification30:
		return (void*)soap_instantiate_ns1__GenericIdentification30(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		return (void*)soap_instantiate_ns1__GenericOrganisationIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		return (void*)soap_instantiate_ns1__GenericPersonIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GroupHeader95:
		return (void*)soap_instantiate_ns1__GroupHeader95(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		return (void*)soap_instantiate_ns1__InstructionForCreditorAgent3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		return (void*)soap_instantiate_ns1__InstructionForDebtorAgent1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		return (void*)soap_instantiate_ns1__LocalInstrument2Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		return (void*)soap_instantiate_ns1__MandateClassification1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		return (void*)soap_instantiate_ns1__MandateSetupReason1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		return (void*)soap_instantiate_ns1__MandateTypeInformation2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NameAndAddress16:
		return (void*)soap_instantiate_ns1__NameAndAddress16(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		return (void*)soap_instantiate_ns1__OrganisationIdentification29(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		return (void*)soap_instantiate_ns1__OrganisationIdentificationSchemeName1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OtherContact1:
		return (void*)soap_instantiate_ns1__OtherContact1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Party38Choice:
		return (void*)soap_instantiate_ns1__Party38Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PartyIdentification135:
		return (void*)soap_instantiate_ns1__PartyIdentification135(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PaymentIdentification6:
		return (void*)soap_instantiate_ns1__PaymentIdentification6(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		return (void*)soap_instantiate_ns1__PaymentInitiationSource1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PaymentInstruction40:
		return (void*)soap_instantiate_ns1__PaymentInstruction40(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		return (void*)soap_instantiate_ns1__PaymentTypeInformation26(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PersonIdentification13:
		return (void*)soap_instantiate_ns1__PersonIdentification13(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		return (void*)soap_instantiate_ns1__PersonIdentificationSchemeName1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PostalAddress24:
		return (void*)soap_instantiate_ns1__PostalAddress24(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		return (void*)soap_instantiate_ns1__ProxyAccountIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		return (void*)soap_instantiate_ns1__ProxyAccountType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Purpose2Choice:
		return (void*)soap_instantiate_ns1__Purpose2Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		return (void*)soap_instantiate_ns1__ReferredDocumentInformation7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		return (void*)soap_instantiate_ns1__ReferredDocumentType3Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		return (void*)soap_instantiate_ns1__ReferredDocumentType4(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		return (void*)soap_instantiate_ns1__RegulatoryAuthority2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		return (void*)soap_instantiate_ns1__RegulatoryReporting3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemittanceAmount2:
		return (void*)soap_instantiate_ns1__RemittanceAmount2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemittanceAmount3:
		return (void*)soap_instantiate_ns1__RemittanceAmount3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemittanceInformation21:
		return (void*)soap_instantiate_ns1__RemittanceInformation21(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemittanceLocation7:
		return (void*)soap_instantiate_ns1__RemittanceLocation7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		return (void*)soap_instantiate_ns1__RemittanceLocationData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		return (void*)soap_instantiate_ns1__ServiceLevel8Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		return (void*)soap_instantiate_ns1__StructuredRegulatoryReporting3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		return (void*)soap_instantiate_ns1__StructuredRemittanceInformation17(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SupplementaryData1:
		return (void*)soap_instantiate_ns1__SupplementaryData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		return (void*)soap_instantiate_ns1__SupplementaryDataEnvelope1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxAmount3:
		return (void*)soap_instantiate_ns1__TaxAmount3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		return (void*)soap_instantiate_ns1__TaxAmountAndType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		return (void*)soap_instantiate_ns1__TaxAmountType1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		return (void*)soap_instantiate_ns1__TaxAuthorisation1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxData1:
		return (void*)soap_instantiate_ns1__TaxData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxInformation10:
		return (void*)soap_instantiate_ns1__TaxInformation10(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxParty1:
		return (void*)soap_instantiate_ns1__TaxParty1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxParty2:
		return (void*)soap_instantiate_ns1__TaxParty2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxPeriod3:
		return (void*)soap_instantiate_ns1__TaxPeriod3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxRecord3:
		return (void*)soap_instantiate_ns1__TaxRecord3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		return (void*)soap_instantiate_ns1__TaxRecordDetails3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		return (void*)soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__gYear:
		return (void*)soap_instantiate_xsd__gYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		return (void*)soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		return (void*)soap_instantiate_ns1__ActiveOrHistoricCurrencyCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		return (void*)soap_instantiate_ns1__AnyBICDec2014Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		return (void*)soap_instantiate_ns1__BICFIDec2014Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BaseOneRate:
		return (void*)soap_instantiate_ns1__BaseOneRate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CountryCode:
		return (void*)soap_instantiate_ns1__CountryCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DecimalNumber:
		return (void*)soap_instantiate_ns1__DecimalNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Exact2NumericText:
		return (void*)soap_instantiate_ns1__Exact2NumericText(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		return (void*)soap_instantiate_ns1__Exact4AlphaNumericText(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		return (void*)soap_instantiate_ns1__ExternalAccountIdentification1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		return (void*)soap_instantiate_ns1__ExternalCashAccountType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		return (void*)soap_instantiate_ns1__ExternalCategoryPurpose1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		return (void*)soap_instantiate_ns1__ExternalClearingSystemIdentification1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		return (void*)soap_instantiate_ns1__ExternalCreditorAgentInstruction1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		return (void*)soap_instantiate_ns1__ExternalDebtorAgentInstruction1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		return (void*)soap_instantiate_ns1__ExternalDiscountAmountType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		return (void*)soap_instantiate_ns1__ExternalDocumentLineType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		return (void*)soap_instantiate_ns1__ExternalFinancialInstitutionIdentification1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		return (void*)soap_instantiate_ns1__ExternalGarnishmentType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		return (void*)soap_instantiate_ns1__ExternalLocalInstrument1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		return (void*)soap_instantiate_ns1__ExternalMandateSetupReason1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		return (void*)soap_instantiate_ns1__ExternalOrganisationIdentification1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		return (void*)soap_instantiate_ns1__ExternalPersonIdentification1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		return (void*)soap_instantiate_ns1__ExternalProxyAccountType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		return (void*)soap_instantiate_ns1__ExternalPurpose1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		return (void*)soap_instantiate_ns1__ExternalServiceLevel1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		return (void*)soap_instantiate_ns1__ExternalTaxAmountType1Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		return (void*)soap_instantiate_ns1__IBAN2007Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ISODate:
		return (void*)soap_instantiate_ns1__ISODate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ISOYear:
		return (void*)soap_instantiate_ns1__ISOYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LEIIdentifier:
		return (void*)soap_instantiate_ns1__LEIIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max10KBinary:
		return (void*)soap_instantiate_ns1__Max10KBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max10Text:
		return (void*)soap_instantiate_ns1__Max10Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max128Text:
		return (void*)soap_instantiate_ns1__Max128Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max140Text:
		return (void*)soap_instantiate_ns1__Max140Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max15NumericText:
		return (void*)soap_instantiate_ns1__Max15NumericText(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max16Text:
		return (void*)soap_instantiate_ns1__Max16Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max2048Text:
		return (void*)soap_instantiate_ns1__Max2048Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max34Text:
		return (void*)soap_instantiate_ns1__Max34Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max350Text:
		return (void*)soap_instantiate_ns1__Max350Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max35Text:
		return (void*)soap_instantiate_ns1__Max35Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max4Text:
		return (void*)soap_instantiate_ns1__Max4Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Max70Text:
		return (void*)soap_instantiate_ns1__Max70Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Number:
		return (void*)soap_instantiate_ns1__Number(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PercentageRate:
		return (void*)soap_instantiate_ns1__PercentageRate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneNumber:
		return (void*)soap_instantiate_ns1__PhoneNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		return (void*)soap_instantiate_ns1__UUIDv4Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__Max140Text:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__Max140Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__OtherContact1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__Max70Text:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__Max70Text(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__Max35Text:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__Max35Text(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AccountIdentification4Choice*>(p->ptr), ns1__AccountIdentification4Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AccountIdentification4Choice*>(p->ptr), ns1__AccountIdentification4Choice);
		break;
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AccountSchemeName1Choice*>(p->ptr), ns1__AccountSchemeName1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AccountSchemeName1Choice*>(p->ptr), ns1__AccountSchemeName1Choice);
		break;
	case SOAP_TYPE_ns1__AddressType3Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AddressType3Choice*>(p->ptr), ns1__AddressType3Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AddressType3Choice*>(p->ptr), ns1__AddressType3Choice);
		break;
	case SOAP_TYPE_ns1__AdviceType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AdviceType1*>(p->ptr), ns1__AdviceType1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AdviceType1*>(p->ptr), ns1__AdviceType1);
		break;
	case SOAP_TYPE_ns1__AdviceType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AdviceType1Choice*>(p->ptr), ns1__AdviceType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AdviceType1Choice*>(p->ptr), ns1__AdviceType1Choice);
		break;
	case SOAP_TYPE_ns1__AmountType4Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AmountType4Choice*>(p->ptr), ns1__AmountType4Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AmountType4Choice*>(p->ptr), ns1__AmountType4Choice);
		break;
	case SOAP_TYPE_ns1__Authorisation1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Authorisation1Choice*>(p->ptr), ns1__Authorisation1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Authorisation1Choice*>(p->ptr), ns1__Authorisation1Choice);
		break;
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BranchAndFinancialInstitutionIdentification6*>(p->ptr), ns1__BranchAndFinancialInstitutionIdentification6);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BranchAndFinancialInstitutionIdentification6*>(p->ptr), ns1__BranchAndFinancialInstitutionIdentification6);
		break;
	case SOAP_TYPE_ns1__BranchData3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BranchData3*>(p->ptr), ns1__BranchData3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BranchData3*>(p->ptr), ns1__BranchData3);
		break;
	case SOAP_TYPE_ns1__CashAccount40:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CashAccount40*>(p->ptr), ns1__CashAccount40);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CashAccount40*>(p->ptr), ns1__CashAccount40);
		break;
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CashAccountType2Choice*>(p->ptr), ns1__CashAccountType2Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CashAccountType2Choice*>(p->ptr), ns1__CashAccountType2Choice);
		break;
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CategoryPurpose1Choice*>(p->ptr), ns1__CategoryPurpose1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CategoryPurpose1Choice*>(p->ptr), ns1__CategoryPurpose1Choice);
		break;
	case SOAP_TYPE_ns1__Cheque11:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Cheque11*>(p->ptr), ns1__Cheque11);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Cheque11*>(p->ptr), ns1__Cheque11);
		break;
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ChequeDeliveryMethod1Choice*>(p->ptr), ns1__ChequeDeliveryMethod1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ChequeDeliveryMethod1Choice*>(p->ptr), ns1__ChequeDeliveryMethod1Choice);
		break;
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ClearingSystemIdentification2Choice*>(p->ptr), ns1__ClearingSystemIdentification2Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ClearingSystemIdentification2Choice*>(p->ptr), ns1__ClearingSystemIdentification2Choice);
		break;
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ClearingSystemMemberIdentification2*>(p->ptr), ns1__ClearingSystemMemberIdentification2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ClearingSystemMemberIdentification2*>(p->ptr), ns1__ClearingSystemMemberIdentification2);
		break;
	case SOAP_TYPE_ns1__Contact4:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Contact4*>(p->ptr), ns1__Contact4);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Contact4*>(p->ptr), ns1__Contact4);
		break;
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CreditTransferMandateData1*>(p->ptr), ns1__CreditTransferMandateData1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CreditTransferMandateData1*>(p->ptr), ns1__CreditTransferMandateData1);
		break;
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CreditTransferTransaction54*>(p->ptr), ns1__CreditTransferTransaction54);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CreditTransferTransaction54*>(p->ptr), ns1__CreditTransferTransaction54);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CreditorReferenceInformation2*>(p->ptr), ns1__CreditorReferenceInformation2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CreditorReferenceInformation2*>(p->ptr), ns1__CreditorReferenceInformation2);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CreditorReferenceType1Choice*>(p->ptr), ns1__CreditorReferenceType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CreditorReferenceType1Choice*>(p->ptr), ns1__CreditorReferenceType1Choice);
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CreditorReferenceType2*>(p->ptr), ns1__CreditorReferenceType2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CreditorReferenceType2*>(p->ptr), ns1__CreditorReferenceType2);
		break;
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CustomerCreditTransferInitiationV11*>(p->ptr), ns1__CustomerCreditTransferInitiationV11);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CustomerCreditTransferInitiationV11*>(p->ptr), ns1__CustomerCreditTransferInitiationV11);
		break;
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DateAndDateTime2Choice*>(p->ptr), ns1__DateAndDateTime2Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DateAndDateTime2Choice*>(p->ptr), ns1__DateAndDateTime2Choice);
		break;
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DateAndPlaceOfBirth1*>(p->ptr), ns1__DateAndPlaceOfBirth1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DateAndPlaceOfBirth1*>(p->ptr), ns1__DateAndPlaceOfBirth1);
		break;
	case SOAP_TYPE_ns1__DatePeriod2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DatePeriod2*>(p->ptr), ns1__DatePeriod2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DatePeriod2*>(p->ptr), ns1__DatePeriod2);
		break;
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DiscountAmountAndType1*>(p->ptr), ns1__DiscountAmountAndType1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DiscountAmountAndType1*>(p->ptr), ns1__DiscountAmountAndType1);
		break;
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DiscountAmountType1Choice*>(p->ptr), ns1__DiscountAmountType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DiscountAmountType1Choice*>(p->ptr), ns1__DiscountAmountType1Choice);
		break;
	case SOAP_TYPE_ns1__Document:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Document*>(p->ptr), ns1__Document);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Document*>(p->ptr), ns1__Document);
		break;
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DocumentAdjustment1*>(p->ptr), ns1__DocumentAdjustment1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DocumentAdjustment1*>(p->ptr), ns1__DocumentAdjustment1);
		break;
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DocumentLineIdentification1*>(p->ptr), ns1__DocumentLineIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DocumentLineIdentification1*>(p->ptr), ns1__DocumentLineIdentification1);
		break;
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DocumentLineInformation1*>(p->ptr), ns1__DocumentLineInformation1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DocumentLineInformation1*>(p->ptr), ns1__DocumentLineInformation1);
		break;
	case SOAP_TYPE_ns1__DocumentLineType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DocumentLineType1*>(p->ptr), ns1__DocumentLineType1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DocumentLineType1*>(p->ptr), ns1__DocumentLineType1);
		break;
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DocumentLineType1Choice*>(p->ptr), ns1__DocumentLineType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DocumentLineType1Choice*>(p->ptr), ns1__DocumentLineType1Choice);
		break;
	case SOAP_TYPE_ns1__EquivalentAmount2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__EquivalentAmount2*>(p->ptr), ns1__EquivalentAmount2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__EquivalentAmount2*>(p->ptr), ns1__EquivalentAmount2);
		break;
	case SOAP_TYPE_ns1__ExchangeRate1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ExchangeRate1*>(p->ptr), ns1__ExchangeRate1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ExchangeRate1*>(p->ptr), ns1__ExchangeRate1);
		break;
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FinancialIdentificationSchemeName1Choice*>(p->ptr), ns1__FinancialIdentificationSchemeName1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FinancialIdentificationSchemeName1Choice*>(p->ptr), ns1__FinancialIdentificationSchemeName1Choice);
		break;
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FinancialInstitutionIdentification18*>(p->ptr), ns1__FinancialInstitutionIdentification18);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FinancialInstitutionIdentification18*>(p->ptr), ns1__FinancialInstitutionIdentification18);
		break;
	case SOAP_TYPE_ns1__Frequency36Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Frequency36Choice*>(p->ptr), ns1__Frequency36Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Frequency36Choice*>(p->ptr), ns1__Frequency36Choice);
		break;
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FrequencyAndMoment1*>(p->ptr), ns1__FrequencyAndMoment1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FrequencyAndMoment1*>(p->ptr), ns1__FrequencyAndMoment1);
		break;
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FrequencyPeriod1*>(p->ptr), ns1__FrequencyPeriod1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FrequencyPeriod1*>(p->ptr), ns1__FrequencyPeriod1);
		break;
	case SOAP_TYPE_ns1__Garnishment3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Garnishment3*>(p->ptr), ns1__Garnishment3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Garnishment3*>(p->ptr), ns1__Garnishment3);
		break;
	case SOAP_TYPE_ns1__GarnishmentType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GarnishmentType1*>(p->ptr), ns1__GarnishmentType1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GarnishmentType1*>(p->ptr), ns1__GarnishmentType1);
		break;
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GarnishmentType1Choice*>(p->ptr), ns1__GarnishmentType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GarnishmentType1Choice*>(p->ptr), ns1__GarnishmentType1Choice);
		break;
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericAccountIdentification1*>(p->ptr), ns1__GenericAccountIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericAccountIdentification1*>(p->ptr), ns1__GenericAccountIdentification1);
		break;
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericFinancialIdentification1*>(p->ptr), ns1__GenericFinancialIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericFinancialIdentification1*>(p->ptr), ns1__GenericFinancialIdentification1);
		break;
	case SOAP_TYPE_ns1__GenericIdentification30:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericIdentification30*>(p->ptr), ns1__GenericIdentification30);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericIdentification30*>(p->ptr), ns1__GenericIdentification30);
		break;
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericOrganisationIdentification1*>(p->ptr), ns1__GenericOrganisationIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericOrganisationIdentification1*>(p->ptr), ns1__GenericOrganisationIdentification1);
		break;
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericPersonIdentification1*>(p->ptr), ns1__GenericPersonIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericPersonIdentification1*>(p->ptr), ns1__GenericPersonIdentification1);
		break;
	case SOAP_TYPE_ns1__GroupHeader95:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GroupHeader95*>(p->ptr), ns1__GroupHeader95);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GroupHeader95*>(p->ptr), ns1__GroupHeader95);
		break;
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InstructionForCreditorAgent3*>(p->ptr), ns1__InstructionForCreditorAgent3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InstructionForCreditorAgent3*>(p->ptr), ns1__InstructionForCreditorAgent3);
		break;
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InstructionForDebtorAgent1*>(p->ptr), ns1__InstructionForDebtorAgent1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InstructionForDebtorAgent1*>(p->ptr), ns1__InstructionForDebtorAgent1);
		break;
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__LocalInstrument2Choice*>(p->ptr), ns1__LocalInstrument2Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__LocalInstrument2Choice*>(p->ptr), ns1__LocalInstrument2Choice);
		break;
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MandateClassification1Choice*>(p->ptr), ns1__MandateClassification1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MandateClassification1Choice*>(p->ptr), ns1__MandateClassification1Choice);
		break;
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MandateSetupReason1Choice*>(p->ptr), ns1__MandateSetupReason1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MandateSetupReason1Choice*>(p->ptr), ns1__MandateSetupReason1Choice);
		break;
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MandateTypeInformation2*>(p->ptr), ns1__MandateTypeInformation2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MandateTypeInformation2*>(p->ptr), ns1__MandateTypeInformation2);
		break;
	case SOAP_TYPE_ns1__NameAndAddress16:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NameAndAddress16*>(p->ptr), ns1__NameAndAddress16);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NameAndAddress16*>(p->ptr), ns1__NameAndAddress16);
		break;
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OrganisationIdentification29*>(p->ptr), ns1__OrganisationIdentification29);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OrganisationIdentification29*>(p->ptr), ns1__OrganisationIdentification29);
		break;
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OrganisationIdentificationSchemeName1Choice*>(p->ptr), ns1__OrganisationIdentificationSchemeName1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OrganisationIdentificationSchemeName1Choice*>(p->ptr), ns1__OrganisationIdentificationSchemeName1Choice);
		break;
	case SOAP_TYPE_ns1__OtherContact1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OtherContact1*>(p->ptr), ns1__OtherContact1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OtherContact1*>(p->ptr), ns1__OtherContact1);
		break;
	case SOAP_TYPE_ns1__Party38Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Party38Choice*>(p->ptr), ns1__Party38Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Party38Choice*>(p->ptr), ns1__Party38Choice);
		break;
	case SOAP_TYPE_ns1__PartyIdentification135:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PartyIdentification135*>(p->ptr), ns1__PartyIdentification135);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PartyIdentification135*>(p->ptr), ns1__PartyIdentification135);
		break;
	case SOAP_TYPE_ns1__PaymentIdentification6:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PaymentIdentification6*>(p->ptr), ns1__PaymentIdentification6);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PaymentIdentification6*>(p->ptr), ns1__PaymentIdentification6);
		break;
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PaymentInitiationSource1*>(p->ptr), ns1__PaymentInitiationSource1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PaymentInitiationSource1*>(p->ptr), ns1__PaymentInitiationSource1);
		break;
	case SOAP_TYPE_ns1__PaymentInstruction40:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PaymentInstruction40*>(p->ptr), ns1__PaymentInstruction40);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PaymentInstruction40*>(p->ptr), ns1__PaymentInstruction40);
		break;
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PaymentTypeInformation26*>(p->ptr), ns1__PaymentTypeInformation26);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PaymentTypeInformation26*>(p->ptr), ns1__PaymentTypeInformation26);
		break;
	case SOAP_TYPE_ns1__PersonIdentification13:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PersonIdentification13*>(p->ptr), ns1__PersonIdentification13);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PersonIdentification13*>(p->ptr), ns1__PersonIdentification13);
		break;
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PersonIdentificationSchemeName1Choice*>(p->ptr), ns1__PersonIdentificationSchemeName1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PersonIdentificationSchemeName1Choice*>(p->ptr), ns1__PersonIdentificationSchemeName1Choice);
		break;
	case SOAP_TYPE_ns1__PostalAddress24:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PostalAddress24*>(p->ptr), ns1__PostalAddress24);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PostalAddress24*>(p->ptr), ns1__PostalAddress24);
		break;
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ProxyAccountIdentification1*>(p->ptr), ns1__ProxyAccountIdentification1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ProxyAccountIdentification1*>(p->ptr), ns1__ProxyAccountIdentification1);
		break;
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ProxyAccountType1Choice*>(p->ptr), ns1__ProxyAccountType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ProxyAccountType1Choice*>(p->ptr), ns1__ProxyAccountType1Choice);
		break;
	case SOAP_TYPE_ns1__Purpose2Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Purpose2Choice*>(p->ptr), ns1__Purpose2Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Purpose2Choice*>(p->ptr), ns1__Purpose2Choice);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ReferredDocumentInformation7*>(p->ptr), ns1__ReferredDocumentInformation7);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ReferredDocumentInformation7*>(p->ptr), ns1__ReferredDocumentInformation7);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ReferredDocumentType3Choice*>(p->ptr), ns1__ReferredDocumentType3Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ReferredDocumentType3Choice*>(p->ptr), ns1__ReferredDocumentType3Choice);
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ReferredDocumentType4*>(p->ptr), ns1__ReferredDocumentType4);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ReferredDocumentType4*>(p->ptr), ns1__ReferredDocumentType4);
		break;
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RegulatoryAuthority2*>(p->ptr), ns1__RegulatoryAuthority2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RegulatoryAuthority2*>(p->ptr), ns1__RegulatoryAuthority2);
		break;
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RegulatoryReporting3*>(p->ptr), ns1__RegulatoryReporting3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RegulatoryReporting3*>(p->ptr), ns1__RegulatoryReporting3);
		break;
	case SOAP_TYPE_ns1__RemittanceAmount2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RemittanceAmount2*>(p->ptr), ns1__RemittanceAmount2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RemittanceAmount2*>(p->ptr), ns1__RemittanceAmount2);
		break;
	case SOAP_TYPE_ns1__RemittanceAmount3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RemittanceAmount3*>(p->ptr), ns1__RemittanceAmount3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RemittanceAmount3*>(p->ptr), ns1__RemittanceAmount3);
		break;
	case SOAP_TYPE_ns1__RemittanceInformation21:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RemittanceInformation21*>(p->ptr), ns1__RemittanceInformation21);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RemittanceInformation21*>(p->ptr), ns1__RemittanceInformation21);
		break;
	case SOAP_TYPE_ns1__RemittanceLocation7:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RemittanceLocation7*>(p->ptr), ns1__RemittanceLocation7);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RemittanceLocation7*>(p->ptr), ns1__RemittanceLocation7);
		break;
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RemittanceLocationData1*>(p->ptr), ns1__RemittanceLocationData1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RemittanceLocationData1*>(p->ptr), ns1__RemittanceLocationData1);
		break;
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ServiceLevel8Choice*>(p->ptr), ns1__ServiceLevel8Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ServiceLevel8Choice*>(p->ptr), ns1__ServiceLevel8Choice);
		break;
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StructuredRegulatoryReporting3*>(p->ptr), ns1__StructuredRegulatoryReporting3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StructuredRegulatoryReporting3*>(p->ptr), ns1__StructuredRegulatoryReporting3);
		break;
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StructuredRemittanceInformation17*>(p->ptr), ns1__StructuredRemittanceInformation17);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StructuredRemittanceInformation17*>(p->ptr), ns1__StructuredRemittanceInformation17);
		break;
	case SOAP_TYPE_ns1__SupplementaryData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SupplementaryData1*>(p->ptr), ns1__SupplementaryData1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SupplementaryData1*>(p->ptr), ns1__SupplementaryData1);
		break;
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SupplementaryDataEnvelope1*>(p->ptr), ns1__SupplementaryDataEnvelope1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SupplementaryDataEnvelope1*>(p->ptr), ns1__SupplementaryDataEnvelope1);
		break;
	case SOAP_TYPE_ns1__TaxAmount3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxAmount3*>(p->ptr), ns1__TaxAmount3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxAmount3*>(p->ptr), ns1__TaxAmount3);
		break;
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxAmountAndType1*>(p->ptr), ns1__TaxAmountAndType1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxAmountAndType1*>(p->ptr), ns1__TaxAmountAndType1);
		break;
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxAmountType1Choice*>(p->ptr), ns1__TaxAmountType1Choice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxAmountType1Choice*>(p->ptr), ns1__TaxAmountType1Choice);
		break;
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxAuthorisation1*>(p->ptr), ns1__TaxAuthorisation1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxAuthorisation1*>(p->ptr), ns1__TaxAuthorisation1);
		break;
	case SOAP_TYPE_ns1__TaxData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxData1*>(p->ptr), ns1__TaxData1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxData1*>(p->ptr), ns1__TaxData1);
		break;
	case SOAP_TYPE_ns1__TaxInformation10:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxInformation10*>(p->ptr), ns1__TaxInformation10);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxInformation10*>(p->ptr), ns1__TaxInformation10);
		break;
	case SOAP_TYPE_ns1__TaxParty1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxParty1*>(p->ptr), ns1__TaxParty1);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxParty1*>(p->ptr), ns1__TaxParty1);
		break;
	case SOAP_TYPE_ns1__TaxParty2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxParty2*>(p->ptr), ns1__TaxParty2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxParty2*>(p->ptr), ns1__TaxParty2);
		break;
	case SOAP_TYPE_ns1__TaxPeriod3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxPeriod3*>(p->ptr), ns1__TaxPeriod3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxPeriod3*>(p->ptr), ns1__TaxPeriod3);
		break;
	case SOAP_TYPE_ns1__TaxRecord3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxRecord3*>(p->ptr), ns1__TaxRecord3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxRecord3*>(p->ptr), ns1__TaxRecord3);
		break;
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TaxRecordDetails3*>(p->ptr), ns1__TaxRecordDetails3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TaxRecordDetails3*>(p->ptr), ns1__TaxRecordDetails3);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ActiveOrHistoricCurrencyAndAmount*>(p->ptr), ns1__ActiveOrHistoricCurrencyAndAmount);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ActiveOrHistoricCurrencyAndAmount*>(p->ptr), ns1__ActiveOrHistoricCurrencyAndAmount);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__gYear:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__BaseOneRate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__CountryCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__DecimalNumber:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Exact2NumericText:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ISODate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ISOYear:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__LEIIdentifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max10KBinary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_ns1__Max10Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max128Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max140Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max15NumericText:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max16Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max2048Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max34Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max350Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max35Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max4Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Max70Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Number:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__PercentageRate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__PhoneNumber:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__TaxRecord3 *> *>(p->ptr), std::vector<ns1__TaxRecord3 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__TaxRecord3 *> *>(p->ptr), std::vector<ns1__TaxRecord3 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__TaxRecordDetails3 *> *>(p->ptr), std::vector<ns1__TaxRecordDetails3 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__TaxRecordDetails3 *> *>(p->ptr), std::vector<ns1__TaxRecordDetails3 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ReferredDocumentInformation7 *> *>(p->ptr), std::vector<ns1__ReferredDocumentInformation7 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ReferredDocumentInformation7 *> *>(p->ptr), std::vector<ns1__ReferredDocumentInformation7 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RemittanceLocationData1 *> *>(p->ptr), std::vector<ns1__RemittanceLocationData1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RemittanceLocationData1 *> *>(p->ptr), std::vector<ns1__RemittanceLocationData1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__StructuredRemittanceInformation17 *> *>(p->ptr), std::vector<ns1__StructuredRemittanceInformation17 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__StructuredRemittanceInformation17 *> *>(p->ptr), std::vector<ns1__StructuredRemittanceInformation17 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max140Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DocumentAdjustment1 *> *>(p->ptr), std::vector<ns1__DocumentAdjustment1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DocumentAdjustment1 *> *>(p->ptr), std::vector<ns1__DocumentAdjustment1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__TaxAmountAndType1 *> *>(p->ptr), std::vector<ns1__TaxAmountAndType1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__TaxAmountAndType1 *> *>(p->ptr), std::vector<ns1__TaxAmountAndType1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DiscountAmountAndType1 *> *>(p->ptr), std::vector<ns1__DiscountAmountAndType1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DiscountAmountAndType1 *> *>(p->ptr), std::vector<ns1__DiscountAmountAndType1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__StructuredRegulatoryReporting3 *> *>(p->ptr), std::vector<ns1__StructuredRegulatoryReporting3 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__StructuredRegulatoryReporting3 *> *>(p->ptr), std::vector<ns1__StructuredRegulatoryReporting3 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DocumentLineInformation1 *> *>(p->ptr), std::vector<ns1__DocumentLineInformation1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DocumentLineInformation1 *> *>(p->ptr), std::vector<ns1__DocumentLineInformation1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__GenericPersonIdentification1 *> *>(p->ptr), std::vector<ns1__GenericPersonIdentification1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__GenericPersonIdentification1 *> *>(p->ptr), std::vector<ns1__GenericPersonIdentification1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ServiceLevel8Choice *> *>(p->ptr), std::vector<ns1__ServiceLevel8Choice *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ServiceLevel8Choice *> *>(p->ptr), std::vector<ns1__ServiceLevel8Choice *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__CreditTransferTransaction54 *> *>(p->ptr), std::vector<ns1__CreditTransferTransaction54 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__CreditTransferTransaction54 *> *>(p->ptr), std::vector<ns1__CreditTransferTransaction54 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__GenericOrganisationIdentification1 *> *>(p->ptr), std::vector<ns1__GenericOrganisationIdentification1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__GenericOrganisationIdentification1 *> *>(p->ptr), std::vector<ns1__GenericOrganisationIdentification1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Authorisation1Choice *> *>(p->ptr), std::vector<ns1__Authorisation1Choice *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Authorisation1Choice *> *>(p->ptr), std::vector<ns1__Authorisation1Choice *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DocumentLineIdentification1 *> *>(p->ptr), std::vector<ns1__DocumentLineIdentification1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DocumentLineIdentification1 *> *>(p->ptr), std::vector<ns1__DocumentLineIdentification1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__PaymentInstruction40 *> *>(p->ptr), std::vector<ns1__PaymentInstruction40 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__PaymentInstruction40 *> *>(p->ptr), std::vector<ns1__PaymentInstruction40 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__SupplementaryData1 *> *>(p->ptr), std::vector<ns1__SupplementaryData1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__SupplementaryData1 *> *>(p->ptr), std::vector<ns1__SupplementaryData1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RemittanceLocation7 *> *>(p->ptr), std::vector<ns1__RemittanceLocation7 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RemittanceLocation7 *> *>(p->ptr), std::vector<ns1__RemittanceLocation7 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RegulatoryReporting3 *> *>(p->ptr), std::vector<ns1__RegulatoryReporting3 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RegulatoryReporting3 *> *>(p->ptr), std::vector<ns1__RegulatoryReporting3 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__InstructionForCreditorAgent3 *> *>(p->ptr), std::vector<ns1__InstructionForCreditorAgent3 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__InstructionForCreditorAgent3 *> *>(p->ptr), std::vector<ns1__InstructionForCreditorAgent3 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__OtherContact1 *> *>(p->ptr), std::vector<ns1__OtherContact1 *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__OtherContact1 *> *>(p->ptr), std::vector<ns1__OtherContact1 *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max70Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max35Text:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3:
		if (t == SOAP_TYPE_ns1__TaxRecord3 || soap_fbase(t, SOAP_TYPE_ns1__TaxRecord3))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__TaxRecord3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__TaxRecord3 *> *)p)[index] = *(ns1__TaxRecord3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3:
		if (t == SOAP_TYPE_ns1__TaxRecordDetails3 || soap_fbase(t, SOAP_TYPE_ns1__TaxRecordDetails3))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__TaxRecordDetails3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__TaxRecordDetails3 *> *)p)[index] = *(ns1__TaxRecordDetails3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7:
		if (t == SOAP_TYPE_ns1__ReferredDocumentInformation7 || soap_fbase(t, SOAP_TYPE_ns1__ReferredDocumentInformation7))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ReferredDocumentInformation7 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ReferredDocumentInformation7 *> *)p)[index] = *(ns1__ReferredDocumentInformation7 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1:
		if (t == SOAP_TYPE_ns1__RemittanceLocationData1 || soap_fbase(t, SOAP_TYPE_ns1__RemittanceLocationData1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RemittanceLocationData1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RemittanceLocationData1 *> *)p)[index] = *(ns1__RemittanceLocationData1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17:
		if (t == SOAP_TYPE_ns1__StructuredRemittanceInformation17 || soap_fbase(t, SOAP_TYPE_ns1__StructuredRemittanceInformation17))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__StructuredRemittanceInformation17 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__StructuredRemittanceInformation17 *> *)p)[index] = *(ns1__StructuredRemittanceInformation17 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max140Text:
		if (t == SOAP_TYPE_ns1__Max140Text)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1:
		if (t == SOAP_TYPE_ns1__DocumentAdjustment1 || soap_fbase(t, SOAP_TYPE_ns1__DocumentAdjustment1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DocumentAdjustment1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DocumentAdjustment1 *> *)p)[index] = *(ns1__DocumentAdjustment1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1:
		if (t == SOAP_TYPE_ns1__TaxAmountAndType1 || soap_fbase(t, SOAP_TYPE_ns1__TaxAmountAndType1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__TaxAmountAndType1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__TaxAmountAndType1 *> *)p)[index] = *(ns1__TaxAmountAndType1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1:
		if (t == SOAP_TYPE_ns1__DiscountAmountAndType1 || soap_fbase(t, SOAP_TYPE_ns1__DiscountAmountAndType1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DiscountAmountAndType1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DiscountAmountAndType1 *> *)p)[index] = *(ns1__DiscountAmountAndType1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3:
		if (t == SOAP_TYPE_ns1__StructuredRegulatoryReporting3 || soap_fbase(t, SOAP_TYPE_ns1__StructuredRegulatoryReporting3))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__StructuredRegulatoryReporting3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__StructuredRegulatoryReporting3 *> *)p)[index] = *(ns1__StructuredRegulatoryReporting3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1:
		if (t == SOAP_TYPE_ns1__DocumentLineInformation1 || soap_fbase(t, SOAP_TYPE_ns1__DocumentLineInformation1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DocumentLineInformation1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DocumentLineInformation1 *> *)p)[index] = *(ns1__DocumentLineInformation1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1:
		if (t == SOAP_TYPE_ns1__GenericPersonIdentification1 || soap_fbase(t, SOAP_TYPE_ns1__GenericPersonIdentification1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__GenericPersonIdentification1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__GenericPersonIdentification1 *> *)p)[index] = *(ns1__GenericPersonIdentification1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice:
		if (t == SOAP_TYPE_ns1__ServiceLevel8Choice || soap_fbase(t, SOAP_TYPE_ns1__ServiceLevel8Choice))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ServiceLevel8Choice *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ServiceLevel8Choice *> *)p)[index] = *(ns1__ServiceLevel8Choice **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54:
		if (t == SOAP_TYPE_ns1__CreditTransferTransaction54 || soap_fbase(t, SOAP_TYPE_ns1__CreditTransferTransaction54))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__CreditTransferTransaction54 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__CreditTransferTransaction54 *> *)p)[index] = *(ns1__CreditTransferTransaction54 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1:
		if (t == SOAP_TYPE_ns1__GenericOrganisationIdentification1 || soap_fbase(t, SOAP_TYPE_ns1__GenericOrganisationIdentification1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__GenericOrganisationIdentification1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__GenericOrganisationIdentification1 *> *)p)[index] = *(ns1__GenericOrganisationIdentification1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice:
		if (t == SOAP_TYPE_ns1__Authorisation1Choice || soap_fbase(t, SOAP_TYPE_ns1__Authorisation1Choice))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Authorisation1Choice *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Authorisation1Choice *> *)p)[index] = *(ns1__Authorisation1Choice **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1:
		if (t == SOAP_TYPE_ns1__DocumentLineIdentification1 || soap_fbase(t, SOAP_TYPE_ns1__DocumentLineIdentification1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DocumentLineIdentification1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DocumentLineIdentification1 *> *)p)[index] = *(ns1__DocumentLineIdentification1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40:
		if (t == SOAP_TYPE_ns1__PaymentInstruction40 || soap_fbase(t, SOAP_TYPE_ns1__PaymentInstruction40))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__PaymentInstruction40 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__PaymentInstruction40 *> *)p)[index] = *(ns1__PaymentInstruction40 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1:
		if (t == SOAP_TYPE_ns1__SupplementaryData1 || soap_fbase(t, SOAP_TYPE_ns1__SupplementaryData1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SupplementaryData1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SupplementaryData1 *> *)p)[index] = *(ns1__SupplementaryData1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7:
		if (t == SOAP_TYPE_ns1__RemittanceLocation7 || soap_fbase(t, SOAP_TYPE_ns1__RemittanceLocation7))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RemittanceLocation7 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RemittanceLocation7 *> *)p)[index] = *(ns1__RemittanceLocation7 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3:
		if (t == SOAP_TYPE_ns1__RegulatoryReporting3 || soap_fbase(t, SOAP_TYPE_ns1__RegulatoryReporting3))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RegulatoryReporting3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RegulatoryReporting3 *> *)p)[index] = *(ns1__RegulatoryReporting3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3:
		if (t == SOAP_TYPE_ns1__InstructionForCreditorAgent3 || soap_fbase(t, SOAP_TYPE_ns1__InstructionForCreditorAgent3))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__InstructionForCreditorAgent3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__InstructionForCreditorAgent3 *> *)p)[index] = *(ns1__InstructionForCreditorAgent3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1:
		if (t == SOAP_TYPE_ns1__OtherContact1 || soap_fbase(t, SOAP_TYPE_ns1__OtherContact1))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__OtherContact1 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__OtherContact1 *> *)p)[index] = *(ns1__OtherContact1 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max70Text:
		if (t == SOAP_TYPE_ns1__Max70Text)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Max35Text:
		if (t == SOAP_TYPE_ns1__Max35Text)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns1__union_AccountIdentification4Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_AccountIdentification4Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_AccountIdentification4Choice*)p = *(union _ns1__union_AccountIdentification4Choice*)q;
		break;
	case SOAP_TYPE_ns1__AccountIdentification4Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AccountIdentification4Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AccountIdentification4Choice*)p = *(ns1__AccountIdentification4Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_AccountSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_AccountSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_AccountSchemeName1Choice*)p = *(union _ns1__union_AccountSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__AccountSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AccountSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AccountSchemeName1Choice*)p = *(ns1__AccountSchemeName1Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_AddressType3Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_AddressType3Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_AddressType3Choice*)p = *(union _ns1__union_AddressType3Choice*)q;
		break;
	case SOAP_TYPE_ns1__AddressType3Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AddressType3Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AddressType3Choice*)p = *(ns1__AddressType3Choice*)q;
		break;
	case SOAP_TYPE_ns1__AdviceType1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AdviceType1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AdviceType1*)p = *(ns1__AdviceType1*)q;
		break;
	case SOAP_TYPE__ns1__union_AdviceType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_AdviceType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_AdviceType1Choice*)p = *(union _ns1__union_AdviceType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__AdviceType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AdviceType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AdviceType1Choice*)p = *(ns1__AdviceType1Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_AmountType4Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_AmountType4Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_AmountType4Choice*)p = *(union _ns1__union_AmountType4Choice*)q;
		break;
	case SOAP_TYPE_ns1__AmountType4Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AmountType4Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AmountType4Choice*)p = *(ns1__AmountType4Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_Authorisation1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_Authorisation1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_Authorisation1Choice*)p = *(union _ns1__union_Authorisation1Choice*)q;
		break;
	case SOAP_TYPE_ns1__Authorisation1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Authorisation1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Authorisation1Choice*)p = *(ns1__Authorisation1Choice*)q;
		break;
	case SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BranchAndFinancialInstitutionIdentification6 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BranchAndFinancialInstitutionIdentification6*)p = *(ns1__BranchAndFinancialInstitutionIdentification6*)q;
		break;
	case SOAP_TYPE_ns1__BranchData3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BranchData3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BranchData3*)p = *(ns1__BranchData3*)q;
		break;
	case SOAP_TYPE_ns1__CashAccount40:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CashAccount40 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CashAccount40*)p = *(ns1__CashAccount40*)q;
		break;
	case SOAP_TYPE__ns1__union_CashAccountType2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_CashAccountType2Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_CashAccountType2Choice*)p = *(union _ns1__union_CashAccountType2Choice*)q;
		break;
	case SOAP_TYPE_ns1__CashAccountType2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CashAccountType2Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CashAccountType2Choice*)p = *(ns1__CashAccountType2Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_CategoryPurpose1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_CategoryPurpose1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_CategoryPurpose1Choice*)p = *(union _ns1__union_CategoryPurpose1Choice*)q;
		break;
	case SOAP_TYPE_ns1__CategoryPurpose1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CategoryPurpose1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CategoryPurpose1Choice*)p = *(ns1__CategoryPurpose1Choice*)q;
		break;
	case SOAP_TYPE_ns1__Cheque11:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Cheque11 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Cheque11*)p = *(ns1__Cheque11*)q;
		break;
	case SOAP_TYPE__ns1__union_ChequeDeliveryMethod1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ChequeDeliveryMethod1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ChequeDeliveryMethod1Choice*)p = *(union _ns1__union_ChequeDeliveryMethod1Choice*)q;
		break;
	case SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ChequeDeliveryMethod1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ChequeDeliveryMethod1Choice*)p = *(ns1__ChequeDeliveryMethod1Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_ClearingSystemIdentification2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ClearingSystemIdentification2Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ClearingSystemIdentification2Choice*)p = *(union _ns1__union_ClearingSystemIdentification2Choice*)q;
		break;
	case SOAP_TYPE_ns1__ClearingSystemIdentification2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ClearingSystemIdentification2Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ClearingSystemIdentification2Choice*)p = *(ns1__ClearingSystemIdentification2Choice*)q;
		break;
	case SOAP_TYPE_ns1__ClearingSystemMemberIdentification2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ClearingSystemMemberIdentification2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ClearingSystemMemberIdentification2*)p = *(ns1__ClearingSystemMemberIdentification2*)q;
		break;
	case SOAP_TYPE_ns1__Contact4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Contact4 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Contact4*)p = *(ns1__Contact4*)q;
		break;
	case SOAP_TYPE_ns1__CreditTransferMandateData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CreditTransferMandateData1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CreditTransferMandateData1*)p = *(ns1__CreditTransferMandateData1*)q;
		break;
	case SOAP_TYPE_ns1__CreditTransferTransaction54:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CreditTransferTransaction54 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CreditTransferTransaction54*)p = *(ns1__CreditTransferTransaction54*)q;
		break;
	case SOAP_TYPE_ns1__CreditorReferenceInformation2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CreditorReferenceInformation2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CreditorReferenceInformation2*)p = *(ns1__CreditorReferenceInformation2*)q;
		break;
	case SOAP_TYPE__ns1__union_CreditorReferenceType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_CreditorReferenceType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_CreditorReferenceType1Choice*)p = *(union _ns1__union_CreditorReferenceType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CreditorReferenceType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CreditorReferenceType1Choice*)p = *(ns1__CreditorReferenceType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__CreditorReferenceType2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CreditorReferenceType2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CreditorReferenceType2*)p = *(ns1__CreditorReferenceType2*)q;
		break;
	case SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CustomerCreditTransferInitiationV11 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CustomerCreditTransferInitiationV11*)p = *(ns1__CustomerCreditTransferInitiationV11*)q;
		break;
	case SOAP_TYPE__ns1__union_DateAndDateTime2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_DateAndDateTime2Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_DateAndDateTime2Choice*)p = *(union _ns1__union_DateAndDateTime2Choice*)q;
		break;
	case SOAP_TYPE_ns1__DateAndDateTime2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DateAndDateTime2Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DateAndDateTime2Choice*)p = *(ns1__DateAndDateTime2Choice*)q;
		break;
	case SOAP_TYPE_ns1__DateAndPlaceOfBirth1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DateAndPlaceOfBirth1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DateAndPlaceOfBirth1*)p = *(ns1__DateAndPlaceOfBirth1*)q;
		break;
	case SOAP_TYPE_ns1__DatePeriod2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DatePeriod2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DatePeriod2*)p = *(ns1__DatePeriod2*)q;
		break;
	case SOAP_TYPE_ns1__DiscountAmountAndType1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DiscountAmountAndType1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DiscountAmountAndType1*)p = *(ns1__DiscountAmountAndType1*)q;
		break;
	case SOAP_TYPE__ns1__union_DiscountAmountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_DiscountAmountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_DiscountAmountType1Choice*)p = *(union _ns1__union_DiscountAmountType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__DiscountAmountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DiscountAmountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DiscountAmountType1Choice*)p = *(ns1__DiscountAmountType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__Document:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Document type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Document*)p = *(ns1__Document*)q;
		break;
	case SOAP_TYPE_ns1__DocumentAdjustment1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DocumentAdjustment1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DocumentAdjustment1*)p = *(ns1__DocumentAdjustment1*)q;
		break;
	case SOAP_TYPE_ns1__DocumentLineIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DocumentLineIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DocumentLineIdentification1*)p = *(ns1__DocumentLineIdentification1*)q;
		break;
	case SOAP_TYPE_ns1__DocumentLineInformation1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DocumentLineInformation1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DocumentLineInformation1*)p = *(ns1__DocumentLineInformation1*)q;
		break;
	case SOAP_TYPE_ns1__DocumentLineType1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DocumentLineType1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DocumentLineType1*)p = *(ns1__DocumentLineType1*)q;
		break;
	case SOAP_TYPE__ns1__union_DocumentLineType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_DocumentLineType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_DocumentLineType1Choice*)p = *(union _ns1__union_DocumentLineType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__DocumentLineType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DocumentLineType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DocumentLineType1Choice*)p = *(ns1__DocumentLineType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__EquivalentAmount2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__EquivalentAmount2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__EquivalentAmount2*)p = *(ns1__EquivalentAmount2*)q;
		break;
	case SOAP_TYPE_ns1__ExchangeRate1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ExchangeRate1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ExchangeRate1*)p = *(ns1__ExchangeRate1*)q;
		break;
	case SOAP_TYPE__ns1__union_FinancialIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_FinancialIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_FinancialIdentificationSchemeName1Choice*)p = *(union _ns1__union_FinancialIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FinancialIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FinancialIdentificationSchemeName1Choice*)p = *(ns1__FinancialIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__FinancialInstitutionIdentification18:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FinancialInstitutionIdentification18 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FinancialInstitutionIdentification18*)p = *(ns1__FinancialInstitutionIdentification18*)q;
		break;
	case SOAP_TYPE__ns1__union_Frequency36Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_Frequency36Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_Frequency36Choice*)p = *(union _ns1__union_Frequency36Choice*)q;
		break;
	case SOAP_TYPE_ns1__Frequency36Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Frequency36Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Frequency36Choice*)p = *(ns1__Frequency36Choice*)q;
		break;
	case SOAP_TYPE_ns1__FrequencyAndMoment1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FrequencyAndMoment1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FrequencyAndMoment1*)p = *(ns1__FrequencyAndMoment1*)q;
		break;
	case SOAP_TYPE_ns1__FrequencyPeriod1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FrequencyPeriod1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FrequencyPeriod1*)p = *(ns1__FrequencyPeriod1*)q;
		break;
	case SOAP_TYPE_ns1__Garnishment3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Garnishment3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Garnishment3*)p = *(ns1__Garnishment3*)q;
		break;
	case SOAP_TYPE_ns1__GarnishmentType1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GarnishmentType1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GarnishmentType1*)p = *(ns1__GarnishmentType1*)q;
		break;
	case SOAP_TYPE__ns1__union_GarnishmentType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_GarnishmentType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_GarnishmentType1Choice*)p = *(union _ns1__union_GarnishmentType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__GarnishmentType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GarnishmentType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GarnishmentType1Choice*)p = *(ns1__GarnishmentType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__GenericAccountIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericAccountIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericAccountIdentification1*)p = *(ns1__GenericAccountIdentification1*)q;
		break;
	case SOAP_TYPE_ns1__GenericFinancialIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericFinancialIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericFinancialIdentification1*)p = *(ns1__GenericFinancialIdentification1*)q;
		break;
	case SOAP_TYPE_ns1__GenericIdentification30:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericIdentification30 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericIdentification30*)p = *(ns1__GenericIdentification30*)q;
		break;
	case SOAP_TYPE_ns1__GenericOrganisationIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericOrganisationIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericOrganisationIdentification1*)p = *(ns1__GenericOrganisationIdentification1*)q;
		break;
	case SOAP_TYPE_ns1__GenericPersonIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericPersonIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericPersonIdentification1*)p = *(ns1__GenericPersonIdentification1*)q;
		break;
	case SOAP_TYPE_ns1__GroupHeader95:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GroupHeader95 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GroupHeader95*)p = *(ns1__GroupHeader95*)q;
		break;
	case SOAP_TYPE_ns1__InstructionForCreditorAgent3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InstructionForCreditorAgent3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InstructionForCreditorAgent3*)p = *(ns1__InstructionForCreditorAgent3*)q;
		break;
	case SOAP_TYPE_ns1__InstructionForDebtorAgent1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InstructionForDebtorAgent1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InstructionForDebtorAgent1*)p = *(ns1__InstructionForDebtorAgent1*)q;
		break;
	case SOAP_TYPE__ns1__union_LocalInstrument2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_LocalInstrument2Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_LocalInstrument2Choice*)p = *(union _ns1__union_LocalInstrument2Choice*)q;
		break;
	case SOAP_TYPE_ns1__LocalInstrument2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LocalInstrument2Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LocalInstrument2Choice*)p = *(ns1__LocalInstrument2Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_MandateClassification1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_MandateClassification1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_MandateClassification1Choice*)p = *(union _ns1__union_MandateClassification1Choice*)q;
		break;
	case SOAP_TYPE_ns1__MandateClassification1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MandateClassification1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MandateClassification1Choice*)p = *(ns1__MandateClassification1Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_MandateSetupReason1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_MandateSetupReason1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_MandateSetupReason1Choice*)p = *(union _ns1__union_MandateSetupReason1Choice*)q;
		break;
	case SOAP_TYPE_ns1__MandateSetupReason1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MandateSetupReason1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MandateSetupReason1Choice*)p = *(ns1__MandateSetupReason1Choice*)q;
		break;
	case SOAP_TYPE_ns1__MandateTypeInformation2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MandateTypeInformation2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MandateTypeInformation2*)p = *(ns1__MandateTypeInformation2*)q;
		break;
	case SOAP_TYPE_ns1__NameAndAddress16:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NameAndAddress16 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NameAndAddress16*)p = *(ns1__NameAndAddress16*)q;
		break;
	case SOAP_TYPE_ns1__OrganisationIdentification29:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OrganisationIdentification29 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OrganisationIdentification29*)p = *(ns1__OrganisationIdentification29*)q;
		break;
	case SOAP_TYPE__ns1__union_OrganisationIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_OrganisationIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_OrganisationIdentificationSchemeName1Choice*)p = *(union _ns1__union_OrganisationIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OrganisationIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OrganisationIdentificationSchemeName1Choice*)p = *(ns1__OrganisationIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__OtherContact1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OtherContact1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OtherContact1*)p = *(ns1__OtherContact1*)q;
		break;
	case SOAP_TYPE__ns1__union_Party38Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_Party38Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_Party38Choice*)p = *(union _ns1__union_Party38Choice*)q;
		break;
	case SOAP_TYPE_ns1__Party38Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Party38Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Party38Choice*)p = *(ns1__Party38Choice*)q;
		break;
	case SOAP_TYPE_ns1__PartyIdentification135:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PartyIdentification135 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PartyIdentification135*)p = *(ns1__PartyIdentification135*)q;
		break;
	case SOAP_TYPE_ns1__PaymentIdentification6:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PaymentIdentification6 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PaymentIdentification6*)p = *(ns1__PaymentIdentification6*)q;
		break;
	case SOAP_TYPE_ns1__PaymentInitiationSource1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PaymentInitiationSource1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PaymentInitiationSource1*)p = *(ns1__PaymentInitiationSource1*)q;
		break;
	case SOAP_TYPE_ns1__PaymentInstruction40:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PaymentInstruction40 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PaymentInstruction40*)p = *(ns1__PaymentInstruction40*)q;
		break;
	case SOAP_TYPE_ns1__PaymentTypeInformation26:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PaymentTypeInformation26 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PaymentTypeInformation26*)p = *(ns1__PaymentTypeInformation26*)q;
		break;
	case SOAP_TYPE_ns1__PersonIdentification13:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PersonIdentification13 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PersonIdentification13*)p = *(ns1__PersonIdentification13*)q;
		break;
	case SOAP_TYPE__ns1__union_PersonIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_PersonIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_PersonIdentificationSchemeName1Choice*)p = *(union _ns1__union_PersonIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PersonIdentificationSchemeName1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PersonIdentificationSchemeName1Choice*)p = *(ns1__PersonIdentificationSchemeName1Choice*)q;
		break;
	case SOAP_TYPE_ns1__PostalAddress24:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PostalAddress24 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PostalAddress24*)p = *(ns1__PostalAddress24*)q;
		break;
	case SOAP_TYPE_ns1__ProxyAccountIdentification1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ProxyAccountIdentification1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ProxyAccountIdentification1*)p = *(ns1__ProxyAccountIdentification1*)q;
		break;
	case SOAP_TYPE__ns1__union_ProxyAccountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ProxyAccountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ProxyAccountType1Choice*)p = *(union _ns1__union_ProxyAccountType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__ProxyAccountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ProxyAccountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ProxyAccountType1Choice*)p = *(ns1__ProxyAccountType1Choice*)q;
		break;
	case SOAP_TYPE__ns1__union_Purpose2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_Purpose2Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_Purpose2Choice*)p = *(union _ns1__union_Purpose2Choice*)q;
		break;
	case SOAP_TYPE_ns1__Purpose2Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Purpose2Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Purpose2Choice*)p = *(ns1__Purpose2Choice*)q;
		break;
	case SOAP_TYPE_ns1__ReferredDocumentInformation7:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReferredDocumentInformation7 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReferredDocumentInformation7*)p = *(ns1__ReferredDocumentInformation7*)q;
		break;
	case SOAP_TYPE__ns1__union_ReferredDocumentType3Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ReferredDocumentType3Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ReferredDocumentType3Choice*)p = *(union _ns1__union_ReferredDocumentType3Choice*)q;
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType3Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReferredDocumentType3Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReferredDocumentType3Choice*)p = *(ns1__ReferredDocumentType3Choice*)q;
		break;
	case SOAP_TYPE_ns1__ReferredDocumentType4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReferredDocumentType4 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReferredDocumentType4*)p = *(ns1__ReferredDocumentType4*)q;
		break;
	case SOAP_TYPE_ns1__RegulatoryAuthority2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RegulatoryAuthority2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RegulatoryAuthority2*)p = *(ns1__RegulatoryAuthority2*)q;
		break;
	case SOAP_TYPE_ns1__RegulatoryReporting3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RegulatoryReporting3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RegulatoryReporting3*)p = *(ns1__RegulatoryReporting3*)q;
		break;
	case SOAP_TYPE_ns1__RemittanceAmount2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RemittanceAmount2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RemittanceAmount2*)p = *(ns1__RemittanceAmount2*)q;
		break;
	case SOAP_TYPE_ns1__RemittanceAmount3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RemittanceAmount3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RemittanceAmount3*)p = *(ns1__RemittanceAmount3*)q;
		break;
	case SOAP_TYPE_ns1__RemittanceInformation21:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RemittanceInformation21 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RemittanceInformation21*)p = *(ns1__RemittanceInformation21*)q;
		break;
	case SOAP_TYPE_ns1__RemittanceLocation7:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RemittanceLocation7 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RemittanceLocation7*)p = *(ns1__RemittanceLocation7*)q;
		break;
	case SOAP_TYPE_ns1__RemittanceLocationData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RemittanceLocationData1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RemittanceLocationData1*)p = *(ns1__RemittanceLocationData1*)q;
		break;
	case SOAP_TYPE__ns1__union_ServiceLevel8Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ServiceLevel8Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ServiceLevel8Choice*)p = *(union _ns1__union_ServiceLevel8Choice*)q;
		break;
	case SOAP_TYPE_ns1__ServiceLevel8Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ServiceLevel8Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ServiceLevel8Choice*)p = *(ns1__ServiceLevel8Choice*)q;
		break;
	case SOAP_TYPE_ns1__StructuredRegulatoryReporting3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StructuredRegulatoryReporting3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StructuredRegulatoryReporting3*)p = *(ns1__StructuredRegulatoryReporting3*)q;
		break;
	case SOAP_TYPE_ns1__StructuredRemittanceInformation17:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StructuredRemittanceInformation17 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StructuredRemittanceInformation17*)p = *(ns1__StructuredRemittanceInformation17*)q;
		break;
	case SOAP_TYPE_ns1__SupplementaryData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SupplementaryData1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SupplementaryData1*)p = *(ns1__SupplementaryData1*)q;
		break;
	case SOAP_TYPE_ns1__SupplementaryDataEnvelope1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SupplementaryDataEnvelope1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SupplementaryDataEnvelope1*)p = *(ns1__SupplementaryDataEnvelope1*)q;
		break;
	case SOAP_TYPE_ns1__TaxAmount3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxAmount3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxAmount3*)p = *(ns1__TaxAmount3*)q;
		break;
	case SOAP_TYPE_ns1__TaxAmountAndType1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxAmountAndType1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxAmountAndType1*)p = *(ns1__TaxAmountAndType1*)q;
		break;
	case SOAP_TYPE__ns1__union_TaxAmountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_TaxAmountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_TaxAmountType1Choice*)p = *(union _ns1__union_TaxAmountType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__TaxAmountType1Choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxAmountType1Choice type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxAmountType1Choice*)p = *(ns1__TaxAmountType1Choice*)q;
		break;
	case SOAP_TYPE_ns1__TaxAuthorisation1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxAuthorisation1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxAuthorisation1*)p = *(ns1__TaxAuthorisation1*)q;
		break;
	case SOAP_TYPE_ns1__TaxData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxData1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxData1*)p = *(ns1__TaxData1*)q;
		break;
	case SOAP_TYPE_ns1__TaxInformation10:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxInformation10 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxInformation10*)p = *(ns1__TaxInformation10*)q;
		break;
	case SOAP_TYPE_ns1__TaxParty1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxParty1 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxParty1*)p = *(ns1__TaxParty1*)q;
		break;
	case SOAP_TYPE_ns1__TaxParty2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxParty2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxParty2*)p = *(ns1__TaxParty2*)q;
		break;
	case SOAP_TYPE_ns1__TaxPeriod3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxPeriod3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxPeriod3*)p = *(ns1__TaxPeriod3*)q;
		break;
	case SOAP_TYPE_ns1__TaxRecord3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxRecord3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxRecord3*)p = *(ns1__TaxRecord3*)q;
		break;
	case SOAP_TYPE_ns1__TaxRecordDetails3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TaxRecordDetails3 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TaxRecordDetails3*)p = *(ns1__TaxRecordDetails3*)q;
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ActiveOrHistoricCurrencyAndAmount type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ActiveOrHistoricCurrencyAndAmount*)p = *(ns1__ActiveOrHistoricCurrencyAndAmount*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__gYear:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__AnyBICDec2014Identifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__BICFIDec2014Identifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__BaseOneRate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__CountryCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__DecimalNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Exact2NumericText:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Exact4AlphaNumericText:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalAccountIdentification1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalCashAccountType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalCategoryPurpose1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalDiscountAmountType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalDocumentLineType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalGarnishmentType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalLocalInstrument1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalMandateSetupReason1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalPersonIdentification1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalProxyAccountType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalPurpose1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalServiceLevel1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ExternalTaxAmountType1Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__IBAN2007Identifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ISODate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ISOYear:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__LEIIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max10KBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_ns1__Max10Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max128Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max140Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max15NumericText:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max16Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max2048Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max34Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max350Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max35Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max4Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Max70Text:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Number:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__PercentageRate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__PhoneNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__UUIDv4Identifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ISODateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ns1__ISODateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_ns1__ISODateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ns1__ISODateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ISODateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ISODateTime(soap, tag ? tag : "ns1:ISODateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_ns1__ISODateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ISODateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrueFalseIndicator(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrueFalseIndicator), type) || soap_send(soap, soap_ns1__TrueFalseIndicator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_ns1__TrueFalseIndicator(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrueFalseIndicator, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__TrueFalseIndicator(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrueFalseIndicator, SOAP_TYPE_ns1__TrueFalseIndicator, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TrueFalseIndicator(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_ns1__TrueFalseIndicator(soap, tag ? tag : "ns1:TrueFalseIndicator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_ns1__TrueFalseIndicator(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrueFalseIndicator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__TaxRecordPeriod1Code[] =
{	{ (LONG64)ns1__TaxRecordPeriod1Code__MM01, "MM01" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM02, "MM02" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM03, "MM03" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM04, "MM04" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM05, "MM05" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM06, "MM06" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM07, "MM07" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM08, "MM08" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM09, "MM09" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM10, "MM10" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM11, "MM11" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__MM12, "MM12" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__QTR1, "QTR1" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__QTR2, "QTR2" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__QTR3, "QTR3" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__QTR4, "QTR4" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__HLF1, "HLF1" },
	{ (LONG64)ns1__TaxRecordPeriod1Code__HLF2, "HLF2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TaxRecordPeriod1Code2s(struct soap *soap, enum ns1__TaxRecordPeriod1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__TaxRecordPeriod1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxRecordPeriod1Code(struct soap *soap, const char *tag, int id, const enum ns1__TaxRecordPeriod1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxRecordPeriod1Code), type) || soap_send(soap, soap_ns1__TaxRecordPeriod1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TaxRecordPeriod1Code(struct soap *soap, const char *s, enum ns1__TaxRecordPeriod1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TaxRecordPeriod1Code, s);
	if (map)
		*a = (enum ns1__TaxRecordPeriod1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 17)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TaxRecordPeriod1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TaxRecordPeriod1Code * SOAP_FMAC4 soap_in_ns1__TaxRecordPeriod1Code(struct soap *soap, const char *tag, enum ns1__TaxRecordPeriod1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TaxRecordPeriod1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxRecordPeriod1Code, sizeof(enum ns1__TaxRecordPeriod1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__TaxRecordPeriod1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__TaxRecordPeriod1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxRecordPeriod1Code, SOAP_TYPE_ns1__TaxRecordPeriod1Code, sizeof(enum ns1__TaxRecordPeriod1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__TaxRecordPeriod1Code * SOAP_FMAC4 soap_new_ns1__TaxRecordPeriod1Code(struct soap *soap, int n)
{
	enum ns1__TaxRecordPeriod1Code *a = static_cast<enum ns1__TaxRecordPeriod1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__TaxRecordPeriod1Code)));
	for (enum ns1__TaxRecordPeriod1Code *p = a; p && n--; ++p)
		soap_default_ns1__TaxRecordPeriod1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TaxRecordPeriod1Code(struct soap *soap, const enum ns1__TaxRecordPeriod1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__TaxRecordPeriod1Code(soap, tag ? tag : "ns1:TaxRecordPeriod1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TaxRecordPeriod1Code * SOAP_FMAC4 soap_get_ns1__TaxRecordPeriod1Code(struct soap *soap, enum ns1__TaxRecordPeriod1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxRecordPeriod1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__RemittanceLocationMethod2Code[] =
{	{ (LONG64)ns1__RemittanceLocationMethod2Code__FAXI, "FAXI" },
	{ (LONG64)ns1__RemittanceLocationMethod2Code__EDIC, "EDIC" },
	{ (LONG64)ns1__RemittanceLocationMethod2Code__URID, "URID" },
	{ (LONG64)ns1__RemittanceLocationMethod2Code__EMAL, "EMAL" },
	{ (LONG64)ns1__RemittanceLocationMethod2Code__POST, "POST" },
	{ (LONG64)ns1__RemittanceLocationMethod2Code__SMSM, "SMSM" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RemittanceLocationMethod2Code2s(struct soap *soap, enum ns1__RemittanceLocationMethod2Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__RemittanceLocationMethod2Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceLocationMethod2Code(struct soap *soap, const char *tag, int id, const enum ns1__RemittanceLocationMethod2Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceLocationMethod2Code), type) || soap_send(soap, soap_ns1__RemittanceLocationMethod2Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RemittanceLocationMethod2Code(struct soap *soap, const char *s, enum ns1__RemittanceLocationMethod2Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RemittanceLocationMethod2Code, s);
	if (map)
		*a = (enum ns1__RemittanceLocationMethod2Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RemittanceLocationMethod2Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RemittanceLocationMethod2Code * SOAP_FMAC4 soap_in_ns1__RemittanceLocationMethod2Code(struct soap *soap, const char *tag, enum ns1__RemittanceLocationMethod2Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RemittanceLocationMethod2Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceLocationMethod2Code, sizeof(enum ns1__RemittanceLocationMethod2Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__RemittanceLocationMethod2Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__RemittanceLocationMethod2Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceLocationMethod2Code, SOAP_TYPE_ns1__RemittanceLocationMethod2Code, sizeof(enum ns1__RemittanceLocationMethod2Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__RemittanceLocationMethod2Code * SOAP_FMAC4 soap_new_ns1__RemittanceLocationMethod2Code(struct soap *soap, int n)
{
	enum ns1__RemittanceLocationMethod2Code *a = static_cast<enum ns1__RemittanceLocationMethod2Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__RemittanceLocationMethod2Code)));
	for (enum ns1__RemittanceLocationMethod2Code *p = a; p && n--; ++p)
		soap_default_ns1__RemittanceLocationMethod2Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RemittanceLocationMethod2Code(struct soap *soap, const enum ns1__RemittanceLocationMethod2Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__RemittanceLocationMethod2Code(soap, tag ? tag : "ns1:RemittanceLocationMethod2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RemittanceLocationMethod2Code * SOAP_FMAC4 soap_get_ns1__RemittanceLocationMethod2Code(struct soap *soap, enum ns1__RemittanceLocationMethod2Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceLocationMethod2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__RegulatoryReportingType1Code[] =
{	{ (LONG64)ns1__RegulatoryReportingType1Code__CRED, "CRED" },
	{ (LONG64)ns1__RegulatoryReportingType1Code__DEBT, "DEBT" },
	{ (LONG64)ns1__RegulatoryReportingType1Code__BOTH, "BOTH" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RegulatoryReportingType1Code2s(struct soap *soap, enum ns1__RegulatoryReportingType1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__RegulatoryReportingType1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegulatoryReportingType1Code(struct soap *soap, const char *tag, int id, const enum ns1__RegulatoryReportingType1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegulatoryReportingType1Code), type) || soap_send(soap, soap_ns1__RegulatoryReportingType1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RegulatoryReportingType1Code(struct soap *soap, const char *s, enum ns1__RegulatoryReportingType1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RegulatoryReportingType1Code, s);
	if (map)
		*a = (enum ns1__RegulatoryReportingType1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RegulatoryReportingType1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RegulatoryReportingType1Code * SOAP_FMAC4 soap_in_ns1__RegulatoryReportingType1Code(struct soap *soap, const char *tag, enum ns1__RegulatoryReportingType1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RegulatoryReportingType1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegulatoryReportingType1Code, sizeof(enum ns1__RegulatoryReportingType1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__RegulatoryReportingType1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__RegulatoryReportingType1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegulatoryReportingType1Code, SOAP_TYPE_ns1__RegulatoryReportingType1Code, sizeof(enum ns1__RegulatoryReportingType1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__RegulatoryReportingType1Code * SOAP_FMAC4 soap_new_ns1__RegulatoryReportingType1Code(struct soap *soap, int n)
{
	enum ns1__RegulatoryReportingType1Code *a = static_cast<enum ns1__RegulatoryReportingType1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__RegulatoryReportingType1Code)));
	for (enum ns1__RegulatoryReportingType1Code *p = a; p && n--; ++p)
		soap_default_ns1__RegulatoryReportingType1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RegulatoryReportingType1Code(struct soap *soap, const enum ns1__RegulatoryReportingType1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__RegulatoryReportingType1Code(soap, tag ? tag : "ns1:RegulatoryReportingType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RegulatoryReportingType1Code * SOAP_FMAC4 soap_get_ns1__RegulatoryReportingType1Code(struct soap *soap, enum ns1__RegulatoryReportingType1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegulatoryReportingType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Priority2Code[] =
{	{ (LONG64)ns1__Priority2Code__HIGH, "HIGH" },
	{ (LONG64)ns1__Priority2Code__NORM, "NORM" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Priority2Code2s(struct soap *soap, enum ns1__Priority2Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__Priority2Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Priority2Code(struct soap *soap, const char *tag, int id, const enum ns1__Priority2Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Priority2Code), type) || soap_send(soap, soap_ns1__Priority2Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Priority2Code(struct soap *soap, const char *s, enum ns1__Priority2Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Priority2Code, s);
	if (map)
		*a = (enum ns1__Priority2Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Priority2Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Priority2Code * SOAP_FMAC4 soap_in_ns1__Priority2Code(struct soap *soap, const char *tag, enum ns1__Priority2Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Priority2Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Priority2Code, sizeof(enum ns1__Priority2Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Priority2Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Priority2Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Priority2Code, SOAP_TYPE_ns1__Priority2Code, sizeof(enum ns1__Priority2Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Priority2Code * SOAP_FMAC4 soap_new_ns1__Priority2Code(struct soap *soap, int n)
{
	enum ns1__Priority2Code *a = static_cast<enum ns1__Priority2Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Priority2Code)));
	for (enum ns1__Priority2Code *p = a; p && n--; ++p)
		soap_default_ns1__Priority2Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Priority2Code(struct soap *soap, const enum ns1__Priority2Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Priority2Code(soap, tag ? tag : "ns1:Priority2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Priority2Code * SOAP_FMAC4 soap_get_ns1__Priority2Code(struct soap *soap, enum ns1__Priority2Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Priority2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__PreferredContactMethod1Code[] =
{	{ (LONG64)ns1__PreferredContactMethod1Code__LETT, "LETT" },
	{ (LONG64)ns1__PreferredContactMethod1Code__MAIL, "MAIL" },
	{ (LONG64)ns1__PreferredContactMethod1Code__PHON, "PHON" },
	{ (LONG64)ns1__PreferredContactMethod1Code__FAXX, "FAXX" },
	{ (LONG64)ns1__PreferredContactMethod1Code__CELL, "CELL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PreferredContactMethod1Code2s(struct soap *soap, enum ns1__PreferredContactMethod1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__PreferredContactMethod1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PreferredContactMethod1Code(struct soap *soap, const char *tag, int id, const enum ns1__PreferredContactMethod1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PreferredContactMethod1Code), type) || soap_send(soap, soap_ns1__PreferredContactMethod1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PreferredContactMethod1Code(struct soap *soap, const char *s, enum ns1__PreferredContactMethod1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PreferredContactMethod1Code, s);
	if (map)
		*a = (enum ns1__PreferredContactMethod1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PreferredContactMethod1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PreferredContactMethod1Code * SOAP_FMAC4 soap_in_ns1__PreferredContactMethod1Code(struct soap *soap, const char *tag, enum ns1__PreferredContactMethod1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PreferredContactMethod1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PreferredContactMethod1Code, sizeof(enum ns1__PreferredContactMethod1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__PreferredContactMethod1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__PreferredContactMethod1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PreferredContactMethod1Code, SOAP_TYPE_ns1__PreferredContactMethod1Code, sizeof(enum ns1__PreferredContactMethod1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__PreferredContactMethod1Code * SOAP_FMAC4 soap_new_ns1__PreferredContactMethod1Code(struct soap *soap, int n)
{
	enum ns1__PreferredContactMethod1Code *a = static_cast<enum ns1__PreferredContactMethod1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__PreferredContactMethod1Code)));
	for (enum ns1__PreferredContactMethod1Code *p = a; p && n--; ++p)
		soap_default_ns1__PreferredContactMethod1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PreferredContactMethod1Code(struct soap *soap, const enum ns1__PreferredContactMethod1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__PreferredContactMethod1Code(soap, tag ? tag : "ns1:PreferredContactMethod1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PreferredContactMethod1Code * SOAP_FMAC4 soap_get_ns1__PreferredContactMethod1Code(struct soap *soap, enum ns1__PreferredContactMethod1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PreferredContactMethod1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__PaymentMethod3Code[] =
{	{ (LONG64)ns1__PaymentMethod3Code__CHK, "CHK" },
	{ (LONG64)ns1__PaymentMethod3Code__TRF, "TRF" },
	{ (LONG64)ns1__PaymentMethod3Code__TRA, "TRA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PaymentMethod3Code2s(struct soap *soap, enum ns1__PaymentMethod3Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__PaymentMethod3Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentMethod3Code(struct soap *soap, const char *tag, int id, const enum ns1__PaymentMethod3Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentMethod3Code), type) || soap_send(soap, soap_ns1__PaymentMethod3Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PaymentMethod3Code(struct soap *soap, const char *s, enum ns1__PaymentMethod3Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PaymentMethod3Code, s);
	if (map)
		*a = (enum ns1__PaymentMethod3Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PaymentMethod3Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PaymentMethod3Code * SOAP_FMAC4 soap_in_ns1__PaymentMethod3Code(struct soap *soap, const char *tag, enum ns1__PaymentMethod3Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PaymentMethod3Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentMethod3Code, sizeof(enum ns1__PaymentMethod3Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__PaymentMethod3Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__PaymentMethod3Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentMethod3Code, SOAP_TYPE_ns1__PaymentMethod3Code, sizeof(enum ns1__PaymentMethod3Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__PaymentMethod3Code * SOAP_FMAC4 soap_new_ns1__PaymentMethod3Code(struct soap *soap, int n)
{
	enum ns1__PaymentMethod3Code *a = static_cast<enum ns1__PaymentMethod3Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__PaymentMethod3Code)));
	for (enum ns1__PaymentMethod3Code *p = a; p && n--; ++p)
		soap_default_ns1__PaymentMethod3Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PaymentMethod3Code(struct soap *soap, const enum ns1__PaymentMethod3Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__PaymentMethod3Code(soap, tag ? tag : "ns1:PaymentMethod3Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PaymentMethod3Code * SOAP_FMAC4 soap_get_ns1__PaymentMethod3Code(struct soap *soap, enum ns1__PaymentMethod3Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentMethod3Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__NamePrefix2Code[] =
{	{ (LONG64)ns1__NamePrefix2Code__DOCT, "DOCT" },
	{ (LONG64)ns1__NamePrefix2Code__MADM, "MADM" },
	{ (LONG64)ns1__NamePrefix2Code__MISS, "MISS" },
	{ (LONG64)ns1__NamePrefix2Code__MIST, "MIST" },
	{ (LONG64)ns1__NamePrefix2Code__MIKS, "MIKS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NamePrefix2Code2s(struct soap *soap, enum ns1__NamePrefix2Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__NamePrefix2Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NamePrefix2Code(struct soap *soap, const char *tag, int id, const enum ns1__NamePrefix2Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NamePrefix2Code), type) || soap_send(soap, soap_ns1__NamePrefix2Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NamePrefix2Code(struct soap *soap, const char *s, enum ns1__NamePrefix2Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NamePrefix2Code, s);
	if (map)
		*a = (enum ns1__NamePrefix2Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NamePrefix2Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NamePrefix2Code * SOAP_FMAC4 soap_in_ns1__NamePrefix2Code(struct soap *soap, const char *tag, enum ns1__NamePrefix2Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NamePrefix2Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NamePrefix2Code, sizeof(enum ns1__NamePrefix2Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__NamePrefix2Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__NamePrefix2Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NamePrefix2Code, SOAP_TYPE_ns1__NamePrefix2Code, sizeof(enum ns1__NamePrefix2Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__NamePrefix2Code * SOAP_FMAC4 soap_new_ns1__NamePrefix2Code(struct soap *soap, int n)
{
	enum ns1__NamePrefix2Code *a = static_cast<enum ns1__NamePrefix2Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__NamePrefix2Code)));
	for (enum ns1__NamePrefix2Code *p = a; p && n--; ++p)
		soap_default_ns1__NamePrefix2Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NamePrefix2Code(struct soap *soap, const enum ns1__NamePrefix2Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__NamePrefix2Code(soap, tag ? tag : "ns1:NamePrefix2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NamePrefix2Code * SOAP_FMAC4 soap_get_ns1__NamePrefix2Code(struct soap *soap, enum ns1__NamePrefix2Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NamePrefix2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__MandateClassification1Code[] =
{	{ (LONG64)ns1__MandateClassification1Code__FIXE, "FIXE" },
	{ (LONG64)ns1__MandateClassification1Code__USGB, "USGB" },
	{ (LONG64)ns1__MandateClassification1Code__VARI, "VARI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MandateClassification1Code2s(struct soap *soap, enum ns1__MandateClassification1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__MandateClassification1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MandateClassification1Code(struct soap *soap, const char *tag, int id, const enum ns1__MandateClassification1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MandateClassification1Code), type) || soap_send(soap, soap_ns1__MandateClassification1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MandateClassification1Code(struct soap *soap, const char *s, enum ns1__MandateClassification1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MandateClassification1Code, s);
	if (map)
		*a = (enum ns1__MandateClassification1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MandateClassification1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MandateClassification1Code * SOAP_FMAC4 soap_in_ns1__MandateClassification1Code(struct soap *soap, const char *tag, enum ns1__MandateClassification1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MandateClassification1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MandateClassification1Code, sizeof(enum ns1__MandateClassification1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__MandateClassification1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__MandateClassification1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MandateClassification1Code, SOAP_TYPE_ns1__MandateClassification1Code, sizeof(enum ns1__MandateClassification1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__MandateClassification1Code * SOAP_FMAC4 soap_new_ns1__MandateClassification1Code(struct soap *soap, int n)
{
	enum ns1__MandateClassification1Code *a = static_cast<enum ns1__MandateClassification1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__MandateClassification1Code)));
	for (enum ns1__MandateClassification1Code *p = a; p && n--; ++p)
		soap_default_ns1__MandateClassification1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MandateClassification1Code(struct soap *soap, const enum ns1__MandateClassification1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__MandateClassification1Code(soap, tag ? tag : "ns1:MandateClassification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MandateClassification1Code * SOAP_FMAC4 soap_get_ns1__MandateClassification1Code(struct soap *soap, enum ns1__MandateClassification1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MandateClassification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Frequency6Code[] =
{	{ (LONG64)ns1__Frequency6Code__YEAR, "YEAR" },
	{ (LONG64)ns1__Frequency6Code__MNTH, "MNTH" },
	{ (LONG64)ns1__Frequency6Code__QURT, "QURT" },
	{ (LONG64)ns1__Frequency6Code__MIAN, "MIAN" },
	{ (LONG64)ns1__Frequency6Code__WEEK, "WEEK" },
	{ (LONG64)ns1__Frequency6Code__DAIL, "DAIL" },
	{ (LONG64)ns1__Frequency6Code__ADHO, "ADHO" },
	{ (LONG64)ns1__Frequency6Code__INDA, "INDA" },
	{ (LONG64)ns1__Frequency6Code__FRTN, "FRTN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Frequency6Code2s(struct soap *soap, enum ns1__Frequency6Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__Frequency6Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Frequency6Code(struct soap *soap, const char *tag, int id, const enum ns1__Frequency6Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Frequency6Code), type) || soap_send(soap, soap_ns1__Frequency6Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Frequency6Code(struct soap *soap, const char *s, enum ns1__Frequency6Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Frequency6Code, s);
	if (map)
		*a = (enum ns1__Frequency6Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 8)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Frequency6Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Frequency6Code * SOAP_FMAC4 soap_in_ns1__Frequency6Code(struct soap *soap, const char *tag, enum ns1__Frequency6Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Frequency6Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Frequency6Code, sizeof(enum ns1__Frequency6Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Frequency6Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Frequency6Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Frequency6Code, SOAP_TYPE_ns1__Frequency6Code, sizeof(enum ns1__Frequency6Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Frequency6Code * SOAP_FMAC4 soap_new_ns1__Frequency6Code(struct soap *soap, int n)
{
	enum ns1__Frequency6Code *a = static_cast<enum ns1__Frequency6Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Frequency6Code)));
	for (enum ns1__Frequency6Code *p = a; p && n--; ++p)
		soap_default_ns1__Frequency6Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Frequency6Code(struct soap *soap, const enum ns1__Frequency6Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Frequency6Code(soap, tag ? tag : "ns1:Frequency6Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Frequency6Code * SOAP_FMAC4 soap_get_ns1__Frequency6Code(struct soap *soap, enum ns1__Frequency6Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Frequency6Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ExchangeRateType1Code[] =
{	{ (LONG64)ns1__ExchangeRateType1Code__SPOT, "SPOT" },
	{ (LONG64)ns1__ExchangeRateType1Code__SALE, "SALE" },
	{ (LONG64)ns1__ExchangeRateType1Code__AGRD, "AGRD" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ExchangeRateType1Code2s(struct soap *soap, enum ns1__ExchangeRateType1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__ExchangeRateType1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExchangeRateType1Code(struct soap *soap, const char *tag, int id, const enum ns1__ExchangeRateType1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExchangeRateType1Code), type) || soap_send(soap, soap_ns1__ExchangeRateType1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ExchangeRateType1Code(struct soap *soap, const char *s, enum ns1__ExchangeRateType1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ExchangeRateType1Code, s);
	if (map)
		*a = (enum ns1__ExchangeRateType1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ExchangeRateType1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ExchangeRateType1Code * SOAP_FMAC4 soap_in_ns1__ExchangeRateType1Code(struct soap *soap, const char *tag, enum ns1__ExchangeRateType1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ExchangeRateType1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExchangeRateType1Code, sizeof(enum ns1__ExchangeRateType1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ExchangeRateType1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ExchangeRateType1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExchangeRateType1Code, SOAP_TYPE_ns1__ExchangeRateType1Code, sizeof(enum ns1__ExchangeRateType1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ExchangeRateType1Code * SOAP_FMAC4 soap_new_ns1__ExchangeRateType1Code(struct soap *soap, int n)
{
	enum ns1__ExchangeRateType1Code *a = static_cast<enum ns1__ExchangeRateType1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ExchangeRateType1Code)));
	for (enum ns1__ExchangeRateType1Code *p = a; p && n--; ++p)
		soap_default_ns1__ExchangeRateType1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExchangeRateType1Code(struct soap *soap, const enum ns1__ExchangeRateType1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExchangeRateType1Code(soap, tag ? tag : "ns1:ExchangeRateType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ExchangeRateType1Code * SOAP_FMAC4 soap_get_ns1__ExchangeRateType1Code(struct soap *soap, enum ns1__ExchangeRateType1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExchangeRateType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DocumentType6Code[] =
{	{ (LONG64)ns1__DocumentType6Code__MSIN, "MSIN" },
	{ (LONG64)ns1__DocumentType6Code__CNFA, "CNFA" },
	{ (LONG64)ns1__DocumentType6Code__DNFA, "DNFA" },
	{ (LONG64)ns1__DocumentType6Code__CINV, "CINV" },
	{ (LONG64)ns1__DocumentType6Code__CREN, "CREN" },
	{ (LONG64)ns1__DocumentType6Code__DEBN, "DEBN" },
	{ (LONG64)ns1__DocumentType6Code__HIRI, "HIRI" },
	{ (LONG64)ns1__DocumentType6Code__SBIN, "SBIN" },
	{ (LONG64)ns1__DocumentType6Code__CMCN, "CMCN" },
	{ (LONG64)ns1__DocumentType6Code__SOAC, "SOAC" },
	{ (LONG64)ns1__DocumentType6Code__DISP, "DISP" },
	{ (LONG64)ns1__DocumentType6Code__BOLD, "BOLD" },
	{ (LONG64)ns1__DocumentType6Code__VCHR, "VCHR" },
	{ (LONG64)ns1__DocumentType6Code__AROI, "AROI" },
	{ (LONG64)ns1__DocumentType6Code__TSUT, "TSUT" },
	{ (LONG64)ns1__DocumentType6Code__PUOR, "PUOR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DocumentType6Code2s(struct soap *soap, enum ns1__DocumentType6Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__DocumentType6Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentType6Code(struct soap *soap, const char *tag, int id, const enum ns1__DocumentType6Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentType6Code), type) || soap_send(soap, soap_ns1__DocumentType6Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DocumentType6Code(struct soap *soap, const char *s, enum ns1__DocumentType6Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DocumentType6Code, s);
	if (map)
		*a = (enum ns1__DocumentType6Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 15)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DocumentType6Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DocumentType6Code * SOAP_FMAC4 soap_in_ns1__DocumentType6Code(struct soap *soap, const char *tag, enum ns1__DocumentType6Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DocumentType6Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentType6Code, sizeof(enum ns1__DocumentType6Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DocumentType6Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DocumentType6Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentType6Code, SOAP_TYPE_ns1__DocumentType6Code, sizeof(enum ns1__DocumentType6Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DocumentType6Code * SOAP_FMAC4 soap_new_ns1__DocumentType6Code(struct soap *soap, int n)
{
	enum ns1__DocumentType6Code *a = static_cast<enum ns1__DocumentType6Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DocumentType6Code)));
	for (enum ns1__DocumentType6Code *p = a; p && n--; ++p)
		soap_default_ns1__DocumentType6Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DocumentType6Code(struct soap *soap, const enum ns1__DocumentType6Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DocumentType6Code(soap, tag ? tag : "ns1:DocumentType6Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DocumentType6Code * SOAP_FMAC4 soap_get_ns1__DocumentType6Code(struct soap *soap, enum ns1__DocumentType6Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentType6Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DocumentType3Code[] =
{	{ (LONG64)ns1__DocumentType3Code__RADM, "RADM" },
	{ (LONG64)ns1__DocumentType3Code__RPIN, "RPIN" },
	{ (LONG64)ns1__DocumentType3Code__FXDR, "FXDR" },
	{ (LONG64)ns1__DocumentType3Code__DISP, "DISP" },
	{ (LONG64)ns1__DocumentType3Code__PUOR, "PUOR" },
	{ (LONG64)ns1__DocumentType3Code__SCOR, "SCOR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DocumentType3Code2s(struct soap *soap, enum ns1__DocumentType3Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__DocumentType3Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentType3Code(struct soap *soap, const char *tag, int id, const enum ns1__DocumentType3Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentType3Code), type) || soap_send(soap, soap_ns1__DocumentType3Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DocumentType3Code(struct soap *soap, const char *s, enum ns1__DocumentType3Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DocumentType3Code, s);
	if (map)
		*a = (enum ns1__DocumentType3Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DocumentType3Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DocumentType3Code * SOAP_FMAC4 soap_in_ns1__DocumentType3Code(struct soap *soap, const char *tag, enum ns1__DocumentType3Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DocumentType3Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentType3Code, sizeof(enum ns1__DocumentType3Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DocumentType3Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DocumentType3Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentType3Code, SOAP_TYPE_ns1__DocumentType3Code, sizeof(enum ns1__DocumentType3Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DocumentType3Code * SOAP_FMAC4 soap_new_ns1__DocumentType3Code(struct soap *soap, int n)
{
	enum ns1__DocumentType3Code *a = static_cast<enum ns1__DocumentType3Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DocumentType3Code)));
	for (enum ns1__DocumentType3Code *p = a; p && n--; ++p)
		soap_default_ns1__DocumentType3Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DocumentType3Code(struct soap *soap, const enum ns1__DocumentType3Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DocumentType3Code(soap, tag ? tag : "ns1:DocumentType3Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DocumentType3Code * SOAP_FMAC4 soap_get_ns1__DocumentType3Code(struct soap *soap, enum ns1__DocumentType3Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentType3Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__CreditDebitCode[] =
{	{ (LONG64)ns1__CreditDebitCode__CRDT, "CRDT" },
	{ (LONG64)ns1__CreditDebitCode__DBIT, "DBIT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__CreditDebitCode2s(struct soap *soap, enum ns1__CreditDebitCode n)
{
	const char *s = soap_code_str(soap_codes_ns1__CreditDebitCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditDebitCode(struct soap *soap, const char *tag, int id, const enum ns1__CreditDebitCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditDebitCode), type) || soap_send(soap, soap_ns1__CreditDebitCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__CreditDebitCode(struct soap *soap, const char *s, enum ns1__CreditDebitCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__CreditDebitCode, s);
	if (map)
		*a = (enum ns1__CreditDebitCode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__CreditDebitCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CreditDebitCode * SOAP_FMAC4 soap_in_ns1__CreditDebitCode(struct soap *soap, const char *tag, enum ns1__CreditDebitCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__CreditDebitCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditDebitCode, sizeof(enum ns1__CreditDebitCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__CreditDebitCode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__CreditDebitCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditDebitCode, SOAP_TYPE_ns1__CreditDebitCode, sizeof(enum ns1__CreditDebitCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__CreditDebitCode * SOAP_FMAC4 soap_new_ns1__CreditDebitCode(struct soap *soap, int n)
{
	enum ns1__CreditDebitCode *a = static_cast<enum ns1__CreditDebitCode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__CreditDebitCode)));
	for (enum ns1__CreditDebitCode *p = a; p && n--; ++p)
		soap_default_ns1__CreditDebitCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CreditDebitCode(struct soap *soap, const enum ns1__CreditDebitCode *a, const char *tag, const char *type)
{
	if (soap_out_ns1__CreditDebitCode(soap, tag ? tag : "ns1:CreditDebitCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CreditDebitCode * SOAP_FMAC4 soap_get_ns1__CreditDebitCode(struct soap *soap, enum ns1__CreditDebitCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditDebitCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ChequeType2Code[] =
{	{ (LONG64)ns1__ChequeType2Code__CCHQ, "CCHQ" },
	{ (LONG64)ns1__ChequeType2Code__CCCH, "CCCH" },
	{ (LONG64)ns1__ChequeType2Code__BCHQ, "BCHQ" },
	{ (LONG64)ns1__ChequeType2Code__DRFT, "DRFT" },
	{ (LONG64)ns1__ChequeType2Code__ELDR, "ELDR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ChequeType2Code2s(struct soap *soap, enum ns1__ChequeType2Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__ChequeType2Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChequeType2Code(struct soap *soap, const char *tag, int id, const enum ns1__ChequeType2Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChequeType2Code), type) || soap_send(soap, soap_ns1__ChequeType2Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ChequeType2Code(struct soap *soap, const char *s, enum ns1__ChequeType2Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ChequeType2Code, s);
	if (map)
		*a = (enum ns1__ChequeType2Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ChequeType2Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ChequeType2Code * SOAP_FMAC4 soap_in_ns1__ChequeType2Code(struct soap *soap, const char *tag, enum ns1__ChequeType2Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ChequeType2Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChequeType2Code, sizeof(enum ns1__ChequeType2Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ChequeType2Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ChequeType2Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChequeType2Code, SOAP_TYPE_ns1__ChequeType2Code, sizeof(enum ns1__ChequeType2Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ChequeType2Code * SOAP_FMAC4 soap_new_ns1__ChequeType2Code(struct soap *soap, int n)
{
	enum ns1__ChequeType2Code *a = static_cast<enum ns1__ChequeType2Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ChequeType2Code)));
	for (enum ns1__ChequeType2Code *p = a; p && n--; ++p)
		soap_default_ns1__ChequeType2Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChequeType2Code(struct soap *soap, const enum ns1__ChequeType2Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ChequeType2Code(soap, tag ? tag : "ns1:ChequeType2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ChequeType2Code * SOAP_FMAC4 soap_get_ns1__ChequeType2Code(struct soap *soap, enum ns1__ChequeType2Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChequeType2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ChequeDelivery1Code[] =
{	{ (LONG64)ns1__ChequeDelivery1Code__MLDB, "MLDB" },
	{ (LONG64)ns1__ChequeDelivery1Code__MLCD, "MLCD" },
	{ (LONG64)ns1__ChequeDelivery1Code__MLFA, "MLFA" },
	{ (LONG64)ns1__ChequeDelivery1Code__CRDB, "CRDB" },
	{ (LONG64)ns1__ChequeDelivery1Code__CRCD, "CRCD" },
	{ (LONG64)ns1__ChequeDelivery1Code__CRFA, "CRFA" },
	{ (LONG64)ns1__ChequeDelivery1Code__PUDB, "PUDB" },
	{ (LONG64)ns1__ChequeDelivery1Code__PUCD, "PUCD" },
	{ (LONG64)ns1__ChequeDelivery1Code__PUFA, "PUFA" },
	{ (LONG64)ns1__ChequeDelivery1Code__RGDB, "RGDB" },
	{ (LONG64)ns1__ChequeDelivery1Code__RGCD, "RGCD" },
	{ (LONG64)ns1__ChequeDelivery1Code__RGFA, "RGFA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ChequeDelivery1Code2s(struct soap *soap, enum ns1__ChequeDelivery1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__ChequeDelivery1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChequeDelivery1Code(struct soap *soap, const char *tag, int id, const enum ns1__ChequeDelivery1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChequeDelivery1Code), type) || soap_send(soap, soap_ns1__ChequeDelivery1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ChequeDelivery1Code(struct soap *soap, const char *s, enum ns1__ChequeDelivery1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ChequeDelivery1Code, s);
	if (map)
		*a = (enum ns1__ChequeDelivery1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 11)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ChequeDelivery1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ChequeDelivery1Code * SOAP_FMAC4 soap_in_ns1__ChequeDelivery1Code(struct soap *soap, const char *tag, enum ns1__ChequeDelivery1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ChequeDelivery1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChequeDelivery1Code, sizeof(enum ns1__ChequeDelivery1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ChequeDelivery1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ChequeDelivery1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChequeDelivery1Code, SOAP_TYPE_ns1__ChequeDelivery1Code, sizeof(enum ns1__ChequeDelivery1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ChequeDelivery1Code * SOAP_FMAC4 soap_new_ns1__ChequeDelivery1Code(struct soap *soap, int n)
{
	enum ns1__ChequeDelivery1Code *a = static_cast<enum ns1__ChequeDelivery1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ChequeDelivery1Code)));
	for (enum ns1__ChequeDelivery1Code *p = a; p && n--; ++p)
		soap_default_ns1__ChequeDelivery1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChequeDelivery1Code(struct soap *soap, const enum ns1__ChequeDelivery1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ChequeDelivery1Code(soap, tag ? tag : "ns1:ChequeDelivery1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ChequeDelivery1Code * SOAP_FMAC4 soap_get_ns1__ChequeDelivery1Code(struct soap *soap, enum ns1__ChequeDelivery1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChequeDelivery1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ChargeBearerType1Code[] =
{	{ (LONG64)ns1__ChargeBearerType1Code__DEBT, "DEBT" },
	{ (LONG64)ns1__ChargeBearerType1Code__CRED, "CRED" },
	{ (LONG64)ns1__ChargeBearerType1Code__SHAR, "SHAR" },
	{ (LONG64)ns1__ChargeBearerType1Code__SLEV, "SLEV" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ChargeBearerType1Code2s(struct soap *soap, enum ns1__ChargeBearerType1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__ChargeBearerType1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChargeBearerType1Code(struct soap *soap, const char *tag, int id, const enum ns1__ChargeBearerType1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChargeBearerType1Code), type) || soap_send(soap, soap_ns1__ChargeBearerType1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ChargeBearerType1Code(struct soap *soap, const char *s, enum ns1__ChargeBearerType1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ChargeBearerType1Code, s);
	if (map)
		*a = (enum ns1__ChargeBearerType1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ChargeBearerType1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ChargeBearerType1Code * SOAP_FMAC4 soap_in_ns1__ChargeBearerType1Code(struct soap *soap, const char *tag, enum ns1__ChargeBearerType1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ChargeBearerType1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChargeBearerType1Code, sizeof(enum ns1__ChargeBearerType1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ChargeBearerType1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ChargeBearerType1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChargeBearerType1Code, SOAP_TYPE_ns1__ChargeBearerType1Code, sizeof(enum ns1__ChargeBearerType1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ChargeBearerType1Code * SOAP_FMAC4 soap_new_ns1__ChargeBearerType1Code(struct soap *soap, int n)
{
	enum ns1__ChargeBearerType1Code *a = static_cast<enum ns1__ChargeBearerType1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ChargeBearerType1Code)));
	for (enum ns1__ChargeBearerType1Code *p = a; p && n--; ++p)
		soap_default_ns1__ChargeBearerType1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChargeBearerType1Code(struct soap *soap, const enum ns1__ChargeBearerType1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ChargeBearerType1Code(soap, tag ? tag : "ns1:ChargeBearerType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ChargeBearerType1Code * SOAP_FMAC4 soap_get_ns1__ChargeBearerType1Code(struct soap *soap, enum ns1__ChargeBearerType1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChargeBearerType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BatchBookingIndicator(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BatchBookingIndicator), type) || soap_send(soap, soap_ns1__BatchBookingIndicator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_ns1__BatchBookingIndicator(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BatchBookingIndicator, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__BatchBookingIndicator(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BatchBookingIndicator, SOAP_TYPE_ns1__BatchBookingIndicator, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BatchBookingIndicator(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_ns1__BatchBookingIndicator(soap, tag ? tag : "ns1:BatchBookingIndicator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_ns1__BatchBookingIndicator(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BatchBookingIndicator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Authorisation1Code[] =
{	{ (LONG64)ns1__Authorisation1Code__AUTH, "AUTH" },
	{ (LONG64)ns1__Authorisation1Code__FDET, "FDET" },
	{ (LONG64)ns1__Authorisation1Code__FSUM, "FSUM" },
	{ (LONG64)ns1__Authorisation1Code__ILEV, "ILEV" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Authorisation1Code2s(struct soap *soap, enum ns1__Authorisation1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__Authorisation1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Authorisation1Code(struct soap *soap, const char *tag, int id, const enum ns1__Authorisation1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Authorisation1Code), type) || soap_send(soap, soap_ns1__Authorisation1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Authorisation1Code(struct soap *soap, const char *s, enum ns1__Authorisation1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Authorisation1Code, s);
	if (map)
		*a = (enum ns1__Authorisation1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Authorisation1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Authorisation1Code * SOAP_FMAC4 soap_in_ns1__Authorisation1Code(struct soap *soap, const char *tag, enum ns1__Authorisation1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Authorisation1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Authorisation1Code, sizeof(enum ns1__Authorisation1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Authorisation1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Authorisation1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Authorisation1Code, SOAP_TYPE_ns1__Authorisation1Code, sizeof(enum ns1__Authorisation1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Authorisation1Code * SOAP_FMAC4 soap_new_ns1__Authorisation1Code(struct soap *soap, int n)
{
	enum ns1__Authorisation1Code *a = static_cast<enum ns1__Authorisation1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Authorisation1Code)));
	for (enum ns1__Authorisation1Code *p = a; p && n--; ++p)
		soap_default_ns1__Authorisation1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Authorisation1Code(struct soap *soap, const enum ns1__Authorisation1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Authorisation1Code(soap, tag ? tag : "ns1:Authorisation1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Authorisation1Code * SOAP_FMAC4 soap_get_ns1__Authorisation1Code(struct soap *soap, enum ns1__Authorisation1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Authorisation1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__AdviceType1Code[] =
{	{ (LONG64)ns1__AdviceType1Code__ADWD, "ADWD" },
	{ (LONG64)ns1__AdviceType1Code__ADND, "ADND" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AdviceType1Code2s(struct soap *soap, enum ns1__AdviceType1Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__AdviceType1Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AdviceType1Code(struct soap *soap, const char *tag, int id, const enum ns1__AdviceType1Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AdviceType1Code), type) || soap_send(soap, soap_ns1__AdviceType1Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AdviceType1Code(struct soap *soap, const char *s, enum ns1__AdviceType1Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AdviceType1Code, s);
	if (map)
		*a = (enum ns1__AdviceType1Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AdviceType1Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AdviceType1Code * SOAP_FMAC4 soap_in_ns1__AdviceType1Code(struct soap *soap, const char *tag, enum ns1__AdviceType1Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AdviceType1Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AdviceType1Code, sizeof(enum ns1__AdviceType1Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__AdviceType1Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__AdviceType1Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AdviceType1Code, SOAP_TYPE_ns1__AdviceType1Code, sizeof(enum ns1__AdviceType1Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__AdviceType1Code * SOAP_FMAC4 soap_new_ns1__AdviceType1Code(struct soap *soap, int n)
{
	enum ns1__AdviceType1Code *a = static_cast<enum ns1__AdviceType1Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__AdviceType1Code)));
	for (enum ns1__AdviceType1Code *p = a; p && n--; ++p)
		soap_default_ns1__AdviceType1Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AdviceType1Code(struct soap *soap, const enum ns1__AdviceType1Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AdviceType1Code(soap, tag ? tag : "ns1:AdviceType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AdviceType1Code * SOAP_FMAC4 soap_get_ns1__AdviceType1Code(struct soap *soap, enum ns1__AdviceType1Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AdviceType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__AddressType2Code[] =
{	{ (LONG64)ns1__AddressType2Code__ADDR, "ADDR" },
	{ (LONG64)ns1__AddressType2Code__PBOX, "PBOX" },
	{ (LONG64)ns1__AddressType2Code__HOME, "HOME" },
	{ (LONG64)ns1__AddressType2Code__BIZZ, "BIZZ" },
	{ (LONG64)ns1__AddressType2Code__MLTO, "MLTO" },
	{ (LONG64)ns1__AddressType2Code__DLVY, "DLVY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AddressType2Code2s(struct soap *soap, enum ns1__AddressType2Code n)
{
	const char *s = soap_code_str(soap_codes_ns1__AddressType2Code, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddressType2Code(struct soap *soap, const char *tag, int id, const enum ns1__AddressType2Code *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddressType2Code), type) || soap_send(soap, soap_ns1__AddressType2Code2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AddressType2Code(struct soap *soap, const char *s, enum ns1__AddressType2Code *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AddressType2Code, s);
	if (map)
		*a = (enum ns1__AddressType2Code)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AddressType2Code)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AddressType2Code * SOAP_FMAC4 soap_in_ns1__AddressType2Code(struct soap *soap, const char *tag, enum ns1__AddressType2Code *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AddressType2Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressType2Code, sizeof(enum ns1__AddressType2Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__AddressType2Code(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__AddressType2Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddressType2Code, SOAP_TYPE_ns1__AddressType2Code, sizeof(enum ns1__AddressType2Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__AddressType2Code * SOAP_FMAC4 soap_new_ns1__AddressType2Code(struct soap *soap, int n)
{
	enum ns1__AddressType2Code *a = static_cast<enum ns1__AddressType2Code *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__AddressType2Code)));
	for (enum ns1__AddressType2Code *p = a; p && n--; ++p)
		soap_default_ns1__AddressType2Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AddressType2Code(struct soap *soap, const enum ns1__AddressType2Code *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AddressType2Code(soap, tag ? tag : "ns1:AddressType2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AddressType2Code * SOAP_FMAC4 soap_get_ns1__AddressType2Code(struct soap *soap, enum ns1__AddressType2Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddressType2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UUIDv4Identifier(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UUIDv4Identifier(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__UUIDv4Identifier), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__UUIDv4Identifier(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUIDv4Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUIDv4Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__UUIDv4Identifier, SOAP_TYPE_ns1__UUIDv4Identifier, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UUIDv4Identifier(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UUIDv4Identifier(soap, tag ? tag : "ns1:UUIDv4Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__UUIDv4Identifier(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UUIDv4Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PhoneNumber(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneNumber(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__PhoneNumber), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__PhoneNumber(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__PhoneNumber, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "\\+[0-9]{1,3}-[0-9()+\\-]{1,30}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__PhoneNumber, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__PhoneNumber, SOAP_TYPE_ns1__PhoneNumber, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PhoneNumber(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__PhoneNumber(soap, tag ? tag : "ns1:PhoneNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__PhoneNumber(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max70Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max70Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max70Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max70Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max70Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 70, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max70Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max70Text, SOAP_TYPE_ns1__Max70Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max70Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max70Text(soap, tag ? tag : "ns1:Max70Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max70Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max70Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max4Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max4Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max4Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max4Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max4Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max4Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max4Text, SOAP_TYPE_ns1__Max4Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max4Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max4Text(soap, tag ? tag : "ns1:Max4Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max4Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max4Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max35Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max35Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max35Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max35Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max35Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 35, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max35Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max35Text, SOAP_TYPE_ns1__Max35Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max35Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max35Text(soap, tag ? tag : "ns1:Max35Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max35Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max35Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max350Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max350Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max350Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max350Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max350Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 350, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max350Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max350Text, SOAP_TYPE_ns1__Max350Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max350Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max350Text(soap, tag ? tag : "ns1:Max350Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max350Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max350Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max34Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max34Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max34Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max34Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max34Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 34, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max34Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max34Text, SOAP_TYPE_ns1__Max34Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max34Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max34Text(soap, tag ? tag : "ns1:Max34Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max34Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max34Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max2048Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max2048Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max2048Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max2048Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max2048Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 2048, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max2048Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max2048Text, SOAP_TYPE_ns1__Max2048Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max2048Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max2048Text(soap, tag ? tag : "ns1:Max2048Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max2048Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max2048Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max16Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max16Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max16Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max16Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max16Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 16, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max16Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max16Text, SOAP_TYPE_ns1__Max16Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max16Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max16Text(soap, tag ? tag : "ns1:Max16Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max16Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max16Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max15NumericText(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max15NumericText(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max15NumericText), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max15NumericText(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max15NumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[0-9]{1,15}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max15NumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max15NumericText, SOAP_TYPE_ns1__Max15NumericText, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max15NumericText(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max15NumericText(soap, tag ? tag : "ns1:Max15NumericText", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max15NumericText(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max15NumericText(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max140Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max140Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max140Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max140Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max140Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 140, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max140Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max140Text, SOAP_TYPE_ns1__Max140Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max140Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max140Text(soap, tag ? tag : "ns1:Max140Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max140Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max140Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max128Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max128Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max128Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max128Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max128Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 128, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max128Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max128Text, SOAP_TYPE_ns1__Max128Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max128Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max128Text(soap, tag ? tag : "ns1:Max128Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max128Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max128Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max10Text(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max10Text(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Max10Text), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Max10Text(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max10Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 10, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Max10Text, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Max10Text, SOAP_TYPE_ns1__Max10Text, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max10Text(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max10Text(soap, tag ? tag : "ns1:Max10Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Max10Text(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max10Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Max10KBinary(struct soap *soap, xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Max10KBinary(struct soap *soap, const xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_ns1__Max10KBinary, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Max10KBinary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Max10KBinary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_ns1__Max10KBinary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ns1__Max10KBinary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Max10KBinary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 1)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 10240)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_ns1__Max10KBinary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Max10KBinary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 1)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 10240)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Max10KBinary, SOAP_TYPE_ns1__Max10KBinary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Max10KBinary(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Max10KBinary(soap, tag ? tag : "ns1:Max10KBinary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns1__Max10KBinary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Max10KBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__LEIIdentifier(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LEIIdentifier(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__LEIIdentifier), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__LEIIdentifier(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__LEIIdentifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z0-9]{18,18}[0-9]{2,2}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__LEIIdentifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__LEIIdentifier, SOAP_TYPE_ns1__LEIIdentifier, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LEIIdentifier(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__LEIIdentifier(soap, tag ? tag : "ns1:LEIIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__LEIIdentifier(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LEIIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__IBAN2007Identifier(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IBAN2007Identifier(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__IBAN2007Identifier), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__IBAN2007Identifier(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__IBAN2007Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__IBAN2007Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__IBAN2007Identifier, SOAP_TYPE_ns1__IBAN2007Identifier, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__IBAN2007Identifier(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__IBAN2007Identifier(soap, tag ? tag : "ns1:IBAN2007Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__IBAN2007Identifier(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IBAN2007Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalTaxAmountType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalTaxAmountType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalTaxAmountType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalTaxAmountType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalTaxAmountType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalTaxAmountType1Code(soap, tag ? tag : "ns1:ExternalTaxAmountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalTaxAmountType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalTaxAmountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalServiceLevel1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalServiceLevel1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalServiceLevel1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalServiceLevel1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalServiceLevel1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalServiceLevel1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalServiceLevel1Code, SOAP_TYPE_ns1__ExternalServiceLevel1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalServiceLevel1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalServiceLevel1Code(soap, tag ? tag : "ns1:ExternalServiceLevel1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalServiceLevel1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalServiceLevel1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalPurpose1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalPurpose1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalPurpose1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalPurpose1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalPurpose1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalPurpose1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalPurpose1Code, SOAP_TYPE_ns1__ExternalPurpose1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalPurpose1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalPurpose1Code(soap, tag ? tag : "ns1:ExternalPurpose1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalPurpose1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalPurpose1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalProxyAccountType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalProxyAccountType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalProxyAccountType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalProxyAccountType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalProxyAccountType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalProxyAccountType1Code(soap, tag ? tag : "ns1:ExternalProxyAccountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalProxyAccountType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalProxyAccountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalPersonIdentification1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalPersonIdentification1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalPersonIdentification1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalPersonIdentification1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalPersonIdentification1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalPersonIdentification1Code(soap, tag ? tag : "ns1:ExternalPersonIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalPersonIdentification1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalPersonIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalOrganisationIdentification1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalOrganisationIdentification1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalOrganisationIdentification1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalOrganisationIdentification1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalOrganisationIdentification1Code(soap, tag ? tag : "ns1:ExternalOrganisationIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalOrganisationIdentification1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalOrganisationIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalMandateSetupReason1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalMandateSetupReason1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalMandateSetupReason1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalMandateSetupReason1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalMandateSetupReason1Code(soap, tag ? tag : "ns1:ExternalMandateSetupReason1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalMandateSetupReason1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalMandateSetupReason1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalLocalInstrument1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalLocalInstrument1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalLocalInstrument1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalLocalInstrument1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 35, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalLocalInstrument1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalLocalInstrument1Code(soap, tag ? tag : "ns1:ExternalLocalInstrument1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalLocalInstrument1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalLocalInstrument1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalGarnishmentType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalGarnishmentType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalGarnishmentType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalGarnishmentType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalGarnishmentType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalGarnishmentType1Code(soap, tag ? tag : "ns1:ExternalGarnishmentType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalGarnishmentType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalGarnishmentType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag ? tag : "ns1:ExternalFinancialInstitutionIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalDocumentLineType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalDocumentLineType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalDocumentLineType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalDocumentLineType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalDocumentLineType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalDocumentLineType1Code(soap, tag ? tag : "ns1:ExternalDocumentLineType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalDocumentLineType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalDocumentLineType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalDiscountAmountType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalDiscountAmountType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalDiscountAmountType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalDiscountAmountType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalDiscountAmountType1Code(soap, tag ? tag : "ns1:ExternalDiscountAmountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalDiscountAmountType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalDiscountAmountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalDebtorAgentInstruction1Code(soap, tag ? tag : "ns1:ExternalDebtorAgentInstruction1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalDebtorAgentInstruction1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalCreditorAgentInstruction1Code(soap, tag ? tag : "ns1:ExternalCreditorAgentInstruction1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalCreditorAgentInstruction1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalClearingSystemIdentification1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalClearingSystemIdentification1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalClearingSystemIdentification1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 5, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalClearingSystemIdentification1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalClearingSystemIdentification1Code(soap, tag ? tag : "ns1:ExternalClearingSystemIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalClearingSystemIdentification1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalClearingSystemIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalCategoryPurpose1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalCategoryPurpose1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalCategoryPurpose1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalCategoryPurpose1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalCategoryPurpose1Code(soap, tag ? tag : "ns1:ExternalCategoryPurpose1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalCategoryPurpose1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalCategoryPurpose1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalCashAccountType1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalCashAccountType1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalCashAccountType1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalCashAccountType1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCashAccountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalCashAccountType1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalCashAccountType1Code, SOAP_TYPE_ns1__ExternalCashAccountType1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalCashAccountType1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalCashAccountType1Code(soap, tag ? tag : "ns1:ExternalCashAccountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalCashAccountType1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalCashAccountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExternalAccountIdentification1Code(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExternalAccountIdentification1Code(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ExternalAccountIdentification1Code), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ExternalAccountIdentification1Code(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExternalAccountIdentification1Code(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExternalAccountIdentification1Code(soap, tag ? tag : "ns1:ExternalAccountIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ExternalAccountIdentification1Code(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExternalAccountIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Exact4AlphaNumericText(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Exact4AlphaNumericText(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Exact4AlphaNumericText), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Exact4AlphaNumericText(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Exact4AlphaNumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[a-zA-Z0-9]{4}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Exact4AlphaNumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Exact4AlphaNumericText, SOAP_TYPE_ns1__Exact4AlphaNumericText, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Exact4AlphaNumericText(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Exact4AlphaNumericText(soap, tag ? tag : "ns1:Exact4AlphaNumericText", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Exact4AlphaNumericText(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Exact4AlphaNumericText(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Exact2NumericText(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Exact2NumericText(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Exact2NumericText), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Exact2NumericText(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Exact2NumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[0-9]{2}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Exact2NumericText, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Exact2NumericText, SOAP_TYPE_ns1__Exact2NumericText, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Exact2NumericText(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Exact2NumericText(soap, tag ? tag : "ns1:Exact2NumericText", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Exact2NumericText(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Exact2NumericText(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CountryCode(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryCode(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__CountryCode), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__CountryCode(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__CountryCode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z]{2,2}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__CountryCode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__CountryCode, SOAP_TYPE_ns1__CountryCode, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CountryCode(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__CountryCode(soap, tag ? tag : "ns1:CountryCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__CountryCode(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BICFIDec2014Identifier(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BICFIDec2014Identifier(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__BICFIDec2014Identifier), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__BICFIDec2014Identifier(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__BICFIDec2014Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__BICFIDec2014Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__BICFIDec2014Identifier, SOAP_TYPE_ns1__BICFIDec2014Identifier, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BICFIDec2014Identifier(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__BICFIDec2014Identifier(soap, tag ? tag : "ns1:BICFIDec2014Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__BICFIDec2014Identifier(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BICFIDec2014Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AnyBICDec2014Identifier(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AnyBICDec2014Identifier(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__AnyBICDec2014Identifier), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__AnyBICDec2014Identifier(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__AnyBICDec2014Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__AnyBICDec2014Identifier, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__AnyBICDec2014Identifier, SOAP_TYPE_ns1__AnyBICDec2014Identifier, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AnyBICDec2014Identifier(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AnyBICDec2014Identifier(soap, tag ? tag : "ns1:AnyBICDec2014Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__AnyBICDec2014Identifier(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AnyBICDec2014Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ActiveOrHistoricCurrencyCode(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActiveOrHistoricCurrencyCode(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ActiveOrHistoricCurrencyCode(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[A-Z]{3,3}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ActiveOrHistoricCurrencyCode(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ActiveOrHistoricCurrencyCode(soap, tag ? tag : "ns1:ActiveOrHistoricCurrencyCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ActiveOrHistoricCurrencyCode(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActiveOrHistoricCurrencyCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxRecordDetails3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxRecordDetails3::Prd = NULL;
	this->ns1__TaxRecordDetails3::Amt = NULL;
}

void ns1__TaxRecordDetails3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TaxPeriod3(soap, &this->ns1__TaxRecordDetails3::Prd);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxRecordDetails3::Amt);
#endif
}

int ns1__TaxRecordDetails3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxRecordDetails3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxRecordDetails3(struct soap *soap, const char *tag, int id, const ns1__TaxRecordDetails3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxRecordDetails3), type))
		return soap->error;
	if (soap_out_PointerTons1__TaxPeriod3(soap, "Prd", -1, &a->ns1__TaxRecordDetails3::Prd, ""))
		return soap->error;
	if (!a->ns1__TaxRecordDetails3::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__TaxRecordDetails3::Amt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxRecordDetails3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxRecordDetails3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxRecordDetails3 * SOAP_FMAC4 soap_in_ns1__TaxRecordDetails3(struct soap *soap, const char *tag, ns1__TaxRecordDetails3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxRecordDetails3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxRecordDetails3, sizeof(ns1__TaxRecordDetails3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxRecordDetails3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxRecordDetails3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Prd1 = 1;
	size_t soap_flag_Amt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Prd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxPeriod3(soap, "Prd", &a->ns1__TaxRecordDetails3::Prd, "ns1:TaxPeriod3"))
				{	soap_flag_Prd1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__TaxRecordDetails3::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__TaxRecordDetails3::Amt))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TaxRecordDetails3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxRecordDetails3, SOAP_TYPE_ns1__TaxRecordDetails3, sizeof(ns1__TaxRecordDetails3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxRecordDetails3 * SOAP_FMAC2 soap_instantiate_ns1__TaxRecordDetails3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxRecordDetails3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxRecordDetails3 *p;
	size_t k = sizeof(ns1__TaxRecordDetails3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxRecordDetails3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxRecordDetails3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxRecordDetails3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxRecordDetails3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxRecordDetails3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxRecordDetails3(soap, tag ? tag : "ns1:TaxRecordDetails3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxRecordDetails3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxRecordDetails3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxRecordDetails3 * SOAP_FMAC4 soap_get_ns1__TaxRecordDetails3(struct soap *soap, ns1__TaxRecordDetails3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxRecordDetails3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxRecord3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxRecord3::Tp = NULL;
	this->ns1__TaxRecord3::Ctgy = NULL;
	this->ns1__TaxRecord3::CtgyDtls = NULL;
	this->ns1__TaxRecord3::DbtrSts = NULL;
	this->ns1__TaxRecord3::CertId = NULL;
	this->ns1__TaxRecord3::FrmsCd = NULL;
	this->ns1__TaxRecord3::Prd = NULL;
	this->ns1__TaxRecord3::TaxAmt = NULL;
	this->ns1__TaxRecord3::AddtlInf = NULL;
}

void ns1__TaxRecord3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::Tp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::Ctgy);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::CtgyDtls);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::DbtrSts);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::CertId);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxRecord3::FrmsCd);
	soap_serialize_PointerTons1__TaxPeriod3(soap, &this->ns1__TaxRecord3::Prd);
	soap_serialize_PointerTons1__TaxAmount3(soap, &this->ns1__TaxRecord3::TaxAmt);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__TaxRecord3::AddtlInf);
#endif
}

int ns1__TaxRecord3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxRecord3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxRecord3(struct soap *soap, const char *tag, int id, const ns1__TaxRecord3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxRecord3), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Tp", -1, &a->ns1__TaxRecord3::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Ctgy", -1, &a->ns1__TaxRecord3::Ctgy, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "CtgyDtls", -1, &a->ns1__TaxRecord3::CtgyDtls, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "DbtrSts", -1, &a->ns1__TaxRecord3::DbtrSts, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "CertId", -1, &a->ns1__TaxRecord3::CertId, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "FrmsCd", -1, &a->ns1__TaxRecord3::FrmsCd, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxPeriod3(soap, "Prd", -1, &a->ns1__TaxRecord3::Prd, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxAmount3(soap, "TaxAmt", -1, &a->ns1__TaxRecord3::TaxAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "AddtlInf", -1, &a->ns1__TaxRecord3::AddtlInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxRecord3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxRecord3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxRecord3 * SOAP_FMAC4 soap_in_ns1__TaxRecord3(struct soap *soap, const char *tag, ns1__TaxRecord3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxRecord3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxRecord3, sizeof(ns1__TaxRecord3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxRecord3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxRecord3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Ctgy1 = 1;
	size_t soap_flag_CtgyDtls1 = 1;
	size_t soap_flag_DbtrSts1 = 1;
	size_t soap_flag_CertId1 = 1;
	size_t soap_flag_FrmsCd1 = 1;
	size_t soap_flag_Prd1 = 1;
	size_t soap_flag_TaxAmt1 = 1;
	size_t soap_flag_AddtlInf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Tp", &a->ns1__TaxRecord3::Tp, "ns1:Max35Text"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Ctgy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Ctgy", &a->ns1__TaxRecord3::Ctgy, "ns1:Max35Text"))
				{	soap_flag_Ctgy1--;
					continue;
				}
			}
			if (soap_flag_CtgyDtls1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "CtgyDtls", &a->ns1__TaxRecord3::CtgyDtls, "ns1:Max35Text"))
				{	soap_flag_CtgyDtls1--;
					continue;
				}
			}
			if (soap_flag_DbtrSts1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "DbtrSts", &a->ns1__TaxRecord3::DbtrSts, "ns1:Max35Text"))
				{	soap_flag_DbtrSts1--;
					continue;
				}
			}
			if (soap_flag_CertId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "CertId", &a->ns1__TaxRecord3::CertId, "ns1:Max35Text"))
				{	soap_flag_CertId1--;
					continue;
				}
			}
			if (soap_flag_FrmsCd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "FrmsCd", &a->ns1__TaxRecord3::FrmsCd, "ns1:Max35Text"))
				{	soap_flag_FrmsCd1--;
					continue;
				}
			}
			if (soap_flag_Prd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxPeriod3(soap, "Prd", &a->ns1__TaxRecord3::Prd, "ns1:TaxPeriod3"))
				{	soap_flag_Prd1--;
					continue;
				}
			}
			if (soap_flag_TaxAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxAmount3(soap, "TaxAmt", &a->ns1__TaxRecord3::TaxAmt, "ns1:TaxAmount3"))
				{	soap_flag_TaxAmt1--;
					continue;
				}
			}
			if (soap_flag_AddtlInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "AddtlInf", &a->ns1__TaxRecord3::AddtlInf, "ns1:Max140Text"))
				{	soap_flag_AddtlInf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxRecord3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxRecord3, SOAP_TYPE_ns1__TaxRecord3, sizeof(ns1__TaxRecord3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxRecord3 * SOAP_FMAC2 soap_instantiate_ns1__TaxRecord3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxRecord3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxRecord3 *p;
	size_t k = sizeof(ns1__TaxRecord3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxRecord3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxRecord3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxRecord3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxRecord3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxRecord3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxRecord3(soap, tag ? tag : "ns1:TaxRecord3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxRecord3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxRecord3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxRecord3 * SOAP_FMAC4 soap_get_ns1__TaxRecord3(struct soap *soap, ns1__TaxRecord3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxRecord3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxPeriod3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxPeriod3::Yr = NULL;
	this->ns1__TaxPeriod3::Tp = NULL;
	this->ns1__TaxPeriod3::FrToDt = NULL;
}

void ns1__TaxPeriod3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ISOYear(soap, &this->ns1__TaxPeriod3::Yr);
	soap_serialize_PointerTons1__TaxRecordPeriod1Code(soap, &this->ns1__TaxPeriod3::Tp);
	soap_serialize_PointerTons1__DatePeriod2(soap, &this->ns1__TaxPeriod3::FrToDt);
#endif
}

int ns1__TaxPeriod3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxPeriod3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxPeriod3(struct soap *soap, const char *tag, int id, const ns1__TaxPeriod3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxPeriod3), type))
		return soap->error;
	if (soap_out_PointerTons1__ISOYear(soap, "Yr", -1, &a->ns1__TaxPeriod3::Yr, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxRecordPeriod1Code(soap, "Tp", -1, &a->ns1__TaxPeriod3::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__DatePeriod2(soap, "FrToDt", -1, &a->ns1__TaxPeriod3::FrToDt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxPeriod3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxPeriod3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxPeriod3 * SOAP_FMAC4 soap_in_ns1__TaxPeriod3(struct soap *soap, const char *tag, ns1__TaxPeriod3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxPeriod3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxPeriod3, sizeof(ns1__TaxPeriod3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxPeriod3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxPeriod3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Yr1 = 1;
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_FrToDt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Yr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISOYear(soap, "Yr", &a->ns1__TaxPeriod3::Yr, "ns1:ISOYear"))
				{	soap_flag_Yr1--;
					continue;
				}
			}
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxRecordPeriod1Code(soap, "Tp", &a->ns1__TaxPeriod3::Tp, "ns1:TaxRecordPeriod1Code"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_FrToDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DatePeriod2(soap, "FrToDt", &a->ns1__TaxPeriod3::FrToDt, "ns1:DatePeriod2"))
				{	soap_flag_FrToDt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxPeriod3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxPeriod3, SOAP_TYPE_ns1__TaxPeriod3, sizeof(ns1__TaxPeriod3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxPeriod3 * SOAP_FMAC2 soap_instantiate_ns1__TaxPeriod3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxPeriod3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxPeriod3 *p;
	size_t k = sizeof(ns1__TaxPeriod3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxPeriod3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxPeriod3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxPeriod3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxPeriod3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxPeriod3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxPeriod3(soap, tag ? tag : "ns1:TaxPeriod3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxPeriod3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxPeriod3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxPeriod3 * SOAP_FMAC4 soap_get_ns1__TaxPeriod3(struct soap *soap, ns1__TaxPeriod3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxPeriod3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxParty2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxParty2::TaxId = NULL;
	this->ns1__TaxParty2::RegnId = NULL;
	this->ns1__TaxParty2::TaxTp = NULL;
	this->ns1__TaxParty2::Authstn = NULL;
}

void ns1__TaxParty2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty2::TaxId);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty2::RegnId);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty2::TaxTp);
	soap_serialize_PointerTons1__TaxAuthorisation1(soap, &this->ns1__TaxParty2::Authstn);
#endif
}

int ns1__TaxParty2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxParty2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxParty2(struct soap *soap, const char *tag, int id, const ns1__TaxParty2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxParty2), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TaxId", -1, &a->ns1__TaxParty2::TaxId, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "RegnId", -1, &a->ns1__TaxParty2::RegnId, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TaxTp", -1, &a->ns1__TaxParty2::TaxTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxAuthorisation1(soap, "Authstn", -1, &a->ns1__TaxParty2::Authstn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxParty2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxParty2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxParty2 * SOAP_FMAC4 soap_in_ns1__TaxParty2(struct soap *soap, const char *tag, ns1__TaxParty2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxParty2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxParty2, sizeof(ns1__TaxParty2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxParty2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxParty2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TaxId1 = 1;
	size_t soap_flag_RegnId1 = 1;
	size_t soap_flag_TaxTp1 = 1;
	size_t soap_flag_Authstn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaxId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TaxId", &a->ns1__TaxParty2::TaxId, "ns1:Max35Text"))
				{	soap_flag_TaxId1--;
					continue;
				}
			}
			if (soap_flag_RegnId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "RegnId", &a->ns1__TaxParty2::RegnId, "ns1:Max35Text"))
				{	soap_flag_RegnId1--;
					continue;
				}
			}
			if (soap_flag_TaxTp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TaxTp", &a->ns1__TaxParty2::TaxTp, "ns1:Max35Text"))
				{	soap_flag_TaxTp1--;
					continue;
				}
			}
			if (soap_flag_Authstn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxAuthorisation1(soap, "Authstn", &a->ns1__TaxParty2::Authstn, "ns1:TaxAuthorisation1"))
				{	soap_flag_Authstn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxParty2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxParty2, SOAP_TYPE_ns1__TaxParty2, sizeof(ns1__TaxParty2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxParty2 * SOAP_FMAC2 soap_instantiate_ns1__TaxParty2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxParty2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxParty2 *p;
	size_t k = sizeof(ns1__TaxParty2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxParty2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxParty2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxParty2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxParty2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxParty2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxParty2(soap, tag ? tag : "ns1:TaxParty2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxParty2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxParty2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxParty2 * SOAP_FMAC4 soap_get_ns1__TaxParty2(struct soap *soap, ns1__TaxParty2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxParty2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxParty1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxParty1::TaxId = NULL;
	this->ns1__TaxParty1::RegnId = NULL;
	this->ns1__TaxParty1::TaxTp = NULL;
}

void ns1__TaxParty1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty1::TaxId);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty1::RegnId);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxParty1::TaxTp);
#endif
}

int ns1__TaxParty1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxParty1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxParty1(struct soap *soap, const char *tag, int id, const ns1__TaxParty1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxParty1), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TaxId", -1, &a->ns1__TaxParty1::TaxId, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "RegnId", -1, &a->ns1__TaxParty1::RegnId, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TaxTp", -1, &a->ns1__TaxParty1::TaxTp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxParty1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxParty1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxParty1 * SOAP_FMAC4 soap_in_ns1__TaxParty1(struct soap *soap, const char *tag, ns1__TaxParty1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxParty1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxParty1, sizeof(ns1__TaxParty1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxParty1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxParty1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TaxId1 = 1;
	size_t soap_flag_RegnId1 = 1;
	size_t soap_flag_TaxTp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaxId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TaxId", &a->ns1__TaxParty1::TaxId, "ns1:Max35Text"))
				{	soap_flag_TaxId1--;
					continue;
				}
			}
			if (soap_flag_RegnId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "RegnId", &a->ns1__TaxParty1::RegnId, "ns1:Max35Text"))
				{	soap_flag_RegnId1--;
					continue;
				}
			}
			if (soap_flag_TaxTp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TaxTp", &a->ns1__TaxParty1::TaxTp, "ns1:Max35Text"))
				{	soap_flag_TaxTp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxParty1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxParty1, SOAP_TYPE_ns1__TaxParty1, sizeof(ns1__TaxParty1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxParty1 * SOAP_FMAC2 soap_instantiate_ns1__TaxParty1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxParty1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxParty1 *p;
	size_t k = sizeof(ns1__TaxParty1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxParty1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxParty1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxParty1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxParty1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxParty1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxParty1(soap, tag ? tag : "ns1:TaxParty1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxParty1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxParty1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxParty1 * SOAP_FMAC4 soap_get_ns1__TaxParty1(struct soap *soap, ns1__TaxParty1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxParty1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxInformation10::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxInformation10::Cdtr = NULL;
	this->ns1__TaxInformation10::Dbtr = NULL;
	this->ns1__TaxInformation10::AdmstnZone = NULL;
	this->ns1__TaxInformation10::RefNb = NULL;
	this->ns1__TaxInformation10::Mtd = NULL;
	this->ns1__TaxInformation10::TtlTaxblBaseAmt = NULL;
	this->ns1__TaxInformation10::TtlTaxAmt = NULL;
	this->ns1__TaxInformation10::Dt = NULL;
	this->ns1__TaxInformation10::SeqNb = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, &this->ns1__TaxInformation10::Rcrd);
}

void ns1__TaxInformation10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TaxParty1(soap, &this->ns1__TaxInformation10::Cdtr);
	soap_serialize_PointerTons1__TaxParty2(soap, &this->ns1__TaxInformation10::Dbtr);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxInformation10::AdmstnZone);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__TaxInformation10::RefNb);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxInformation10::Mtd);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxInformation10::TtlTaxblBaseAmt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxInformation10::TtlTaxAmt);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__TaxInformation10::Dt);
	soap_serialize_PointerTons1__Number(soap, &this->ns1__TaxInformation10::SeqNb);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, &this->ns1__TaxInformation10::Rcrd);
#endif
}

int ns1__TaxInformation10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxInformation10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxInformation10(struct soap *soap, const char *tag, int id, const ns1__TaxInformation10 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxInformation10), type))
		return soap->error;
	if (soap_out_PointerTons1__TaxParty1(soap, "Cdtr", -1, &a->ns1__TaxInformation10::Cdtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxParty2(soap, "Dbtr", -1, &a->ns1__TaxInformation10::Dbtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "AdmstnZone", -1, &a->ns1__TaxInformation10::AdmstnZone, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "RefNb", -1, &a->ns1__TaxInformation10::RefNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Mtd", -1, &a->ns1__TaxInformation10::Mtd, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxblBaseAmt", -1, &a->ns1__TaxInformation10::TtlTaxblBaseAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxAmt", -1, &a->ns1__TaxInformation10::TtlTaxAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "Dt", -1, &a->ns1__TaxInformation10::Dt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Number(soap, "SeqNb", -1, &a->ns1__TaxInformation10::SeqNb, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, "Rcrd", -1, &a->ns1__TaxInformation10::Rcrd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxInformation10::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxInformation10(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxInformation10 * SOAP_FMAC4 soap_in_ns1__TaxInformation10(struct soap *soap, const char *tag, ns1__TaxInformation10 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxInformation10*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxInformation10, sizeof(ns1__TaxInformation10), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxInformation10)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxInformation10 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cdtr1 = 1;
	size_t soap_flag_Dbtr1 = 1;
	size_t soap_flag_AdmstnZone1 = 1;
	size_t soap_flag_RefNb1 = 1;
	size_t soap_flag_Mtd1 = 1;
	size_t soap_flag_TtlTaxblBaseAmt1 = 1;
	size_t soap_flag_TtlTaxAmt1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_SeqNb1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cdtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxParty1(soap, "Cdtr", &a->ns1__TaxInformation10::Cdtr, "ns1:TaxParty1"))
				{	soap_flag_Cdtr1--;
					continue;
				}
			}
			if (soap_flag_Dbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxParty2(soap, "Dbtr", &a->ns1__TaxInformation10::Dbtr, "ns1:TaxParty2"))
				{	soap_flag_Dbtr1--;
					continue;
				}
			}
			if (soap_flag_AdmstnZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "AdmstnZone", &a->ns1__TaxInformation10::AdmstnZone, "ns1:Max35Text"))
				{	soap_flag_AdmstnZone1--;
					continue;
				}
			}
			if (soap_flag_RefNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "RefNb", &a->ns1__TaxInformation10::RefNb, "ns1:Max140Text"))
				{	soap_flag_RefNb1--;
					continue;
				}
			}
			if (soap_flag_Mtd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Mtd", &a->ns1__TaxInformation10::Mtd, "ns1:Max35Text"))
				{	soap_flag_Mtd1--;
					continue;
				}
			}
			if (soap_flag_TtlTaxblBaseAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxblBaseAmt", &a->ns1__TaxInformation10::TtlTaxblBaseAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TtlTaxblBaseAmt1--;
					continue;
				}
			}
			if (soap_flag_TtlTaxAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxAmt", &a->ns1__TaxInformation10::TtlTaxAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TtlTaxAmt1--;
					continue;
				}
			}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "Dt", &a->ns1__TaxInformation10::Dt, "ns1:ISODate"))
				{	soap_flag_Dt1--;
					continue;
				}
			}
			if (soap_flag_SeqNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Number(soap, "SeqNb", &a->ns1__TaxInformation10::SeqNb, "ns1:Number"))
				{	soap_flag_SeqNb1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, "Rcrd", &a->ns1__TaxInformation10::Rcrd, "ns1:TaxRecord3"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxInformation10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxInformation10, SOAP_TYPE_ns1__TaxInformation10, sizeof(ns1__TaxInformation10), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxInformation10 * SOAP_FMAC2 soap_instantiate_ns1__TaxInformation10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxInformation10(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxInformation10 *p;
	size_t k = sizeof(ns1__TaxInformation10);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxInformation10, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxInformation10);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxInformation10, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxInformation10 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxInformation10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxInformation10(soap, tag ? tag : "ns1:TaxInformation10", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxInformation10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxInformation10(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxInformation10 * SOAP_FMAC4 soap_get_ns1__TaxInformation10(struct soap *soap, ns1__TaxInformation10 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxInformation10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxData1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxData1::Cdtr = NULL;
	this->ns1__TaxData1::Dbtr = NULL;
	this->ns1__TaxData1::UltmtDbtr = NULL;
	this->ns1__TaxData1::AdmstnZone = NULL;
	this->ns1__TaxData1::RefNb = NULL;
	this->ns1__TaxData1::Mtd = NULL;
	this->ns1__TaxData1::TtlTaxblBaseAmt = NULL;
	this->ns1__TaxData1::TtlTaxAmt = NULL;
	this->ns1__TaxData1::Dt = NULL;
	this->ns1__TaxData1::SeqNb = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, &this->ns1__TaxData1::Rcrd);
}

void ns1__TaxData1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TaxParty1(soap, &this->ns1__TaxData1::Cdtr);
	soap_serialize_PointerTons1__TaxParty2(soap, &this->ns1__TaxData1::Dbtr);
	soap_serialize_PointerTons1__TaxParty2(soap, &this->ns1__TaxData1::UltmtDbtr);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxData1::AdmstnZone);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__TaxData1::RefNb);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxData1::Mtd);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxData1::TtlTaxblBaseAmt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxData1::TtlTaxAmt);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__TaxData1::Dt);
	soap_serialize_PointerTons1__Number(soap, &this->ns1__TaxData1::SeqNb);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, &this->ns1__TaxData1::Rcrd);
#endif
}

int ns1__TaxData1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxData1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxData1(struct soap *soap, const char *tag, int id, const ns1__TaxData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxData1), type))
		return soap->error;
	if (soap_out_PointerTons1__TaxParty1(soap, "Cdtr", -1, &a->ns1__TaxData1::Cdtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxParty2(soap, "Dbtr", -1, &a->ns1__TaxData1::Dbtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxParty2(soap, "UltmtDbtr", -1, &a->ns1__TaxData1::UltmtDbtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "AdmstnZone", -1, &a->ns1__TaxData1::AdmstnZone, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "RefNb", -1, &a->ns1__TaxData1::RefNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Mtd", -1, &a->ns1__TaxData1::Mtd, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxblBaseAmt", -1, &a->ns1__TaxData1::TtlTaxblBaseAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxAmt", -1, &a->ns1__TaxData1::TtlTaxAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "Dt", -1, &a->ns1__TaxData1::Dt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Number(soap, "SeqNb", -1, &a->ns1__TaxData1::SeqNb, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, "Rcrd", -1, &a->ns1__TaxData1::Rcrd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxData1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxData1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxData1 * SOAP_FMAC4 soap_in_ns1__TaxData1(struct soap *soap, const char *tag, ns1__TaxData1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxData1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxData1, sizeof(ns1__TaxData1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxData1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxData1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cdtr1 = 1;
	size_t soap_flag_Dbtr1 = 1;
	size_t soap_flag_UltmtDbtr1 = 1;
	size_t soap_flag_AdmstnZone1 = 1;
	size_t soap_flag_RefNb1 = 1;
	size_t soap_flag_Mtd1 = 1;
	size_t soap_flag_TtlTaxblBaseAmt1 = 1;
	size_t soap_flag_TtlTaxAmt1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_SeqNb1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cdtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxParty1(soap, "Cdtr", &a->ns1__TaxData1::Cdtr, "ns1:TaxParty1"))
				{	soap_flag_Cdtr1--;
					continue;
				}
			}
			if (soap_flag_Dbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxParty2(soap, "Dbtr", &a->ns1__TaxData1::Dbtr, "ns1:TaxParty2"))
				{	soap_flag_Dbtr1--;
					continue;
				}
			}
			if (soap_flag_UltmtDbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxParty2(soap, "UltmtDbtr", &a->ns1__TaxData1::UltmtDbtr, "ns1:TaxParty2"))
				{	soap_flag_UltmtDbtr1--;
					continue;
				}
			}
			if (soap_flag_AdmstnZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "AdmstnZone", &a->ns1__TaxData1::AdmstnZone, "ns1:Max35Text"))
				{	soap_flag_AdmstnZone1--;
					continue;
				}
			}
			if (soap_flag_RefNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "RefNb", &a->ns1__TaxData1::RefNb, "ns1:Max140Text"))
				{	soap_flag_RefNb1--;
					continue;
				}
			}
			if (soap_flag_Mtd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Mtd", &a->ns1__TaxData1::Mtd, "ns1:Max35Text"))
				{	soap_flag_Mtd1--;
					continue;
				}
			}
			if (soap_flag_TtlTaxblBaseAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxblBaseAmt", &a->ns1__TaxData1::TtlTaxblBaseAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TtlTaxblBaseAmt1--;
					continue;
				}
			}
			if (soap_flag_TtlTaxAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlTaxAmt", &a->ns1__TaxData1::TtlTaxAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TtlTaxAmt1--;
					continue;
				}
			}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "Dt", &a->ns1__TaxData1::Dt, "ns1:ISODate"))
				{	soap_flag_Dt1--;
					continue;
				}
			}
			if (soap_flag_SeqNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Number(soap, "SeqNb", &a->ns1__TaxData1::SeqNb, "ns1:Number"))
				{	soap_flag_SeqNb1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TaxRecord3(soap, "Rcrd", &a->ns1__TaxData1::Rcrd, "ns1:TaxRecord3"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxData1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxData1, SOAP_TYPE_ns1__TaxData1, sizeof(ns1__TaxData1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxData1 * SOAP_FMAC2 soap_instantiate_ns1__TaxData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxData1 *p;
	size_t k = sizeof(ns1__TaxData1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxData1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxData1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxData1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxData1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxData1(soap, tag ? tag : "ns1:TaxData1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxData1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxData1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxData1 * SOAP_FMAC4 soap_get_ns1__TaxData1(struct soap *soap, ns1__TaxData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxAuthorisation1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxAuthorisation1::Titl = NULL;
	this->ns1__TaxAuthorisation1::Nm = NULL;
}

void ns1__TaxAuthorisation1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__TaxAuthorisation1::Titl);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__TaxAuthorisation1::Nm);
#endif
}

int ns1__TaxAuthorisation1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxAuthorisation1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxAuthorisation1(struct soap *soap, const char *tag, int id, const ns1__TaxAuthorisation1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxAuthorisation1), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Titl", -1, &a->ns1__TaxAuthorisation1::Titl, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__TaxAuthorisation1::Nm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxAuthorisation1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxAuthorisation1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxAuthorisation1 * SOAP_FMAC4 soap_in_ns1__TaxAuthorisation1(struct soap *soap, const char *tag, ns1__TaxAuthorisation1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxAuthorisation1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxAuthorisation1, sizeof(ns1__TaxAuthorisation1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxAuthorisation1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxAuthorisation1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Titl1 = 1;
	size_t soap_flag_Nm1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Titl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Titl", &a->ns1__TaxAuthorisation1::Titl, "ns1:Max35Text"))
				{	soap_flag_Titl1--;
					continue;
				}
			}
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__TaxAuthorisation1::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxAuthorisation1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxAuthorisation1, SOAP_TYPE_ns1__TaxAuthorisation1, sizeof(ns1__TaxAuthorisation1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxAuthorisation1 * SOAP_FMAC2 soap_instantiate_ns1__TaxAuthorisation1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxAuthorisation1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxAuthorisation1 *p;
	size_t k = sizeof(ns1__TaxAuthorisation1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxAuthorisation1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxAuthorisation1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxAuthorisation1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxAuthorisation1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxAuthorisation1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxAuthorisation1(soap, tag ? tag : "ns1:TaxAuthorisation1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxAuthorisation1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxAuthorisation1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxAuthorisation1 * SOAP_FMAC4 soap_get_ns1__TaxAuthorisation1(struct soap *soap, ns1__TaxAuthorisation1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxAuthorisation1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxAmountType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxAmountType1Choice::__union_TaxAmountType1Choice = 0;
}

void ns1__TaxAmountType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_TaxAmountType1Choice(soap, this->ns1__TaxAmountType1Choice::__union_TaxAmountType1Choice, &this->ns1__TaxAmountType1Choice::union_TaxAmountType1Choice);
#endif
}

int ns1__TaxAmountType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxAmountType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxAmountType1Choice(struct soap *soap, const char *tag, int id, const ns1__TaxAmountType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxAmountType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_TaxAmountType1Choice(soap, a->ns1__TaxAmountType1Choice::__union_TaxAmountType1Choice, &a->ns1__TaxAmountType1Choice::union_TaxAmountType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxAmountType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxAmountType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxAmountType1Choice * SOAP_FMAC4 soap_in_ns1__TaxAmountType1Choice(struct soap *soap, const char *tag, ns1__TaxAmountType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxAmountType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxAmountType1Choice, sizeof(ns1__TaxAmountType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_TaxAmountType1Choice(soap, &a->__union_TaxAmountType1Choice, &a->union_TaxAmountType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__TaxAmountType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxAmountType1Choice, SOAP_TYPE_ns1__TaxAmountType1Choice, sizeof(ns1__TaxAmountType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxAmountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__TaxAmountType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxAmountType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxAmountType1Choice *p;
	size_t k = sizeof(ns1__TaxAmountType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxAmountType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxAmountType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxAmountType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxAmountType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxAmountType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxAmountType1Choice(soap, tag ? tag : "ns1:TaxAmountType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxAmountType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxAmountType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxAmountType1Choice * SOAP_FMAC4 soap_get_ns1__TaxAmountType1Choice(struct soap *soap, ns1__TaxAmountType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxAmountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxAmountAndType1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxAmountAndType1::Tp = NULL;
	this->ns1__TaxAmountAndType1::Amt = NULL;
}

void ns1__TaxAmountAndType1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TaxAmountType1Choice(soap, &this->ns1__TaxAmountAndType1::Tp);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxAmountAndType1::Amt);
#endif
}

int ns1__TaxAmountAndType1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxAmountAndType1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxAmountAndType1(struct soap *soap, const char *tag, int id, const ns1__TaxAmountAndType1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxAmountAndType1), type))
		return soap->error;
	if (soap_out_PointerTons1__TaxAmountType1Choice(soap, "Tp", -1, &a->ns1__TaxAmountAndType1::Tp, ""))
		return soap->error;
	if (!a->ns1__TaxAmountAndType1::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__TaxAmountAndType1::Amt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxAmountAndType1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxAmountAndType1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxAmountAndType1 * SOAP_FMAC4 soap_in_ns1__TaxAmountAndType1(struct soap *soap, const char *tag, ns1__TaxAmountAndType1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxAmountAndType1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxAmountAndType1, sizeof(ns1__TaxAmountAndType1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxAmountAndType1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxAmountAndType1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Amt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxAmountType1Choice(soap, "Tp", &a->ns1__TaxAmountAndType1::Tp, "ns1:TaxAmountType1Choice"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__TaxAmountAndType1::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__TaxAmountAndType1::Amt))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TaxAmountAndType1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxAmountAndType1, SOAP_TYPE_ns1__TaxAmountAndType1, sizeof(ns1__TaxAmountAndType1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxAmountAndType1 * SOAP_FMAC2 soap_instantiate_ns1__TaxAmountAndType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxAmountAndType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxAmountAndType1 *p;
	size_t k = sizeof(ns1__TaxAmountAndType1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxAmountAndType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxAmountAndType1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxAmountAndType1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxAmountAndType1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxAmountAndType1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxAmountAndType1(soap, tag ? tag : "ns1:TaxAmountAndType1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxAmountAndType1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxAmountAndType1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxAmountAndType1 * SOAP_FMAC4 soap_get_ns1__TaxAmountAndType1(struct soap *soap, ns1__TaxAmountAndType1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxAmountAndType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TaxAmount3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaxAmount3::Rate = NULL;
	this->ns1__TaxAmount3::TaxblBaseAmt = NULL;
	this->ns1__TaxAmount3::TtlAmt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap, &this->ns1__TaxAmount3::Dtls);
}

void ns1__TaxAmount3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__PercentageRate(soap, &this->ns1__TaxAmount3::Rate);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxAmount3::TaxblBaseAmt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__TaxAmount3::TtlAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap, &this->ns1__TaxAmount3::Dtls);
#endif
}

int ns1__TaxAmount3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaxAmount3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaxAmount3(struct soap *soap, const char *tag, int id, const ns1__TaxAmount3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaxAmount3), type))
		return soap->error;
	if (soap_out_PointerTons1__PercentageRate(soap, "Rate", -1, &a->ns1__TaxAmount3::Rate, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TaxblBaseAmt", -1, &a->ns1__TaxAmount3::TaxblBaseAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlAmt", -1, &a->ns1__TaxAmount3::TtlAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap, "Dtls", -1, &a->ns1__TaxAmount3::Dtls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TaxAmount3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TaxAmount3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaxAmount3 * SOAP_FMAC4 soap_in_ns1__TaxAmount3(struct soap *soap, const char *tag, ns1__TaxAmount3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaxAmount3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaxAmount3, sizeof(ns1__TaxAmount3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TaxAmount3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TaxAmount3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Rate1 = 1;
	size_t soap_flag_TaxblBaseAmt1 = 1;
	size_t soap_flag_TtlAmt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__PercentageRate(soap, "Rate", &a->ns1__TaxAmount3::Rate, "ns1:PercentageRate"))
				{	soap_flag_Rate1--;
					continue;
				}
			}
			if (soap_flag_TaxblBaseAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TaxblBaseAmt", &a->ns1__TaxAmount3::TaxblBaseAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TaxblBaseAmt1--;
					continue;
				}
			}
			if (soap_flag_TtlAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "TtlAmt", &a->ns1__TaxAmount3::TtlAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_TtlAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap, "Dtls", &a->ns1__TaxAmount3::Dtls, "ns1:TaxRecordDetails3"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaxAmount3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaxAmount3, SOAP_TYPE_ns1__TaxAmount3, sizeof(ns1__TaxAmount3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TaxAmount3 * SOAP_FMAC2 soap_instantiate_ns1__TaxAmount3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaxAmount3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TaxAmount3 *p;
	size_t k = sizeof(ns1__TaxAmount3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TaxAmount3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TaxAmount3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TaxAmount3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TaxAmount3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TaxAmount3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TaxAmount3(soap, tag ? tag : "ns1:TaxAmount3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaxAmount3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaxAmount3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaxAmount3 * SOAP_FMAC4 soap_get_ns1__TaxAmount3(struct soap *soap, ns1__TaxAmount3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaxAmount3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SupplementaryDataEnvelope1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SupplementaryDataEnvelope1::__any = NULL;
}

void ns1__SupplementaryDataEnvelope1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SupplementaryDataEnvelope1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SupplementaryDataEnvelope1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SupplementaryDataEnvelope1(struct soap *soap, const char *tag, int id, const ns1__SupplementaryDataEnvelope1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SupplementaryDataEnvelope1), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->ns1__SupplementaryDataEnvelope1::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SupplementaryDataEnvelope1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SupplementaryDataEnvelope1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SupplementaryDataEnvelope1 * SOAP_FMAC4 soap_in_ns1__SupplementaryDataEnvelope1(struct soap *soap, const char *tag, ns1__SupplementaryDataEnvelope1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SupplementaryDataEnvelope1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, sizeof(ns1__SupplementaryDataEnvelope1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SupplementaryDataEnvelope1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SupplementaryDataEnvelope1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->ns1__SupplementaryDataEnvelope1::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SupplementaryDataEnvelope1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, sizeof(ns1__SupplementaryDataEnvelope1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SupplementaryDataEnvelope1 * SOAP_FMAC2 soap_instantiate_ns1__SupplementaryDataEnvelope1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SupplementaryDataEnvelope1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SupplementaryDataEnvelope1 *p;
	size_t k = sizeof(ns1__SupplementaryDataEnvelope1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SupplementaryDataEnvelope1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SupplementaryDataEnvelope1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SupplementaryDataEnvelope1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SupplementaryDataEnvelope1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SupplementaryDataEnvelope1(soap, tag ? tag : "ns1:SupplementaryDataEnvelope1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SupplementaryDataEnvelope1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SupplementaryDataEnvelope1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SupplementaryDataEnvelope1 * SOAP_FMAC4 soap_get_ns1__SupplementaryDataEnvelope1(struct soap *soap, ns1__SupplementaryDataEnvelope1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SupplementaryDataEnvelope1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SupplementaryData1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SupplementaryData1::PlcAndNm = NULL;
	this->ns1__SupplementaryData1::Envlp = NULL;
}

void ns1__SupplementaryData1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max350Text(soap, &this->ns1__SupplementaryData1::PlcAndNm);
	soap_serialize_PointerTons1__SupplementaryDataEnvelope1(soap, &this->ns1__SupplementaryData1::Envlp);
#endif
}

int ns1__SupplementaryData1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SupplementaryData1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SupplementaryData1(struct soap *soap, const char *tag, int id, const ns1__SupplementaryData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SupplementaryData1), type))
		return soap->error;
	if (soap_out_PointerTons1__Max350Text(soap, "PlcAndNm", -1, &a->ns1__SupplementaryData1::PlcAndNm, ""))
		return soap->error;
	if (!a->ns1__SupplementaryData1::Envlp)
	{	if (soap_element_empty(soap, "Envlp", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__SupplementaryDataEnvelope1(soap, "Envlp", -1, &a->ns1__SupplementaryData1::Envlp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SupplementaryData1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SupplementaryData1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SupplementaryData1 * SOAP_FMAC4 soap_in_ns1__SupplementaryData1(struct soap *soap, const char *tag, ns1__SupplementaryData1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SupplementaryData1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SupplementaryData1, sizeof(ns1__SupplementaryData1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SupplementaryData1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SupplementaryData1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PlcAndNm1 = 1;
	size_t soap_flag_Envlp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PlcAndNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max350Text(soap, "PlcAndNm", &a->ns1__SupplementaryData1::PlcAndNm, "ns1:Max350Text"))
				{	soap_flag_PlcAndNm1--;
					continue;
				}
			}
			if (soap_flag_Envlp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SupplementaryDataEnvelope1(soap, "Envlp", &a->ns1__SupplementaryData1::Envlp, "ns1:SupplementaryDataEnvelope1"))
				{	soap_flag_Envlp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SupplementaryData1::Envlp))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SupplementaryData1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SupplementaryData1, SOAP_TYPE_ns1__SupplementaryData1, sizeof(ns1__SupplementaryData1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SupplementaryData1 * SOAP_FMAC2 soap_instantiate_ns1__SupplementaryData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SupplementaryData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SupplementaryData1 *p;
	size_t k = sizeof(ns1__SupplementaryData1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SupplementaryData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SupplementaryData1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SupplementaryData1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SupplementaryData1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SupplementaryData1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SupplementaryData1(soap, tag ? tag : "ns1:SupplementaryData1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SupplementaryData1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SupplementaryData1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SupplementaryData1 * SOAP_FMAC4 soap_get_ns1__SupplementaryData1(struct soap *soap, ns1__SupplementaryData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SupplementaryData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StructuredRemittanceInformation17::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap, &this->ns1__StructuredRemittanceInformation17::RfrdDocInf);
	this->ns1__StructuredRemittanceInformation17::RfrdDocAmt = NULL;
	this->ns1__StructuredRemittanceInformation17::CdtrRefInf = NULL;
	this->ns1__StructuredRemittanceInformation17::Invcr = NULL;
	this->ns1__StructuredRemittanceInformation17::Invcee = NULL;
	this->ns1__StructuredRemittanceInformation17::TaxRmt = NULL;
	this->ns1__StructuredRemittanceInformation17::GrnshmtRmt = NULL;
	soap_default_std__vectorTemplateOfns1__Max140Text(soap, &this->ns1__StructuredRemittanceInformation17::AddtlRmtInf);
}

void ns1__StructuredRemittanceInformation17::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap, &this->ns1__StructuredRemittanceInformation17::RfrdDocInf);
	soap_serialize_PointerTons1__RemittanceAmount2(soap, &this->ns1__StructuredRemittanceInformation17::RfrdDocAmt);
	soap_serialize_PointerTons1__CreditorReferenceInformation2(soap, &this->ns1__StructuredRemittanceInformation17::CdtrRefInf);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__StructuredRemittanceInformation17::Invcr);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__StructuredRemittanceInformation17::Invcee);
	soap_serialize_PointerTons1__TaxData1(soap, &this->ns1__StructuredRemittanceInformation17::TaxRmt);
	soap_serialize_PointerTons1__Garnishment3(soap, &this->ns1__StructuredRemittanceInformation17::GrnshmtRmt);
	soap_serialize_std__vectorTemplateOfns1__Max140Text(soap, &this->ns1__StructuredRemittanceInformation17::AddtlRmtInf);
#endif
}

int ns1__StructuredRemittanceInformation17::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StructuredRemittanceInformation17(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, int id, const ns1__StructuredRemittanceInformation17 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StructuredRemittanceInformation17), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap, "RfrdDocInf", -1, &a->ns1__StructuredRemittanceInformation17::RfrdDocInf, ""))
		return soap->error;
	if (soap_out_PointerTons1__RemittanceAmount2(soap, "RfrdDocAmt", -1, &a->ns1__StructuredRemittanceInformation17::RfrdDocAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__CreditorReferenceInformation2(soap, "CdtrRefInf", -1, &a->ns1__StructuredRemittanceInformation17::CdtrRefInf, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "Invcr", -1, &a->ns1__StructuredRemittanceInformation17::Invcr, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "Invcee", -1, &a->ns1__StructuredRemittanceInformation17::Invcee, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxData1(soap, "TaxRmt", -1, &a->ns1__StructuredRemittanceInformation17::TaxRmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Garnishment3(soap, "GrnshmtRmt", -1, &a->ns1__StructuredRemittanceInformation17::GrnshmtRmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max140Text(soap, "AddtlRmtInf", -1, &a->ns1__StructuredRemittanceInformation17::AddtlRmtInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StructuredRemittanceInformation17::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StructuredRemittanceInformation17(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StructuredRemittanceInformation17 * SOAP_FMAC4 soap_in_ns1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, ns1__StructuredRemittanceInformation17 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StructuredRemittanceInformation17*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StructuredRemittanceInformation17, sizeof(ns1__StructuredRemittanceInformation17), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StructuredRemittanceInformation17)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StructuredRemittanceInformation17 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RfrdDocAmt1 = 1;
	size_t soap_flag_CdtrRefInf1 = 1;
	size_t soap_flag_Invcr1 = 1;
	size_t soap_flag_Invcee1 = 1;
	size_t soap_flag_TaxRmt1 = 1;
	size_t soap_flag_GrnshmtRmt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap, "RfrdDocInf", &a->ns1__StructuredRemittanceInformation17::RfrdDocInf, "ns1:ReferredDocumentInformation7"))
					continue;
			}
			if (soap_flag_RfrdDocAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RemittanceAmount2(soap, "RfrdDocAmt", &a->ns1__StructuredRemittanceInformation17::RfrdDocAmt, "ns1:RemittanceAmount2"))
				{	soap_flag_RfrdDocAmt1--;
					continue;
				}
			}
			if (soap_flag_CdtrRefInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CreditorReferenceInformation2(soap, "CdtrRefInf", &a->ns1__StructuredRemittanceInformation17::CdtrRefInf, "ns1:CreditorReferenceInformation2"))
				{	soap_flag_CdtrRefInf1--;
					continue;
				}
			}
			if (soap_flag_Invcr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "Invcr", &a->ns1__StructuredRemittanceInformation17::Invcr, "ns1:PartyIdentification135"))
				{	soap_flag_Invcr1--;
					continue;
				}
			}
			if (soap_flag_Invcee1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "Invcee", &a->ns1__StructuredRemittanceInformation17::Invcee, "ns1:PartyIdentification135"))
				{	soap_flag_Invcee1--;
					continue;
				}
			}
			if (soap_flag_TaxRmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxData1(soap, "TaxRmt", &a->ns1__StructuredRemittanceInformation17::TaxRmt, "ns1:TaxData1"))
				{	soap_flag_TaxRmt1--;
					continue;
				}
			}
			if (soap_flag_GrnshmtRmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Garnishment3(soap, "GrnshmtRmt", &a->ns1__StructuredRemittanceInformation17::GrnshmtRmt, "ns1:Garnishment3"))
				{	soap_flag_GrnshmtRmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max140Text(soap, "AddtlRmtInf", &a->ns1__StructuredRemittanceInformation17::AddtlRmtInf, "ns1:Max140Text"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__StructuredRemittanceInformation17::AddtlRmtInf.size() > 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__StructuredRemittanceInformation17 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StructuredRemittanceInformation17, SOAP_TYPE_ns1__StructuredRemittanceInformation17, sizeof(ns1__StructuredRemittanceInformation17), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StructuredRemittanceInformation17 * SOAP_FMAC2 soap_instantiate_ns1__StructuredRemittanceInformation17(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StructuredRemittanceInformation17(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StructuredRemittanceInformation17 *p;
	size_t k = sizeof(ns1__StructuredRemittanceInformation17);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StructuredRemittanceInformation17, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StructuredRemittanceInformation17);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StructuredRemittanceInformation17, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StructuredRemittanceInformation17 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StructuredRemittanceInformation17::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StructuredRemittanceInformation17(soap, tag ? tag : "ns1:StructuredRemittanceInformation17", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StructuredRemittanceInformation17::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StructuredRemittanceInformation17(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StructuredRemittanceInformation17 * SOAP_FMAC4 soap_get_ns1__StructuredRemittanceInformation17(struct soap *soap, ns1__StructuredRemittanceInformation17 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StructuredRemittanceInformation17(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StructuredRegulatoryReporting3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__StructuredRegulatoryReporting3::Tp = NULL;
	this->ns1__StructuredRegulatoryReporting3::Dt = NULL;
	this->ns1__StructuredRegulatoryReporting3::Ctry = NULL;
	this->ns1__StructuredRegulatoryReporting3::Cd = NULL;
	this->ns1__StructuredRegulatoryReporting3::Amt = NULL;
	soap_default_std__vectorTemplateOfns1__Max35Text(soap, &this->ns1__StructuredRegulatoryReporting3::Inf);
}

void ns1__StructuredRegulatoryReporting3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__StructuredRegulatoryReporting3::Tp);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__StructuredRegulatoryReporting3::Dt);
	soap_serialize_PointerTons1__CountryCode(soap, &this->ns1__StructuredRegulatoryReporting3::Ctry);
	soap_serialize_PointerTons1__Max10Text(soap, &this->ns1__StructuredRegulatoryReporting3::Cd);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__StructuredRegulatoryReporting3::Amt);
	soap_serialize_std__vectorTemplateOfns1__Max35Text(soap, &this->ns1__StructuredRegulatoryReporting3::Inf);
#endif
}

int ns1__StructuredRegulatoryReporting3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StructuredRegulatoryReporting3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, int id, const ns1__StructuredRegulatoryReporting3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StructuredRegulatoryReporting3), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Tp", -1, &a->ns1__StructuredRegulatoryReporting3::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "Dt", -1, &a->ns1__StructuredRegulatoryReporting3::Dt, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryCode(soap, "Ctry", -1, &a->ns1__StructuredRegulatoryReporting3::Ctry, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max10Text(soap, "Cd", -1, &a->ns1__StructuredRegulatoryReporting3::Cd, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__StructuredRegulatoryReporting3::Amt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max35Text(soap, "Inf", -1, &a->ns1__StructuredRegulatoryReporting3::Inf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StructuredRegulatoryReporting3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StructuredRegulatoryReporting3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StructuredRegulatoryReporting3 * SOAP_FMAC4 soap_in_ns1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, ns1__StructuredRegulatoryReporting3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StructuredRegulatoryReporting3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, sizeof(ns1__StructuredRegulatoryReporting3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StructuredRegulatoryReporting3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StructuredRegulatoryReporting3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_Ctry1 = 1;
	size_t soap_flag_Cd1 = 1;
	size_t soap_flag_Amt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Tp", &a->ns1__StructuredRegulatoryReporting3::Tp, "ns1:Max35Text"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "Dt", &a->ns1__StructuredRegulatoryReporting3::Dt, "ns1:ISODate"))
				{	soap_flag_Dt1--;
					continue;
				}
			}
			if (soap_flag_Ctry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__CountryCode(soap, "Ctry", &a->ns1__StructuredRegulatoryReporting3::Ctry, "ns1:CountryCode"))
				{	soap_flag_Ctry1--;
					continue;
				}
			}
			if (soap_flag_Cd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max10Text(soap, "Cd", &a->ns1__StructuredRegulatoryReporting3::Cd, "ns1:Max10Text"))
				{	soap_flag_Cd1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__StructuredRegulatoryReporting3::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max35Text(soap, "Inf", &a->ns1__StructuredRegulatoryReporting3::Inf, "ns1:Max35Text"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StructuredRegulatoryReporting3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, sizeof(ns1__StructuredRegulatoryReporting3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StructuredRegulatoryReporting3 * SOAP_FMAC2 soap_instantiate_ns1__StructuredRegulatoryReporting3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StructuredRegulatoryReporting3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StructuredRegulatoryReporting3 *p;
	size_t k = sizeof(ns1__StructuredRegulatoryReporting3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StructuredRegulatoryReporting3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StructuredRegulatoryReporting3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StructuredRegulatoryReporting3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StructuredRegulatoryReporting3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StructuredRegulatoryReporting3(soap, tag ? tag : "ns1:StructuredRegulatoryReporting3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StructuredRegulatoryReporting3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StructuredRegulatoryReporting3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StructuredRegulatoryReporting3 * SOAP_FMAC4 soap_get_ns1__StructuredRegulatoryReporting3(struct soap *soap, ns1__StructuredRegulatoryReporting3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StructuredRegulatoryReporting3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ServiceLevel8Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ServiceLevel8Choice::__union_ServiceLevel8Choice = 0;
}

void ns1__ServiceLevel8Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ServiceLevel8Choice(soap, this->ns1__ServiceLevel8Choice::__union_ServiceLevel8Choice, &this->ns1__ServiceLevel8Choice::union_ServiceLevel8Choice);
#endif
}

int ns1__ServiceLevel8Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ServiceLevel8Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServiceLevel8Choice(struct soap *soap, const char *tag, int id, const ns1__ServiceLevel8Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServiceLevel8Choice), type))
		return soap->error;
	if (soap_out__ns1__union_ServiceLevel8Choice(soap, a->ns1__ServiceLevel8Choice::__union_ServiceLevel8Choice, &a->ns1__ServiceLevel8Choice::union_ServiceLevel8Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ServiceLevel8Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ServiceLevel8Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ServiceLevel8Choice * SOAP_FMAC4 soap_in_ns1__ServiceLevel8Choice(struct soap *soap, const char *tag, ns1__ServiceLevel8Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ServiceLevel8Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServiceLevel8Choice, sizeof(ns1__ServiceLevel8Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ServiceLevel8Choice(soap, &a->__union_ServiceLevel8Choice, &a->union_ServiceLevel8Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ServiceLevel8Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServiceLevel8Choice, SOAP_TYPE_ns1__ServiceLevel8Choice, sizeof(ns1__ServiceLevel8Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ServiceLevel8Choice * SOAP_FMAC2 soap_instantiate_ns1__ServiceLevel8Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ServiceLevel8Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ServiceLevel8Choice *p;
	size_t k = sizeof(ns1__ServiceLevel8Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ServiceLevel8Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ServiceLevel8Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ServiceLevel8Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ServiceLevel8Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ServiceLevel8Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ServiceLevel8Choice(soap, tag ? tag : "ns1:ServiceLevel8Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ServiceLevel8Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ServiceLevel8Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ServiceLevel8Choice * SOAP_FMAC4 soap_get_ns1__ServiceLevel8Choice(struct soap *soap, ns1__ServiceLevel8Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServiceLevel8Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RemittanceLocationData1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__RemittanceLocationMethod2Code(soap, &this->ns1__RemittanceLocationData1::Mtd);
	this->ns1__RemittanceLocationData1::ElctrncAdr = NULL;
	this->ns1__RemittanceLocationData1::PstlAdr = NULL;
}

void ns1__RemittanceLocationData1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max2048Text(soap, &this->ns1__RemittanceLocationData1::ElctrncAdr);
	soap_serialize_PointerTons1__NameAndAddress16(soap, &this->ns1__RemittanceLocationData1::PstlAdr);
#endif
}

int ns1__RemittanceLocationData1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemittanceLocationData1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceLocationData1(struct soap *soap, const char *tag, int id, const ns1__RemittanceLocationData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceLocationData1), type))
		return soap->error;
	if (soap_out_ns1__RemittanceLocationMethod2Code(soap, "Mtd", -1, &a->ns1__RemittanceLocationData1::Mtd, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max2048Text(soap, "ElctrncAdr", -1, &a->ns1__RemittanceLocationData1::ElctrncAdr, ""))
		return soap->error;
	if (soap_out_PointerTons1__NameAndAddress16(soap, "PstlAdr", -1, &a->ns1__RemittanceLocationData1::PstlAdr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RemittanceLocationData1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RemittanceLocationData1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemittanceLocationData1 * SOAP_FMAC4 soap_in_ns1__RemittanceLocationData1(struct soap *soap, const char *tag, ns1__RemittanceLocationData1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemittanceLocationData1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceLocationData1, sizeof(ns1__RemittanceLocationData1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RemittanceLocationData1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RemittanceLocationData1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mtd1 = 1;
	size_t soap_flag_ElctrncAdr1 = 1;
	size_t soap_flag_PstlAdr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mtd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__RemittanceLocationMethod2Code(soap, "Mtd", &a->ns1__RemittanceLocationData1::Mtd, "ns1:RemittanceLocationMethod2Code"))
				{	soap_flag_Mtd1--;
					continue;
				}
			}
			if (soap_flag_ElctrncAdr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max2048Text(soap, "ElctrncAdr", &a->ns1__RemittanceLocationData1::ElctrncAdr, "ns1:Max2048Text"))
				{	soap_flag_ElctrncAdr1--;
					continue;
				}
			}
			if (soap_flag_PstlAdr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NameAndAddress16(soap, "PstlAdr", &a->ns1__RemittanceLocationData1::PstlAdr, "ns1:NameAndAddress16"))
				{	soap_flag_PstlAdr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mtd1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RemittanceLocationData1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceLocationData1, SOAP_TYPE_ns1__RemittanceLocationData1, sizeof(ns1__RemittanceLocationData1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RemittanceLocationData1 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceLocationData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemittanceLocationData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RemittanceLocationData1 *p;
	size_t k = sizeof(ns1__RemittanceLocationData1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RemittanceLocationData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RemittanceLocationData1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RemittanceLocationData1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RemittanceLocationData1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RemittanceLocationData1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RemittanceLocationData1(soap, tag ? tag : "ns1:RemittanceLocationData1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RemittanceLocationData1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemittanceLocationData1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemittanceLocationData1 * SOAP_FMAC4 soap_get_ns1__RemittanceLocationData1(struct soap *soap, ns1__RemittanceLocationData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceLocationData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RemittanceLocation7::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RemittanceLocation7::RmtId = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap, &this->ns1__RemittanceLocation7::RmtLctnDtls);
}

void ns1__RemittanceLocation7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__RemittanceLocation7::RmtId);
	soap_serialize_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap, &this->ns1__RemittanceLocation7::RmtLctnDtls);
#endif
}

int ns1__RemittanceLocation7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemittanceLocation7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceLocation7(struct soap *soap, const char *tag, int id, const ns1__RemittanceLocation7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceLocation7), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "RmtId", -1, &a->ns1__RemittanceLocation7::RmtId, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap, "RmtLctnDtls", -1, &a->ns1__RemittanceLocation7::RmtLctnDtls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RemittanceLocation7::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RemittanceLocation7(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemittanceLocation7 * SOAP_FMAC4 soap_in_ns1__RemittanceLocation7(struct soap *soap, const char *tag, ns1__RemittanceLocation7 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemittanceLocation7*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceLocation7, sizeof(ns1__RemittanceLocation7), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RemittanceLocation7)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RemittanceLocation7 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RmtId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RmtId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "RmtId", &a->ns1__RemittanceLocation7::RmtId, "ns1:Max35Text"))
				{	soap_flag_RmtId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap, "RmtLctnDtls", &a->ns1__RemittanceLocation7::RmtLctnDtls, "ns1:RemittanceLocationData1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RemittanceLocation7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceLocation7, SOAP_TYPE_ns1__RemittanceLocation7, sizeof(ns1__RemittanceLocation7), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RemittanceLocation7 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceLocation7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemittanceLocation7(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RemittanceLocation7 *p;
	size_t k = sizeof(ns1__RemittanceLocation7);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RemittanceLocation7, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RemittanceLocation7);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RemittanceLocation7, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RemittanceLocation7 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RemittanceLocation7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RemittanceLocation7(soap, tag ? tag : "ns1:RemittanceLocation7", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RemittanceLocation7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemittanceLocation7(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemittanceLocation7 * SOAP_FMAC4 soap_get_ns1__RemittanceLocation7(struct soap *soap, ns1__RemittanceLocation7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceLocation7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RemittanceInformation21::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__Max140Text(soap, &this->ns1__RemittanceInformation21::Ustrd);
	soap_default_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap, &this->ns1__RemittanceInformation21::Strd);
}

void ns1__RemittanceInformation21::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns1__Max140Text(soap, &this->ns1__RemittanceInformation21::Ustrd);
	soap_serialize_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap, &this->ns1__RemittanceInformation21::Strd);
#endif
}

int ns1__RemittanceInformation21::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemittanceInformation21(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceInformation21(struct soap *soap, const char *tag, int id, const ns1__RemittanceInformation21 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceInformation21), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max140Text(soap, "Ustrd", -1, &a->ns1__RemittanceInformation21::Ustrd, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap, "Strd", -1, &a->ns1__RemittanceInformation21::Strd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RemittanceInformation21::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RemittanceInformation21(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemittanceInformation21 * SOAP_FMAC4 soap_in_ns1__RemittanceInformation21(struct soap *soap, const char *tag, ns1__RemittanceInformation21 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemittanceInformation21*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceInformation21, sizeof(ns1__RemittanceInformation21), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RemittanceInformation21)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RemittanceInformation21 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max140Text(soap, "Ustrd", &a->ns1__RemittanceInformation21::Ustrd, "ns1:Max140Text"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap, "Strd", &a->ns1__RemittanceInformation21::Strd, "ns1:StructuredRemittanceInformation17"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RemittanceInformation21 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceInformation21, SOAP_TYPE_ns1__RemittanceInformation21, sizeof(ns1__RemittanceInformation21), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RemittanceInformation21 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceInformation21(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemittanceInformation21(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RemittanceInformation21 *p;
	size_t k = sizeof(ns1__RemittanceInformation21);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RemittanceInformation21, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RemittanceInformation21);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RemittanceInformation21, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RemittanceInformation21 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RemittanceInformation21::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RemittanceInformation21(soap, tag ? tag : "ns1:RemittanceInformation21", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RemittanceInformation21::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemittanceInformation21(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemittanceInformation21 * SOAP_FMAC4 soap_get_ns1__RemittanceInformation21(struct soap *soap, ns1__RemittanceInformation21 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceInformation21(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RemittanceAmount3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RemittanceAmount3::DuePyblAmt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, &this->ns1__RemittanceAmount3::DscntApldAmt);
	this->ns1__RemittanceAmount3::CdtNoteAmt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, &this->ns1__RemittanceAmount3::TaxAmt);
	soap_default_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, &this->ns1__RemittanceAmount3::AdjstmntAmtAndRsn);
	this->ns1__RemittanceAmount3::RmtdAmt = NULL;
}

void ns1__RemittanceAmount3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount3::DuePyblAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, &this->ns1__RemittanceAmount3::DscntApldAmt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount3::CdtNoteAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, &this->ns1__RemittanceAmount3::TaxAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, &this->ns1__RemittanceAmount3::AdjstmntAmtAndRsn);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount3::RmtdAmt);
#endif
}

int ns1__RemittanceAmount3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemittanceAmount3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceAmount3(struct soap *soap, const char *tag, int id, const ns1__RemittanceAmount3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceAmount3), type))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "DuePyblAmt", -1, &a->ns1__RemittanceAmount3::DuePyblAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, "DscntApldAmt", -1, &a->ns1__RemittanceAmount3::DscntApldAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "CdtNoteAmt", -1, &a->ns1__RemittanceAmount3::CdtNoteAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, "TaxAmt", -1, &a->ns1__RemittanceAmount3::TaxAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, "AdjstmntAmtAndRsn", -1, &a->ns1__RemittanceAmount3::AdjstmntAmtAndRsn, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", -1, &a->ns1__RemittanceAmount3::RmtdAmt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RemittanceAmount3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RemittanceAmount3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemittanceAmount3 * SOAP_FMAC4 soap_in_ns1__RemittanceAmount3(struct soap *soap, const char *tag, ns1__RemittanceAmount3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemittanceAmount3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceAmount3, sizeof(ns1__RemittanceAmount3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RemittanceAmount3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RemittanceAmount3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DuePyblAmt1 = 1;
	size_t soap_flag_CdtNoteAmt1 = 1;
	size_t soap_flag_RmtdAmt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DuePyblAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "DuePyblAmt", &a->ns1__RemittanceAmount3::DuePyblAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_DuePyblAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, "DscntApldAmt", &a->ns1__RemittanceAmount3::DscntApldAmt, "ns1:DiscountAmountAndType1"))
					continue;
			}
			if (soap_flag_CdtNoteAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "CdtNoteAmt", &a->ns1__RemittanceAmount3::CdtNoteAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_CdtNoteAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, "TaxAmt", &a->ns1__RemittanceAmount3::TaxAmt, "ns1:TaxAmountAndType1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, "AdjstmntAmtAndRsn", &a->ns1__RemittanceAmount3::AdjstmntAmtAndRsn, "ns1:DocumentAdjustment1"))
					continue;
			}
			if (soap_flag_RmtdAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", &a->ns1__RemittanceAmount3::RmtdAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_RmtdAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RemittanceAmount3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceAmount3, SOAP_TYPE_ns1__RemittanceAmount3, sizeof(ns1__RemittanceAmount3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RemittanceAmount3 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceAmount3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemittanceAmount3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RemittanceAmount3 *p;
	size_t k = sizeof(ns1__RemittanceAmount3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RemittanceAmount3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RemittanceAmount3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RemittanceAmount3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RemittanceAmount3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RemittanceAmount3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RemittanceAmount3(soap, tag ? tag : "ns1:RemittanceAmount3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RemittanceAmount3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemittanceAmount3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemittanceAmount3 * SOAP_FMAC4 soap_get_ns1__RemittanceAmount3(struct soap *soap, ns1__RemittanceAmount3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceAmount3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RemittanceAmount2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RemittanceAmount2::DuePyblAmt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, &this->ns1__RemittanceAmount2::DscntApldAmt);
	this->ns1__RemittanceAmount2::CdtNoteAmt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, &this->ns1__RemittanceAmount2::TaxAmt);
	soap_default_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, &this->ns1__RemittanceAmount2::AdjstmntAmtAndRsn);
	this->ns1__RemittanceAmount2::RmtdAmt = NULL;
}

void ns1__RemittanceAmount2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount2::DuePyblAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, &this->ns1__RemittanceAmount2::DscntApldAmt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount2::CdtNoteAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, &this->ns1__RemittanceAmount2::TaxAmt);
	soap_serialize_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, &this->ns1__RemittanceAmount2::AdjstmntAmtAndRsn);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__RemittanceAmount2::RmtdAmt);
#endif
}

int ns1__RemittanceAmount2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemittanceAmount2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemittanceAmount2(struct soap *soap, const char *tag, int id, const ns1__RemittanceAmount2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemittanceAmount2), type))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "DuePyblAmt", -1, &a->ns1__RemittanceAmount2::DuePyblAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, "DscntApldAmt", -1, &a->ns1__RemittanceAmount2::DscntApldAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "CdtNoteAmt", -1, &a->ns1__RemittanceAmount2::CdtNoteAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, "TaxAmt", -1, &a->ns1__RemittanceAmount2::TaxAmt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, "AdjstmntAmtAndRsn", -1, &a->ns1__RemittanceAmount2::AdjstmntAmtAndRsn, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", -1, &a->ns1__RemittanceAmount2::RmtdAmt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RemittanceAmount2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RemittanceAmount2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemittanceAmount2 * SOAP_FMAC4 soap_in_ns1__RemittanceAmount2(struct soap *soap, const char *tag, ns1__RemittanceAmount2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemittanceAmount2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemittanceAmount2, sizeof(ns1__RemittanceAmount2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RemittanceAmount2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RemittanceAmount2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DuePyblAmt1 = 1;
	size_t soap_flag_CdtNoteAmt1 = 1;
	size_t soap_flag_RmtdAmt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DuePyblAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "DuePyblAmt", &a->ns1__RemittanceAmount2::DuePyblAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_DuePyblAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap, "DscntApldAmt", &a->ns1__RemittanceAmount2::DscntApldAmt, "ns1:DiscountAmountAndType1"))
					continue;
			}
			if (soap_flag_CdtNoteAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "CdtNoteAmt", &a->ns1__RemittanceAmount2::CdtNoteAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_CdtNoteAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap, "TaxAmt", &a->ns1__RemittanceAmount2::TaxAmt, "ns1:TaxAmountAndType1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap, "AdjstmntAmtAndRsn", &a->ns1__RemittanceAmount2::AdjstmntAmtAndRsn, "ns1:DocumentAdjustment1"))
					continue;
			}
			if (soap_flag_RmtdAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", &a->ns1__RemittanceAmount2::RmtdAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_RmtdAmt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RemittanceAmount2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemittanceAmount2, SOAP_TYPE_ns1__RemittanceAmount2, sizeof(ns1__RemittanceAmount2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RemittanceAmount2 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceAmount2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemittanceAmount2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RemittanceAmount2 *p;
	size_t k = sizeof(ns1__RemittanceAmount2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RemittanceAmount2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RemittanceAmount2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RemittanceAmount2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RemittanceAmount2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RemittanceAmount2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RemittanceAmount2(soap, tag ? tag : "ns1:RemittanceAmount2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RemittanceAmount2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemittanceAmount2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemittanceAmount2 * SOAP_FMAC4 soap_get_ns1__RemittanceAmount2(struct soap *soap, ns1__RemittanceAmount2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemittanceAmount2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RegulatoryReporting3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RegulatoryReporting3::DbtCdtRptgInd = NULL;
	this->ns1__RegulatoryReporting3::Authrty = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap, &this->ns1__RegulatoryReporting3::Dtls);
}

void ns1__RegulatoryReporting3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RegulatoryReportingType1Code(soap, &this->ns1__RegulatoryReporting3::DbtCdtRptgInd);
	soap_serialize_PointerTons1__RegulatoryAuthority2(soap, &this->ns1__RegulatoryReporting3::Authrty);
	soap_serialize_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap, &this->ns1__RegulatoryReporting3::Dtls);
#endif
}

int ns1__RegulatoryReporting3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RegulatoryReporting3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegulatoryReporting3(struct soap *soap, const char *tag, int id, const ns1__RegulatoryReporting3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegulatoryReporting3), type))
		return soap->error;
	if (soap_out_PointerTons1__RegulatoryReportingType1Code(soap, "DbtCdtRptgInd", -1, &a->ns1__RegulatoryReporting3::DbtCdtRptgInd, ""))
		return soap->error;
	if (soap_out_PointerTons1__RegulatoryAuthority2(soap, "Authrty", -1, &a->ns1__RegulatoryReporting3::Authrty, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap, "Dtls", -1, &a->ns1__RegulatoryReporting3::Dtls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RegulatoryReporting3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RegulatoryReporting3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RegulatoryReporting3 * SOAP_FMAC4 soap_in_ns1__RegulatoryReporting3(struct soap *soap, const char *tag, ns1__RegulatoryReporting3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RegulatoryReporting3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegulatoryReporting3, sizeof(ns1__RegulatoryReporting3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RegulatoryReporting3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RegulatoryReporting3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DbtCdtRptgInd1 = 1;
	size_t soap_flag_Authrty1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbtCdtRptgInd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RegulatoryReportingType1Code(soap, "DbtCdtRptgInd", &a->ns1__RegulatoryReporting3::DbtCdtRptgInd, "ns1:RegulatoryReportingType1Code"))
				{	soap_flag_DbtCdtRptgInd1--;
					continue;
				}
			}
			if (soap_flag_Authrty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RegulatoryAuthority2(soap, "Authrty", &a->ns1__RegulatoryReporting3::Authrty, "ns1:RegulatoryAuthority2"))
				{	soap_flag_Authrty1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap, "Dtls", &a->ns1__RegulatoryReporting3::Dtls, "ns1:StructuredRegulatoryReporting3"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RegulatoryReporting3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegulatoryReporting3, SOAP_TYPE_ns1__RegulatoryReporting3, sizeof(ns1__RegulatoryReporting3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RegulatoryReporting3 * SOAP_FMAC2 soap_instantiate_ns1__RegulatoryReporting3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RegulatoryReporting3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RegulatoryReporting3 *p;
	size_t k = sizeof(ns1__RegulatoryReporting3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RegulatoryReporting3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RegulatoryReporting3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RegulatoryReporting3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RegulatoryReporting3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RegulatoryReporting3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RegulatoryReporting3(soap, tag ? tag : "ns1:RegulatoryReporting3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RegulatoryReporting3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RegulatoryReporting3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RegulatoryReporting3 * SOAP_FMAC4 soap_get_ns1__RegulatoryReporting3(struct soap *soap, ns1__RegulatoryReporting3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegulatoryReporting3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RegulatoryAuthority2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RegulatoryAuthority2::Nm = NULL;
	this->ns1__RegulatoryAuthority2::Ctry = NULL;
}

void ns1__RegulatoryAuthority2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__RegulatoryAuthority2::Nm);
	soap_serialize_PointerTons1__CountryCode(soap, &this->ns1__RegulatoryAuthority2::Ctry);
#endif
}

int ns1__RegulatoryAuthority2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RegulatoryAuthority2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegulatoryAuthority2(struct soap *soap, const char *tag, int id, const ns1__RegulatoryAuthority2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegulatoryAuthority2), type))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__RegulatoryAuthority2::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryCode(soap, "Ctry", -1, &a->ns1__RegulatoryAuthority2::Ctry, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RegulatoryAuthority2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RegulatoryAuthority2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RegulatoryAuthority2 * SOAP_FMAC4 soap_in_ns1__RegulatoryAuthority2(struct soap *soap, const char *tag, ns1__RegulatoryAuthority2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RegulatoryAuthority2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegulatoryAuthority2, sizeof(ns1__RegulatoryAuthority2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RegulatoryAuthority2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RegulatoryAuthority2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_Ctry1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__RegulatoryAuthority2::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_Ctry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__CountryCode(soap, "Ctry", &a->ns1__RegulatoryAuthority2::Ctry, "ns1:CountryCode"))
				{	soap_flag_Ctry1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RegulatoryAuthority2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegulatoryAuthority2, SOAP_TYPE_ns1__RegulatoryAuthority2, sizeof(ns1__RegulatoryAuthority2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RegulatoryAuthority2 * SOAP_FMAC2 soap_instantiate_ns1__RegulatoryAuthority2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RegulatoryAuthority2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RegulatoryAuthority2 *p;
	size_t k = sizeof(ns1__RegulatoryAuthority2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RegulatoryAuthority2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RegulatoryAuthority2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RegulatoryAuthority2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RegulatoryAuthority2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RegulatoryAuthority2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RegulatoryAuthority2(soap, tag ? tag : "ns1:RegulatoryAuthority2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RegulatoryAuthority2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RegulatoryAuthority2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RegulatoryAuthority2 * SOAP_FMAC4 soap_get_ns1__RegulatoryAuthority2(struct soap *soap, ns1__RegulatoryAuthority2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegulatoryAuthority2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ReferredDocumentType4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ReferredDocumentType4::CdOrPrtry = NULL;
	this->ns1__ReferredDocumentType4::Issr = NULL;
}

void ns1__ReferredDocumentType4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ReferredDocumentType3Choice(soap, &this->ns1__ReferredDocumentType4::CdOrPrtry);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__ReferredDocumentType4::Issr);
#endif
}

int ns1__ReferredDocumentType4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReferredDocumentType4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReferredDocumentType4(struct soap *soap, const char *tag, int id, const ns1__ReferredDocumentType4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReferredDocumentType4), type))
		return soap->error;
	if (!a->ns1__ReferredDocumentType4::CdOrPrtry)
	{	if (soap_element_empty(soap, "CdOrPrtry", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ReferredDocumentType3Choice(soap, "CdOrPrtry", -1, &a->ns1__ReferredDocumentType4::CdOrPrtry, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__ReferredDocumentType4::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ReferredDocumentType4::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ReferredDocumentType4(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReferredDocumentType4 * SOAP_FMAC4 soap_in_ns1__ReferredDocumentType4(struct soap *soap, const char *tag, ns1__ReferredDocumentType4 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReferredDocumentType4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReferredDocumentType4, sizeof(ns1__ReferredDocumentType4), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReferredDocumentType4)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ReferredDocumentType4 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CdOrPrtry1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CdOrPrtry1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ReferredDocumentType3Choice(soap, "CdOrPrtry", &a->ns1__ReferredDocumentType4::CdOrPrtry, "ns1:ReferredDocumentType3Choice"))
				{	soap_flag_CdOrPrtry1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__ReferredDocumentType4::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReferredDocumentType4::CdOrPrtry))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ReferredDocumentType4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReferredDocumentType4, SOAP_TYPE_ns1__ReferredDocumentType4, sizeof(ns1__ReferredDocumentType4), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ReferredDocumentType4 * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentType4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReferredDocumentType4(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReferredDocumentType4 *p;
	size_t k = sizeof(ns1__ReferredDocumentType4);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ReferredDocumentType4, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ReferredDocumentType4);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ReferredDocumentType4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReferredDocumentType4 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ReferredDocumentType4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReferredDocumentType4(soap, tag ? tag : "ns1:ReferredDocumentType4", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReferredDocumentType4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReferredDocumentType4(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReferredDocumentType4 * SOAP_FMAC4 soap_get_ns1__ReferredDocumentType4(struct soap *soap, ns1__ReferredDocumentType4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReferredDocumentType4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ReferredDocumentType3Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ReferredDocumentType3Choice::__union_ReferredDocumentType3Choice = 0;
}

void ns1__ReferredDocumentType3Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ReferredDocumentType3Choice(soap, this->ns1__ReferredDocumentType3Choice::__union_ReferredDocumentType3Choice, &this->ns1__ReferredDocumentType3Choice::union_ReferredDocumentType3Choice);
#endif
}

int ns1__ReferredDocumentType3Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReferredDocumentType3Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReferredDocumentType3Choice(struct soap *soap, const char *tag, int id, const ns1__ReferredDocumentType3Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReferredDocumentType3Choice), type))
		return soap->error;
	if (soap_out__ns1__union_ReferredDocumentType3Choice(soap, a->ns1__ReferredDocumentType3Choice::__union_ReferredDocumentType3Choice, &a->ns1__ReferredDocumentType3Choice::union_ReferredDocumentType3Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ReferredDocumentType3Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ReferredDocumentType3Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReferredDocumentType3Choice * SOAP_FMAC4 soap_in_ns1__ReferredDocumentType3Choice(struct soap *soap, const char *tag, ns1__ReferredDocumentType3Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReferredDocumentType3Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReferredDocumentType3Choice, sizeof(ns1__ReferredDocumentType3Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ReferredDocumentType3Choice(soap, &a->__union_ReferredDocumentType3Choice, &a->union_ReferredDocumentType3Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ReferredDocumentType3Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReferredDocumentType3Choice, SOAP_TYPE_ns1__ReferredDocumentType3Choice, sizeof(ns1__ReferredDocumentType3Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ReferredDocumentType3Choice * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentType3Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReferredDocumentType3Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReferredDocumentType3Choice *p;
	size_t k = sizeof(ns1__ReferredDocumentType3Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ReferredDocumentType3Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ReferredDocumentType3Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ReferredDocumentType3Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReferredDocumentType3Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ReferredDocumentType3Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReferredDocumentType3Choice(soap, tag ? tag : "ns1:ReferredDocumentType3Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReferredDocumentType3Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReferredDocumentType3Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReferredDocumentType3Choice * SOAP_FMAC4 soap_get_ns1__ReferredDocumentType3Choice(struct soap *soap, ns1__ReferredDocumentType3Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReferredDocumentType3Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ReferredDocumentInformation7::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ReferredDocumentInformation7::Tp = NULL;
	this->ns1__ReferredDocumentInformation7::Nb = NULL;
	this->ns1__ReferredDocumentInformation7::RltdDt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap, &this->ns1__ReferredDocumentInformation7::LineDtls);
}

void ns1__ReferredDocumentInformation7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ReferredDocumentType4(soap, &this->ns1__ReferredDocumentInformation7::Tp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__ReferredDocumentInformation7::Nb);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__ReferredDocumentInformation7::RltdDt);
	soap_serialize_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap, &this->ns1__ReferredDocumentInformation7::LineDtls);
#endif
}

int ns1__ReferredDocumentInformation7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReferredDocumentInformation7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReferredDocumentInformation7(struct soap *soap, const char *tag, int id, const ns1__ReferredDocumentInformation7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReferredDocumentInformation7), type))
		return soap->error;
	if (soap_out_PointerTons1__ReferredDocumentType4(soap, "Tp", -1, &a->ns1__ReferredDocumentInformation7::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Nb", -1, &a->ns1__ReferredDocumentInformation7::Nb, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "RltdDt", -1, &a->ns1__ReferredDocumentInformation7::RltdDt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap, "LineDtls", -1, &a->ns1__ReferredDocumentInformation7::LineDtls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ReferredDocumentInformation7::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ReferredDocumentInformation7(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReferredDocumentInformation7 * SOAP_FMAC4 soap_in_ns1__ReferredDocumentInformation7(struct soap *soap, const char *tag, ns1__ReferredDocumentInformation7 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReferredDocumentInformation7*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReferredDocumentInformation7, sizeof(ns1__ReferredDocumentInformation7), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReferredDocumentInformation7)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ReferredDocumentInformation7 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Nb1 = 1;
	size_t soap_flag_RltdDt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ReferredDocumentType4(soap, "Tp", &a->ns1__ReferredDocumentInformation7::Tp, "ns1:ReferredDocumentType4"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Nb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Nb", &a->ns1__ReferredDocumentInformation7::Nb, "ns1:Max35Text"))
				{	soap_flag_Nb1--;
					continue;
				}
			}
			if (soap_flag_RltdDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "RltdDt", &a->ns1__ReferredDocumentInformation7::RltdDt, "ns1:ISODate"))
				{	soap_flag_RltdDt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap, "LineDtls", &a->ns1__ReferredDocumentInformation7::LineDtls, "ns1:DocumentLineInformation1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReferredDocumentInformation7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReferredDocumentInformation7, SOAP_TYPE_ns1__ReferredDocumentInformation7, sizeof(ns1__ReferredDocumentInformation7), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ReferredDocumentInformation7 * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentInformation7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReferredDocumentInformation7(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReferredDocumentInformation7 *p;
	size_t k = sizeof(ns1__ReferredDocumentInformation7);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ReferredDocumentInformation7, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ReferredDocumentInformation7);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ReferredDocumentInformation7, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReferredDocumentInformation7 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ReferredDocumentInformation7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReferredDocumentInformation7(soap, tag ? tag : "ns1:ReferredDocumentInformation7", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReferredDocumentInformation7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReferredDocumentInformation7(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReferredDocumentInformation7 * SOAP_FMAC4 soap_get_ns1__ReferredDocumentInformation7(struct soap *soap, ns1__ReferredDocumentInformation7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReferredDocumentInformation7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Purpose2Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Purpose2Choice::__union_Purpose2Choice = 0;
}

void ns1__Purpose2Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_Purpose2Choice(soap, this->ns1__Purpose2Choice::__union_Purpose2Choice, &this->ns1__Purpose2Choice::union_Purpose2Choice);
#endif
}

int ns1__Purpose2Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Purpose2Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Purpose2Choice(struct soap *soap, const char *tag, int id, const ns1__Purpose2Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Purpose2Choice), type))
		return soap->error;
	if (soap_out__ns1__union_Purpose2Choice(soap, a->ns1__Purpose2Choice::__union_Purpose2Choice, &a->ns1__Purpose2Choice::union_Purpose2Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Purpose2Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Purpose2Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Purpose2Choice * SOAP_FMAC4 soap_in_ns1__Purpose2Choice(struct soap *soap, const char *tag, ns1__Purpose2Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Purpose2Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Purpose2Choice, sizeof(ns1__Purpose2Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_Purpose2Choice(soap, &a->__union_Purpose2Choice, &a->union_Purpose2Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__Purpose2Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Purpose2Choice, SOAP_TYPE_ns1__Purpose2Choice, sizeof(ns1__Purpose2Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Purpose2Choice * SOAP_FMAC2 soap_instantiate_ns1__Purpose2Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Purpose2Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Purpose2Choice *p;
	size_t k = sizeof(ns1__Purpose2Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Purpose2Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Purpose2Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Purpose2Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Purpose2Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Purpose2Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Purpose2Choice(soap, tag ? tag : "ns1:Purpose2Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Purpose2Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Purpose2Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Purpose2Choice * SOAP_FMAC4 soap_get_ns1__Purpose2Choice(struct soap *soap, ns1__Purpose2Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Purpose2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ProxyAccountType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ProxyAccountType1Choice::__union_ProxyAccountType1Choice = 0;
}

void ns1__ProxyAccountType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ProxyAccountType1Choice(soap, this->ns1__ProxyAccountType1Choice::__union_ProxyAccountType1Choice, &this->ns1__ProxyAccountType1Choice::union_ProxyAccountType1Choice);
#endif
}

int ns1__ProxyAccountType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProxyAccountType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProxyAccountType1Choice(struct soap *soap, const char *tag, int id, const ns1__ProxyAccountType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProxyAccountType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_ProxyAccountType1Choice(soap, a->ns1__ProxyAccountType1Choice::__union_ProxyAccountType1Choice, &a->ns1__ProxyAccountType1Choice::union_ProxyAccountType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ProxyAccountType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ProxyAccountType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProxyAccountType1Choice * SOAP_FMAC4 soap_in_ns1__ProxyAccountType1Choice(struct soap *soap, const char *tag, ns1__ProxyAccountType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProxyAccountType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProxyAccountType1Choice, sizeof(ns1__ProxyAccountType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ProxyAccountType1Choice(soap, &a->__union_ProxyAccountType1Choice, &a->union_ProxyAccountType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ProxyAccountType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProxyAccountType1Choice, SOAP_TYPE_ns1__ProxyAccountType1Choice, sizeof(ns1__ProxyAccountType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ProxyAccountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__ProxyAccountType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProxyAccountType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ProxyAccountType1Choice *p;
	size_t k = sizeof(ns1__ProxyAccountType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ProxyAccountType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ProxyAccountType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ProxyAccountType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ProxyAccountType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ProxyAccountType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ProxyAccountType1Choice(soap, tag ? tag : "ns1:ProxyAccountType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ProxyAccountType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProxyAccountType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProxyAccountType1Choice * SOAP_FMAC4 soap_get_ns1__ProxyAccountType1Choice(struct soap *soap, ns1__ProxyAccountType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProxyAccountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ProxyAccountIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ProxyAccountIdentification1::Tp = NULL;
	soap_default_ns1__Max2048Text(soap, &this->ns1__ProxyAccountIdentification1::Id);
}

void ns1__ProxyAccountIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ProxyAccountType1Choice(soap, &this->ns1__ProxyAccountIdentification1::Tp);
	soap_embedded(soap, &this->ns1__ProxyAccountIdentification1::Id, SOAP_TYPE_ns1__Max2048Text);
	soap_serialize_ns1__Max2048Text(soap, &this->ns1__ProxyAccountIdentification1::Id);
#endif
}

int ns1__ProxyAccountIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProxyAccountIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProxyAccountIdentification1(struct soap *soap, const char *tag, int id, const ns1__ProxyAccountIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProxyAccountIdentification1), type))
		return soap->error;
	if (soap_out_PointerTons1__ProxyAccountType1Choice(soap, "Tp", -1, &a->ns1__ProxyAccountIdentification1::Tp, ""))
		return soap->error;
	if (soap_out_ns1__Max2048Text(soap, "Id", -1, &a->ns1__ProxyAccountIdentification1::Id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ProxyAccountIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ProxyAccountIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProxyAccountIdentification1 * SOAP_FMAC4 soap_in_ns1__ProxyAccountIdentification1(struct soap *soap, const char *tag, ns1__ProxyAccountIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProxyAccountIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProxyAccountIdentification1, sizeof(ns1__ProxyAccountIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ProxyAccountIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ProxyAccountIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Id1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProxyAccountType1Choice(soap, "Tp", &a->ns1__ProxyAccountIdentification1::Tp, "ns1:ProxyAccountType1Choice"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max2048Text(soap, "Id", &a->ns1__ProxyAccountIdentification1::Id, "ns1:Max2048Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ProxyAccountIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProxyAccountIdentification1, SOAP_TYPE_ns1__ProxyAccountIdentification1, sizeof(ns1__ProxyAccountIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ProxyAccountIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__ProxyAccountIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProxyAccountIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ProxyAccountIdentification1 *p;
	size_t k = sizeof(ns1__ProxyAccountIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ProxyAccountIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ProxyAccountIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ProxyAccountIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ProxyAccountIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ProxyAccountIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ProxyAccountIdentification1(soap, tag ? tag : "ns1:ProxyAccountIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ProxyAccountIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProxyAccountIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProxyAccountIdentification1 * SOAP_FMAC4 soap_get_ns1__ProxyAccountIdentification1(struct soap *soap, ns1__ProxyAccountIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProxyAccountIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PostalAddress24::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PostalAddress24::AdrTp = NULL;
	this->ns1__PostalAddress24::Dept = NULL;
	this->ns1__PostalAddress24::SubDept = NULL;
	this->ns1__PostalAddress24::StrtNm = NULL;
	this->ns1__PostalAddress24::BldgNb = NULL;
	this->ns1__PostalAddress24::BldgNm = NULL;
	this->ns1__PostalAddress24::Flr = NULL;
	this->ns1__PostalAddress24::PstBx = NULL;
	this->ns1__PostalAddress24::Room = NULL;
	this->ns1__PostalAddress24::PstCd = NULL;
	this->ns1__PostalAddress24::TwnNm = NULL;
	this->ns1__PostalAddress24::TwnLctnNm = NULL;
	this->ns1__PostalAddress24::DstrctNm = NULL;
	this->ns1__PostalAddress24::CtrySubDvsn = NULL;
	this->ns1__PostalAddress24::Ctry = NULL;
	soap_default_std__vectorTemplateOfns1__Max70Text(soap, &this->ns1__PostalAddress24::AdrLine);
}

void ns1__PostalAddress24::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AddressType3Choice(soap, &this->ns1__PostalAddress24::AdrTp);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__PostalAddress24::Dept);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__PostalAddress24::SubDept);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__PostalAddress24::StrtNm);
	soap_serialize_PointerTons1__Max16Text(soap, &this->ns1__PostalAddress24::BldgNb);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PostalAddress24::BldgNm);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__PostalAddress24::Flr);
	soap_serialize_PointerTons1__Max16Text(soap, &this->ns1__PostalAddress24::PstBx);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__PostalAddress24::Room);
	soap_serialize_PointerTons1__Max16Text(soap, &this->ns1__PostalAddress24::PstCd);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PostalAddress24::TwnNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PostalAddress24::TwnLctnNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PostalAddress24::DstrctNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PostalAddress24::CtrySubDvsn);
	soap_serialize_PointerTons1__CountryCode(soap, &this->ns1__PostalAddress24::Ctry);
	soap_serialize_std__vectorTemplateOfns1__Max70Text(soap, &this->ns1__PostalAddress24::AdrLine);
#endif
}

int ns1__PostalAddress24::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PostalAddress24(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PostalAddress24(struct soap *soap, const char *tag, int id, const ns1__PostalAddress24 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PostalAddress24), type))
		return soap->error;
	if (soap_out_PointerTons1__AddressType3Choice(soap, "AdrTp", -1, &a->ns1__PostalAddress24::AdrTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "Dept", -1, &a->ns1__PostalAddress24::Dept, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "SubDept", -1, &a->ns1__PostalAddress24::SubDept, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "StrtNm", -1, &a->ns1__PostalAddress24::StrtNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max16Text(soap, "BldgNb", -1, &a->ns1__PostalAddress24::BldgNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "BldgNm", -1, &a->ns1__PostalAddress24::BldgNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "Flr", -1, &a->ns1__PostalAddress24::Flr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max16Text(soap, "PstBx", -1, &a->ns1__PostalAddress24::PstBx, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "Room", -1, &a->ns1__PostalAddress24::Room, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max16Text(soap, "PstCd", -1, &a->ns1__PostalAddress24::PstCd, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TwnNm", -1, &a->ns1__PostalAddress24::TwnNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "TwnLctnNm", -1, &a->ns1__PostalAddress24::TwnLctnNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "DstrctNm", -1, &a->ns1__PostalAddress24::DstrctNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "CtrySubDvsn", -1, &a->ns1__PostalAddress24::CtrySubDvsn, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryCode(soap, "Ctry", -1, &a->ns1__PostalAddress24::Ctry, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max70Text(soap, "AdrLine", -1, &a->ns1__PostalAddress24::AdrLine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PostalAddress24::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PostalAddress24(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PostalAddress24 * SOAP_FMAC4 soap_in_ns1__PostalAddress24(struct soap *soap, const char *tag, ns1__PostalAddress24 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PostalAddress24*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddress24, sizeof(ns1__PostalAddress24), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PostalAddress24)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PostalAddress24 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AdrTp1 = 1;
	size_t soap_flag_Dept1 = 1;
	size_t soap_flag_SubDept1 = 1;
	size_t soap_flag_StrtNm1 = 1;
	size_t soap_flag_BldgNb1 = 1;
	size_t soap_flag_BldgNm1 = 1;
	size_t soap_flag_Flr1 = 1;
	size_t soap_flag_PstBx1 = 1;
	size_t soap_flag_Room1 = 1;
	size_t soap_flag_PstCd1 = 1;
	size_t soap_flag_TwnNm1 = 1;
	size_t soap_flag_TwnLctnNm1 = 1;
	size_t soap_flag_DstrctNm1 = 1;
	size_t soap_flag_CtrySubDvsn1 = 1;
	size_t soap_flag_Ctry1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdrTp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AddressType3Choice(soap, "AdrTp", &a->ns1__PostalAddress24::AdrTp, "ns1:AddressType3Choice"))
				{	soap_flag_AdrTp1--;
					continue;
				}
			}
			if (soap_flag_Dept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "Dept", &a->ns1__PostalAddress24::Dept, "ns1:Max70Text"))
				{	soap_flag_Dept1--;
					continue;
				}
			}
			if (soap_flag_SubDept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "SubDept", &a->ns1__PostalAddress24::SubDept, "ns1:Max70Text"))
				{	soap_flag_SubDept1--;
					continue;
				}
			}
			if (soap_flag_StrtNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "StrtNm", &a->ns1__PostalAddress24::StrtNm, "ns1:Max70Text"))
				{	soap_flag_StrtNm1--;
					continue;
				}
			}
			if (soap_flag_BldgNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max16Text(soap, "BldgNb", &a->ns1__PostalAddress24::BldgNb, "ns1:Max16Text"))
				{	soap_flag_BldgNb1--;
					continue;
				}
			}
			if (soap_flag_BldgNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "BldgNm", &a->ns1__PostalAddress24::BldgNm, "ns1:Max35Text"))
				{	soap_flag_BldgNm1--;
					continue;
				}
			}
			if (soap_flag_Flr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "Flr", &a->ns1__PostalAddress24::Flr, "ns1:Max70Text"))
				{	soap_flag_Flr1--;
					continue;
				}
			}
			if (soap_flag_PstBx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max16Text(soap, "PstBx", &a->ns1__PostalAddress24::PstBx, "ns1:Max16Text"))
				{	soap_flag_PstBx1--;
					continue;
				}
			}
			if (soap_flag_Room1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "Room", &a->ns1__PostalAddress24::Room, "ns1:Max70Text"))
				{	soap_flag_Room1--;
					continue;
				}
			}
			if (soap_flag_PstCd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max16Text(soap, "PstCd", &a->ns1__PostalAddress24::PstCd, "ns1:Max16Text"))
				{	soap_flag_PstCd1--;
					continue;
				}
			}
			if (soap_flag_TwnNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TwnNm", &a->ns1__PostalAddress24::TwnNm, "ns1:Max35Text"))
				{	soap_flag_TwnNm1--;
					continue;
				}
			}
			if (soap_flag_TwnLctnNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "TwnLctnNm", &a->ns1__PostalAddress24::TwnLctnNm, "ns1:Max35Text"))
				{	soap_flag_TwnLctnNm1--;
					continue;
				}
			}
			if (soap_flag_DstrctNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "DstrctNm", &a->ns1__PostalAddress24::DstrctNm, "ns1:Max35Text"))
				{	soap_flag_DstrctNm1--;
					continue;
				}
			}
			if (soap_flag_CtrySubDvsn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "CtrySubDvsn", &a->ns1__PostalAddress24::CtrySubDvsn, "ns1:Max35Text"))
				{	soap_flag_CtrySubDvsn1--;
					continue;
				}
			}
			if (soap_flag_Ctry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__CountryCode(soap, "Ctry", &a->ns1__PostalAddress24::Ctry, "ns1:CountryCode"))
				{	soap_flag_Ctry1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max70Text(soap, "AdrLine", &a->ns1__PostalAddress24::AdrLine, "ns1:Max70Text"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__PostalAddress24::AdrLine.size() > 7))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__PostalAddress24 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PostalAddress24, SOAP_TYPE_ns1__PostalAddress24, sizeof(ns1__PostalAddress24), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PostalAddress24 * SOAP_FMAC2 soap_instantiate_ns1__PostalAddress24(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PostalAddress24(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PostalAddress24 *p;
	size_t k = sizeof(ns1__PostalAddress24);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PostalAddress24, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PostalAddress24);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PostalAddress24, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PostalAddress24 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PostalAddress24::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PostalAddress24(soap, tag ? tag : "ns1:PostalAddress24", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PostalAddress24::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PostalAddress24(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PostalAddress24 * SOAP_FMAC4 soap_get_ns1__PostalAddress24(struct soap *soap, ns1__PostalAddress24 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PostalAddress24(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PersonIdentificationSchemeName1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PersonIdentificationSchemeName1Choice::__union_PersonIdentificationSchemeName1Choice = 0;
}

void ns1__PersonIdentificationSchemeName1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_PersonIdentificationSchemeName1Choice(soap, this->ns1__PersonIdentificationSchemeName1Choice::__union_PersonIdentificationSchemeName1Choice, &this->ns1__PersonIdentificationSchemeName1Choice::union_PersonIdentificationSchemeName1Choice);
#endif
}

int ns1__PersonIdentificationSchemeName1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PersonIdentificationSchemeName1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PersonIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, const ns1__PersonIdentificationSchemeName1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_PersonIdentificationSchemeName1Choice(soap, a->ns1__PersonIdentificationSchemeName1Choice::__union_PersonIdentificationSchemeName1Choice, &a->ns1__PersonIdentificationSchemeName1Choice::union_PersonIdentificationSchemeName1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PersonIdentificationSchemeName1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PersonIdentificationSchemeName1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PersonIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in_ns1__PersonIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__PersonIdentificationSchemeName1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PersonIdentificationSchemeName1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, sizeof(ns1__PersonIdentificationSchemeName1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_PersonIdentificationSchemeName1Choice(soap, &a->__union_PersonIdentificationSchemeName1Choice, &a->union_PersonIdentificationSchemeName1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__PersonIdentificationSchemeName1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, sizeof(ns1__PersonIdentificationSchemeName1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PersonIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__PersonIdentificationSchemeName1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PersonIdentificationSchemeName1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PersonIdentificationSchemeName1Choice *p;
	size_t k = sizeof(ns1__PersonIdentificationSchemeName1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PersonIdentificationSchemeName1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PersonIdentificationSchemeName1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PersonIdentificationSchemeName1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PersonIdentificationSchemeName1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PersonIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:PersonIdentificationSchemeName1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PersonIdentificationSchemeName1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PersonIdentificationSchemeName1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PersonIdentificationSchemeName1Choice * SOAP_FMAC4 soap_get_ns1__PersonIdentificationSchemeName1Choice(struct soap *soap, ns1__PersonIdentificationSchemeName1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PersonIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PersonIdentification13::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PersonIdentification13::DtAndPlcOfBirth = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap, &this->ns1__PersonIdentification13::Othr);
}

void ns1__PersonIdentification13::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DateAndPlaceOfBirth1(soap, &this->ns1__PersonIdentification13::DtAndPlcOfBirth);
	soap_serialize_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap, &this->ns1__PersonIdentification13::Othr);
#endif
}

int ns1__PersonIdentification13::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PersonIdentification13(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PersonIdentification13(struct soap *soap, const char *tag, int id, const ns1__PersonIdentification13 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PersonIdentification13), type))
		return soap->error;
	if (soap_out_PointerTons1__DateAndPlaceOfBirth1(soap, "DtAndPlcOfBirth", -1, &a->ns1__PersonIdentification13::DtAndPlcOfBirth, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap, "Othr", -1, &a->ns1__PersonIdentification13::Othr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PersonIdentification13::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PersonIdentification13(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PersonIdentification13 * SOAP_FMAC4 soap_in_ns1__PersonIdentification13(struct soap *soap, const char *tag, ns1__PersonIdentification13 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PersonIdentification13*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PersonIdentification13, sizeof(ns1__PersonIdentification13), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PersonIdentification13)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PersonIdentification13 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DtAndPlcOfBirth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DtAndPlcOfBirth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateAndPlaceOfBirth1(soap, "DtAndPlcOfBirth", &a->ns1__PersonIdentification13::DtAndPlcOfBirth, "ns1:DateAndPlaceOfBirth1"))
				{	soap_flag_DtAndPlcOfBirth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap, "Othr", &a->ns1__PersonIdentification13::Othr, "ns1:GenericPersonIdentification1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PersonIdentification13 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PersonIdentification13, SOAP_TYPE_ns1__PersonIdentification13, sizeof(ns1__PersonIdentification13), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PersonIdentification13 * SOAP_FMAC2 soap_instantiate_ns1__PersonIdentification13(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PersonIdentification13(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PersonIdentification13 *p;
	size_t k = sizeof(ns1__PersonIdentification13);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PersonIdentification13, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PersonIdentification13);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PersonIdentification13, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PersonIdentification13 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PersonIdentification13::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PersonIdentification13(soap, tag ? tag : "ns1:PersonIdentification13", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PersonIdentification13::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PersonIdentification13(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PersonIdentification13 * SOAP_FMAC4 soap_get_ns1__PersonIdentification13(struct soap *soap, ns1__PersonIdentification13 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PersonIdentification13(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PaymentTypeInformation26::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PaymentTypeInformation26::InstrPrty = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap, &this->ns1__PaymentTypeInformation26::SvcLvl);
	this->ns1__PaymentTypeInformation26::LclInstrm = NULL;
	this->ns1__PaymentTypeInformation26::CtgyPurp = NULL;
}

void ns1__PaymentTypeInformation26::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Priority2Code(soap, &this->ns1__PaymentTypeInformation26::InstrPrty);
	soap_serialize_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap, &this->ns1__PaymentTypeInformation26::SvcLvl);
	soap_serialize_PointerTons1__LocalInstrument2Choice(soap, &this->ns1__PaymentTypeInformation26::LclInstrm);
	soap_serialize_PointerTons1__CategoryPurpose1Choice(soap, &this->ns1__PaymentTypeInformation26::CtgyPurp);
#endif
}

int ns1__PaymentTypeInformation26::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PaymentTypeInformation26(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentTypeInformation26(struct soap *soap, const char *tag, int id, const ns1__PaymentTypeInformation26 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentTypeInformation26), type))
		return soap->error;
	if (soap_out_PointerTons1__Priority2Code(soap, "InstrPrty", -1, &a->ns1__PaymentTypeInformation26::InstrPrty, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap, "SvcLvl", -1, &a->ns1__PaymentTypeInformation26::SvcLvl, ""))
		return soap->error;
	if (soap_out_PointerTons1__LocalInstrument2Choice(soap, "LclInstrm", -1, &a->ns1__PaymentTypeInformation26::LclInstrm, ""))
		return soap->error;
	if (soap_out_PointerTons1__CategoryPurpose1Choice(soap, "CtgyPurp", -1, &a->ns1__PaymentTypeInformation26::CtgyPurp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PaymentTypeInformation26::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PaymentTypeInformation26(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PaymentTypeInformation26 * SOAP_FMAC4 soap_in_ns1__PaymentTypeInformation26(struct soap *soap, const char *tag, ns1__PaymentTypeInformation26 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PaymentTypeInformation26*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentTypeInformation26, sizeof(ns1__PaymentTypeInformation26), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PaymentTypeInformation26)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PaymentTypeInformation26 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InstrPrty1 = 1;
	size_t soap_flag_LclInstrm1 = 1;
	size_t soap_flag_CtgyPurp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InstrPrty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Priority2Code(soap, "InstrPrty", &a->ns1__PaymentTypeInformation26::InstrPrty, "ns1:Priority2Code"))
				{	soap_flag_InstrPrty1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap, "SvcLvl", &a->ns1__PaymentTypeInformation26::SvcLvl, "ns1:ServiceLevel8Choice"))
					continue;
			}
			if (soap_flag_LclInstrm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LocalInstrument2Choice(soap, "LclInstrm", &a->ns1__PaymentTypeInformation26::LclInstrm, "ns1:LocalInstrument2Choice"))
				{	soap_flag_LclInstrm1--;
					continue;
				}
			}
			if (soap_flag_CtgyPurp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CategoryPurpose1Choice(soap, "CtgyPurp", &a->ns1__PaymentTypeInformation26::CtgyPurp, "ns1:CategoryPurpose1Choice"))
				{	soap_flag_CtgyPurp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PaymentTypeInformation26 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentTypeInformation26, SOAP_TYPE_ns1__PaymentTypeInformation26, sizeof(ns1__PaymentTypeInformation26), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PaymentTypeInformation26 * SOAP_FMAC2 soap_instantiate_ns1__PaymentTypeInformation26(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PaymentTypeInformation26(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PaymentTypeInformation26 *p;
	size_t k = sizeof(ns1__PaymentTypeInformation26);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PaymentTypeInformation26, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PaymentTypeInformation26);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PaymentTypeInformation26, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PaymentTypeInformation26 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PaymentTypeInformation26::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PaymentTypeInformation26(soap, tag ? tag : "ns1:PaymentTypeInformation26", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PaymentTypeInformation26::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PaymentTypeInformation26(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PaymentTypeInformation26 * SOAP_FMAC4 soap_get_ns1__PaymentTypeInformation26(struct soap *soap, ns1__PaymentTypeInformation26 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentTypeInformation26(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PaymentInstruction40::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max35Text(soap, &this->ns1__PaymentInstruction40::PmtInfId);
	soap_default_ns1__PaymentMethod3Code(soap, &this->ns1__PaymentInstruction40::PmtMtd);
	this->ns1__PaymentInstruction40::ReqdAdvcTp = NULL;
	this->ns1__PaymentInstruction40::BtchBookg = NULL;
	this->ns1__PaymentInstruction40::NbOfTxs = NULL;
	this->ns1__PaymentInstruction40::CtrlSum = NULL;
	this->ns1__PaymentInstruction40::PmtTpInf = NULL;
	this->ns1__PaymentInstruction40::ReqdExctnDt = NULL;
	this->ns1__PaymentInstruction40::PoolgAdjstmntDt = NULL;
	this->ns1__PaymentInstruction40::Dbtr = NULL;
	this->ns1__PaymentInstruction40::DbtrAcct = NULL;
	this->ns1__PaymentInstruction40::DbtrAgt = NULL;
	this->ns1__PaymentInstruction40::DbtrAgtAcct = NULL;
	this->ns1__PaymentInstruction40::InstrForDbtrAgt = NULL;
	this->ns1__PaymentInstruction40::UltmtDbtr = NULL;
	this->ns1__PaymentInstruction40::ChrgBr = NULL;
	this->ns1__PaymentInstruction40::ChrgsAcct = NULL;
	this->ns1__PaymentInstruction40::ChrgsAcctAgt = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap, &this->ns1__PaymentInstruction40::CdtTrfTxInf);
}

void ns1__PaymentInstruction40::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__PaymentInstruction40::PmtInfId, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__PaymentInstruction40::PmtInfId);
	soap_serialize_PointerTons1__AdviceType1(soap, &this->ns1__PaymentInstruction40::ReqdAdvcTp);
	soap_serialize_PointerTons1__BatchBookingIndicator(soap, &this->ns1__PaymentInstruction40::BtchBookg);
	soap_serialize_PointerTons1__Max15NumericText(soap, &this->ns1__PaymentInstruction40::NbOfTxs);
	soap_serialize_PointerTons1__DecimalNumber(soap, &this->ns1__PaymentInstruction40::CtrlSum);
	soap_serialize_PointerTons1__PaymentTypeInformation26(soap, &this->ns1__PaymentInstruction40::PmtTpInf);
	soap_serialize_PointerTons1__DateAndDateTime2Choice(soap, &this->ns1__PaymentInstruction40::ReqdExctnDt);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__PaymentInstruction40::PoolgAdjstmntDt);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__PaymentInstruction40::Dbtr);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__PaymentInstruction40::DbtrAcct);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__PaymentInstruction40::DbtrAgt);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__PaymentInstruction40::DbtrAgtAcct);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__PaymentInstruction40::InstrForDbtrAgt);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__PaymentInstruction40::UltmtDbtr);
	soap_serialize_PointerTons1__ChargeBearerType1Code(soap, &this->ns1__PaymentInstruction40::ChrgBr);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__PaymentInstruction40::ChrgsAcct);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__PaymentInstruction40::ChrgsAcctAgt);
	soap_serialize_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap, &this->ns1__PaymentInstruction40::CdtTrfTxInf);
#endif
}

int ns1__PaymentInstruction40::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PaymentInstruction40(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentInstruction40(struct soap *soap, const char *tag, int id, const ns1__PaymentInstruction40 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentInstruction40), type))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "PmtInfId", -1, &a->ns1__PaymentInstruction40::PmtInfId, ""))
		return soap->error;
	if (soap_out_ns1__PaymentMethod3Code(soap, "PmtMtd", -1, &a->ns1__PaymentInstruction40::PmtMtd, ""))
		return soap->error;
	if (soap_out_PointerTons1__AdviceType1(soap, "ReqdAdvcTp", -1, &a->ns1__PaymentInstruction40::ReqdAdvcTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__BatchBookingIndicator(soap, "BtchBookg", -1, &a->ns1__PaymentInstruction40::BtchBookg, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max15NumericText(soap, "NbOfTxs", -1, &a->ns1__PaymentInstruction40::NbOfTxs, ""))
		return soap->error;
	if (soap_out_PointerTons1__DecimalNumber(soap, "CtrlSum", -1, &a->ns1__PaymentInstruction40::CtrlSum, ""))
		return soap->error;
	if (soap_out_PointerTons1__PaymentTypeInformation26(soap, "PmtTpInf", -1, &a->ns1__PaymentInstruction40::PmtTpInf, ""))
		return soap->error;
	if (!a->ns1__PaymentInstruction40::ReqdExctnDt)
	{	if (soap_element_empty(soap, "ReqdExctnDt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__DateAndDateTime2Choice(soap, "ReqdExctnDt", -1, &a->ns1__PaymentInstruction40::ReqdExctnDt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "PoolgAdjstmntDt", -1, &a->ns1__PaymentInstruction40::PoolgAdjstmntDt, ""))
		return soap->error;
	if (!a->ns1__PaymentInstruction40::Dbtr)
	{	if (soap_element_empty(soap, "Dbtr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__PartyIdentification135(soap, "Dbtr", -1, &a->ns1__PaymentInstruction40::Dbtr, ""))
		return soap->error;
	if (!a->ns1__PaymentInstruction40::DbtrAcct)
	{	if (soap_element_empty(soap, "DbtrAcct", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__CashAccount40(soap, "DbtrAcct", -1, &a->ns1__PaymentInstruction40::DbtrAcct, ""))
		return soap->error;
	if (!a->ns1__PaymentInstruction40::DbtrAgt)
	{	if (soap_element_empty(soap, "DbtrAgt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "DbtrAgt", -1, &a->ns1__PaymentInstruction40::DbtrAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "DbtrAgtAcct", -1, &a->ns1__PaymentInstruction40::DbtrAgtAcct, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "InstrForDbtrAgt", -1, &a->ns1__PaymentInstruction40::InstrForDbtrAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "UltmtDbtr", -1, &a->ns1__PaymentInstruction40::UltmtDbtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__ChargeBearerType1Code(soap, "ChrgBr", -1, &a->ns1__PaymentInstruction40::ChrgBr, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "ChrgsAcct", -1, &a->ns1__PaymentInstruction40::ChrgsAcct, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "ChrgsAcctAgt", -1, &a->ns1__PaymentInstruction40::ChrgsAcctAgt, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap, "CdtTrfTxInf", -1, &a->ns1__PaymentInstruction40::CdtTrfTxInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PaymentInstruction40::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PaymentInstruction40(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PaymentInstruction40 * SOAP_FMAC4 soap_in_ns1__PaymentInstruction40(struct soap *soap, const char *tag, ns1__PaymentInstruction40 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PaymentInstruction40*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentInstruction40, sizeof(ns1__PaymentInstruction40), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PaymentInstruction40)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PaymentInstruction40 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PmtInfId1 = 1;
	size_t soap_flag_PmtMtd1 = 1;
	size_t soap_flag_ReqdAdvcTp1 = 1;
	size_t soap_flag_BtchBookg1 = 1;
	size_t soap_flag_NbOfTxs1 = 1;
	size_t soap_flag_CtrlSum1 = 1;
	size_t soap_flag_PmtTpInf1 = 1;
	size_t soap_flag_ReqdExctnDt1 = 1;
	size_t soap_flag_PoolgAdjstmntDt1 = 1;
	size_t soap_flag_Dbtr1 = 1;
	size_t soap_flag_DbtrAcct1 = 1;
	size_t soap_flag_DbtrAgt1 = 1;
	size_t soap_flag_DbtrAgtAcct1 = 1;
	size_t soap_flag_InstrForDbtrAgt1 = 1;
	size_t soap_flag_UltmtDbtr1 = 1;
	size_t soap_flag_ChrgBr1 = 1;
	size_t soap_flag_ChrgsAcct1 = 1;
	size_t soap_flag_ChrgsAcctAgt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PmtInfId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "PmtInfId", &a->ns1__PaymentInstruction40::PmtInfId, "ns1:Max35Text"))
				{	soap_flag_PmtInfId1--;
					continue;
				}
			}
			if (soap_flag_PmtMtd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__PaymentMethod3Code(soap, "PmtMtd", &a->ns1__PaymentInstruction40::PmtMtd, "ns1:PaymentMethod3Code"))
				{	soap_flag_PmtMtd1--;
					continue;
				}
			}
			if (soap_flag_ReqdAdvcTp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AdviceType1(soap, "ReqdAdvcTp", &a->ns1__PaymentInstruction40::ReqdAdvcTp, "ns1:AdviceType1"))
				{	soap_flag_ReqdAdvcTp1--;
					continue;
				}
			}
			if (soap_flag_BtchBookg1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BatchBookingIndicator(soap, "BtchBookg", &a->ns1__PaymentInstruction40::BtchBookg, "ns1:BatchBookingIndicator"))
				{	soap_flag_BtchBookg1--;
					continue;
				}
			}
			if (soap_flag_NbOfTxs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max15NumericText(soap, "NbOfTxs", &a->ns1__PaymentInstruction40::NbOfTxs, "ns1:Max15NumericText"))
				{	soap_flag_NbOfTxs1--;
					continue;
				}
			}
			if (soap_flag_CtrlSum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__DecimalNumber(soap, "CtrlSum", &a->ns1__PaymentInstruction40::CtrlSum, "ns1:DecimalNumber"))
				{	soap_flag_CtrlSum1--;
					continue;
				}
			}
			if (soap_flag_PmtTpInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PaymentTypeInformation26(soap, "PmtTpInf", &a->ns1__PaymentInstruction40::PmtTpInf, "ns1:PaymentTypeInformation26"))
				{	soap_flag_PmtTpInf1--;
					continue;
				}
			}
			if (soap_flag_ReqdExctnDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateAndDateTime2Choice(soap, "ReqdExctnDt", &a->ns1__PaymentInstruction40::ReqdExctnDt, "ns1:DateAndDateTime2Choice"))
				{	soap_flag_ReqdExctnDt1--;
					continue;
				}
			}
			if (soap_flag_PoolgAdjstmntDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "PoolgAdjstmntDt", &a->ns1__PaymentInstruction40::PoolgAdjstmntDt, "ns1:ISODate"))
				{	soap_flag_PoolgAdjstmntDt1--;
					continue;
				}
			}
			if (soap_flag_Dbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "Dbtr", &a->ns1__PaymentInstruction40::Dbtr, "ns1:PartyIdentification135"))
				{	soap_flag_Dbtr1--;
					continue;
				}
			}
			if (soap_flag_DbtrAcct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "DbtrAcct", &a->ns1__PaymentInstruction40::DbtrAcct, "ns1:CashAccount40"))
				{	soap_flag_DbtrAcct1--;
					continue;
				}
			}
			if (soap_flag_DbtrAgt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "DbtrAgt", &a->ns1__PaymentInstruction40::DbtrAgt, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_DbtrAgt1--;
					continue;
				}
			}
			if (soap_flag_DbtrAgtAcct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "DbtrAgtAcct", &a->ns1__PaymentInstruction40::DbtrAgtAcct, "ns1:CashAccount40"))
				{	soap_flag_DbtrAgtAcct1--;
					continue;
				}
			}
			if (soap_flag_InstrForDbtrAgt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "InstrForDbtrAgt", &a->ns1__PaymentInstruction40::InstrForDbtrAgt, "ns1:Max140Text"))
				{	soap_flag_InstrForDbtrAgt1--;
					continue;
				}
			}
			if (soap_flag_UltmtDbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "UltmtDbtr", &a->ns1__PaymentInstruction40::UltmtDbtr, "ns1:PartyIdentification135"))
				{	soap_flag_UltmtDbtr1--;
					continue;
				}
			}
			if (soap_flag_ChrgBr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ChargeBearerType1Code(soap, "ChrgBr", &a->ns1__PaymentInstruction40::ChrgBr, "ns1:ChargeBearerType1Code"))
				{	soap_flag_ChrgBr1--;
					continue;
				}
			}
			if (soap_flag_ChrgsAcct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "ChrgsAcct", &a->ns1__PaymentInstruction40::ChrgsAcct, "ns1:CashAccount40"))
				{	soap_flag_ChrgsAcct1--;
					continue;
				}
			}
			if (soap_flag_ChrgsAcctAgt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "ChrgsAcctAgt", &a->ns1__PaymentInstruction40::ChrgsAcctAgt, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_ChrgsAcctAgt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap, "CdtTrfTxInf", &a->ns1__PaymentInstruction40::CdtTrfTxInf, "ns1:CreditTransferTransaction54"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PmtInfId1 > 0 || soap_flag_PmtMtd1 > 0 || !a->ns1__PaymentInstruction40::ReqdExctnDt || !a->ns1__PaymentInstruction40::Dbtr || !a->ns1__PaymentInstruction40::DbtrAcct || !a->ns1__PaymentInstruction40::DbtrAgt || a->ns1__PaymentInstruction40::CdtTrfTxInf.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PaymentInstruction40 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentInstruction40, SOAP_TYPE_ns1__PaymentInstruction40, sizeof(ns1__PaymentInstruction40), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PaymentInstruction40 * SOAP_FMAC2 soap_instantiate_ns1__PaymentInstruction40(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PaymentInstruction40(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PaymentInstruction40 *p;
	size_t k = sizeof(ns1__PaymentInstruction40);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PaymentInstruction40, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PaymentInstruction40);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PaymentInstruction40, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PaymentInstruction40 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PaymentInstruction40::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PaymentInstruction40(soap, tag ? tag : "ns1:PaymentInstruction40", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PaymentInstruction40::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PaymentInstruction40(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PaymentInstruction40 * SOAP_FMAC4 soap_get_ns1__PaymentInstruction40(struct soap *soap, ns1__PaymentInstruction40 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentInstruction40(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PaymentInitiationSource1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max140Text(soap, &this->ns1__PaymentInitiationSource1::Nm);
	this->ns1__PaymentInitiationSource1::Prvdr = NULL;
	this->ns1__PaymentInitiationSource1::Vrsn = NULL;
}

void ns1__PaymentInitiationSource1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__PaymentInitiationSource1::Nm, SOAP_TYPE_ns1__Max140Text);
	soap_serialize_ns1__Max140Text(soap, &this->ns1__PaymentInitiationSource1::Nm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PaymentInitiationSource1::Prvdr);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PaymentInitiationSource1::Vrsn);
#endif
}

int ns1__PaymentInitiationSource1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PaymentInitiationSource1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentInitiationSource1(struct soap *soap, const char *tag, int id, const ns1__PaymentInitiationSource1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentInitiationSource1), type))
		return soap->error;
	if (soap_out_ns1__Max140Text(soap, "Nm", -1, &a->ns1__PaymentInitiationSource1::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Prvdr", -1, &a->ns1__PaymentInitiationSource1::Prvdr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Vrsn", -1, &a->ns1__PaymentInitiationSource1::Vrsn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PaymentInitiationSource1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PaymentInitiationSource1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PaymentInitiationSource1 * SOAP_FMAC4 soap_in_ns1__PaymentInitiationSource1(struct soap *soap, const char *tag, ns1__PaymentInitiationSource1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PaymentInitiationSource1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentInitiationSource1, sizeof(ns1__PaymentInitiationSource1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PaymentInitiationSource1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PaymentInitiationSource1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_Prvdr1 = 1;
	size_t soap_flag_Vrsn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max140Text(soap, "Nm", &a->ns1__PaymentInitiationSource1::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_Prvdr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Prvdr", &a->ns1__PaymentInitiationSource1::Prvdr, "ns1:Max35Text"))
				{	soap_flag_Prvdr1--;
					continue;
				}
			}
			if (soap_flag_Vrsn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Vrsn", &a->ns1__PaymentInitiationSource1::Vrsn, "ns1:Max35Text"))
				{	soap_flag_Vrsn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Nm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PaymentInitiationSource1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentInitiationSource1, SOAP_TYPE_ns1__PaymentInitiationSource1, sizeof(ns1__PaymentInitiationSource1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PaymentInitiationSource1 * SOAP_FMAC2 soap_instantiate_ns1__PaymentInitiationSource1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PaymentInitiationSource1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PaymentInitiationSource1 *p;
	size_t k = sizeof(ns1__PaymentInitiationSource1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PaymentInitiationSource1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PaymentInitiationSource1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PaymentInitiationSource1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PaymentInitiationSource1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PaymentInitiationSource1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PaymentInitiationSource1(soap, tag ? tag : "ns1:PaymentInitiationSource1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PaymentInitiationSource1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PaymentInitiationSource1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PaymentInitiationSource1 * SOAP_FMAC4 soap_get_ns1__PaymentInitiationSource1(struct soap *soap, ns1__PaymentInitiationSource1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentInitiationSource1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PaymentIdentification6::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PaymentIdentification6::InstrId = NULL;
	soap_default_ns1__Max35Text(soap, &this->ns1__PaymentIdentification6::EndToEndId);
	this->ns1__PaymentIdentification6::UETR = NULL;
}

void ns1__PaymentIdentification6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__PaymentIdentification6::InstrId);
	soap_embedded(soap, &this->ns1__PaymentIdentification6::EndToEndId, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__PaymentIdentification6::EndToEndId);
	soap_serialize_PointerTons1__UUIDv4Identifier(soap, &this->ns1__PaymentIdentification6::UETR);
#endif
}

int ns1__PaymentIdentification6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PaymentIdentification6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentIdentification6(struct soap *soap, const char *tag, int id, const ns1__PaymentIdentification6 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentIdentification6), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "InstrId", -1, &a->ns1__PaymentIdentification6::InstrId, ""))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "EndToEndId", -1, &a->ns1__PaymentIdentification6::EndToEndId, ""))
		return soap->error;
	if (soap_out_PointerTons1__UUIDv4Identifier(soap, "UETR", -1, &a->ns1__PaymentIdentification6::UETR, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PaymentIdentification6::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PaymentIdentification6(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PaymentIdentification6 * SOAP_FMAC4 soap_in_ns1__PaymentIdentification6(struct soap *soap, const char *tag, ns1__PaymentIdentification6 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PaymentIdentification6*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentIdentification6, sizeof(ns1__PaymentIdentification6), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PaymentIdentification6)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PaymentIdentification6 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InstrId1 = 1;
	size_t soap_flag_EndToEndId1 = 1;
	size_t soap_flag_UETR1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InstrId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "InstrId", &a->ns1__PaymentIdentification6::InstrId, "ns1:Max35Text"))
				{	soap_flag_InstrId1--;
					continue;
				}
			}
			if (soap_flag_EndToEndId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "EndToEndId", &a->ns1__PaymentIdentification6::EndToEndId, "ns1:Max35Text"))
				{	soap_flag_EndToEndId1--;
					continue;
				}
			}
			if (soap_flag_UETR1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__UUIDv4Identifier(soap, "UETR", &a->ns1__PaymentIdentification6::UETR, "ns1:UUIDv4Identifier"))
				{	soap_flag_UETR1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EndToEndId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PaymentIdentification6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentIdentification6, SOAP_TYPE_ns1__PaymentIdentification6, sizeof(ns1__PaymentIdentification6), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PaymentIdentification6 * SOAP_FMAC2 soap_instantiate_ns1__PaymentIdentification6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PaymentIdentification6(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PaymentIdentification6 *p;
	size_t k = sizeof(ns1__PaymentIdentification6);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PaymentIdentification6, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PaymentIdentification6);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PaymentIdentification6, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PaymentIdentification6 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PaymentIdentification6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PaymentIdentification6(soap, tag ? tag : "ns1:PaymentIdentification6", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PaymentIdentification6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PaymentIdentification6(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PaymentIdentification6 * SOAP_FMAC4 soap_get_ns1__PaymentIdentification6(struct soap *soap, ns1__PaymentIdentification6 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentIdentification6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PartyIdentification135::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PartyIdentification135::Nm = NULL;
	this->ns1__PartyIdentification135::PstlAdr = NULL;
	this->ns1__PartyIdentification135::Id = NULL;
	this->ns1__PartyIdentification135::CtryOfRes = NULL;
	this->ns1__PartyIdentification135::CtctDtls = NULL;
}

void ns1__PartyIdentification135::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__PartyIdentification135::Nm);
	soap_serialize_PointerTons1__PostalAddress24(soap, &this->ns1__PartyIdentification135::PstlAdr);
	soap_serialize_PointerTons1__Party38Choice(soap, &this->ns1__PartyIdentification135::Id);
	soap_serialize_PointerTons1__CountryCode(soap, &this->ns1__PartyIdentification135::CtryOfRes);
	soap_serialize_PointerTons1__Contact4(soap, &this->ns1__PartyIdentification135::CtctDtls);
#endif
}

int ns1__PartyIdentification135::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PartyIdentification135(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PartyIdentification135(struct soap *soap, const char *tag, int id, const ns1__PartyIdentification135 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PartyIdentification135), type))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__PartyIdentification135::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__PostalAddress24(soap, "PstlAdr", -1, &a->ns1__PartyIdentification135::PstlAdr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Party38Choice(soap, "Id", -1, &a->ns1__PartyIdentification135::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryCode(soap, "CtryOfRes", -1, &a->ns1__PartyIdentification135::CtryOfRes, ""))
		return soap->error;
	if (soap_out_PointerTons1__Contact4(soap, "CtctDtls", -1, &a->ns1__PartyIdentification135::CtctDtls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PartyIdentification135::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PartyIdentification135(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PartyIdentification135 * SOAP_FMAC4 soap_in_ns1__PartyIdentification135(struct soap *soap, const char *tag, ns1__PartyIdentification135 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PartyIdentification135*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PartyIdentification135, sizeof(ns1__PartyIdentification135), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PartyIdentification135)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PartyIdentification135 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_PstlAdr1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_CtryOfRes1 = 1;
	size_t soap_flag_CtctDtls1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__PartyIdentification135::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_PstlAdr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PostalAddress24(soap, "PstlAdr", &a->ns1__PartyIdentification135::PstlAdr, "ns1:PostalAddress24"))
				{	soap_flag_PstlAdr1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Party38Choice(soap, "Id", &a->ns1__PartyIdentification135::Id, "ns1:Party38Choice"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_CtryOfRes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__CountryCode(soap, "CtryOfRes", &a->ns1__PartyIdentification135::CtryOfRes, "ns1:CountryCode"))
				{	soap_flag_CtryOfRes1--;
					continue;
				}
			}
			if (soap_flag_CtctDtls1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Contact4(soap, "CtctDtls", &a->ns1__PartyIdentification135::CtctDtls, "ns1:Contact4"))
				{	soap_flag_CtctDtls1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PartyIdentification135 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PartyIdentification135, SOAP_TYPE_ns1__PartyIdentification135, sizeof(ns1__PartyIdentification135), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PartyIdentification135 * SOAP_FMAC2 soap_instantiate_ns1__PartyIdentification135(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PartyIdentification135(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PartyIdentification135 *p;
	size_t k = sizeof(ns1__PartyIdentification135);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PartyIdentification135, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PartyIdentification135);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PartyIdentification135, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PartyIdentification135 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PartyIdentification135::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PartyIdentification135(soap, tag ? tag : "ns1:PartyIdentification135", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PartyIdentification135::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PartyIdentification135(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PartyIdentification135 * SOAP_FMAC4 soap_get_ns1__PartyIdentification135(struct soap *soap, ns1__PartyIdentification135 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PartyIdentification135(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Party38Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Party38Choice::__union_Party38Choice = 0;
}

void ns1__Party38Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_Party38Choice(soap, this->ns1__Party38Choice::__union_Party38Choice, &this->ns1__Party38Choice::union_Party38Choice);
#endif
}

int ns1__Party38Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Party38Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Party38Choice(struct soap *soap, const char *tag, int id, const ns1__Party38Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Party38Choice), type))
		return soap->error;
	if (soap_out__ns1__union_Party38Choice(soap, a->ns1__Party38Choice::__union_Party38Choice, &a->ns1__Party38Choice::union_Party38Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Party38Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Party38Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Party38Choice * SOAP_FMAC4 soap_in_ns1__Party38Choice(struct soap *soap, const char *tag, ns1__Party38Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Party38Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Party38Choice, sizeof(ns1__Party38Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_Party38Choice(soap, &a->__union_Party38Choice, &a->union_Party38Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__Party38Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Party38Choice, SOAP_TYPE_ns1__Party38Choice, sizeof(ns1__Party38Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Party38Choice * SOAP_FMAC2 soap_instantiate_ns1__Party38Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Party38Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Party38Choice *p;
	size_t k = sizeof(ns1__Party38Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Party38Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Party38Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Party38Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Party38Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Party38Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Party38Choice(soap, tag ? tag : "ns1:Party38Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Party38Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Party38Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Party38Choice * SOAP_FMAC4 soap_get_ns1__Party38Choice(struct soap *soap, ns1__Party38Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Party38Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OtherContact1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max4Text(soap, &this->ns1__OtherContact1::ChanlTp);
	this->ns1__OtherContact1::Id = NULL;
}

void ns1__OtherContact1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__OtherContact1::ChanlTp, SOAP_TYPE_ns1__Max4Text);
	soap_serialize_ns1__Max4Text(soap, &this->ns1__OtherContact1::ChanlTp);
	soap_serialize_PointerTons1__Max128Text(soap, &this->ns1__OtherContact1::Id);
#endif
}

int ns1__OtherContact1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OtherContact1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtherContact1(struct soap *soap, const char *tag, int id, const ns1__OtherContact1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtherContact1), type))
		return soap->error;
	if (soap_out_ns1__Max4Text(soap, "ChanlTp", -1, &a->ns1__OtherContact1::ChanlTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max128Text(soap, "Id", -1, &a->ns1__OtherContact1::Id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OtherContact1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OtherContact1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OtherContact1 * SOAP_FMAC4 soap_in_ns1__OtherContact1(struct soap *soap, const char *tag, ns1__OtherContact1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OtherContact1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtherContact1, sizeof(ns1__OtherContact1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OtherContact1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OtherContact1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChanlTp1 = 1;
	size_t soap_flag_Id1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChanlTp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max4Text(soap, "ChanlTp", &a->ns1__OtherContact1::ChanlTp, "ns1:Max4Text"))
				{	soap_flag_ChanlTp1--;
					continue;
				}
			}
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max128Text(soap, "Id", &a->ns1__OtherContact1::Id, "ns1:Max128Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChanlTp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OtherContact1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtherContact1, SOAP_TYPE_ns1__OtherContact1, sizeof(ns1__OtherContact1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OtherContact1 * SOAP_FMAC2 soap_instantiate_ns1__OtherContact1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OtherContact1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OtherContact1 *p;
	size_t k = sizeof(ns1__OtherContact1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OtherContact1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OtherContact1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OtherContact1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OtherContact1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OtherContact1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OtherContact1(soap, tag ? tag : "ns1:OtherContact1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OtherContact1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OtherContact1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OtherContact1 * SOAP_FMAC4 soap_get_ns1__OtherContact1(struct soap *soap, ns1__OtherContact1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtherContact1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OrganisationIdentificationSchemeName1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__OrganisationIdentificationSchemeName1Choice::__union_OrganisationIdentificationSchemeName1Choice = 0;
}

void ns1__OrganisationIdentificationSchemeName1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_OrganisationIdentificationSchemeName1Choice(soap, this->ns1__OrganisationIdentificationSchemeName1Choice::__union_OrganisationIdentificationSchemeName1Choice, &this->ns1__OrganisationIdentificationSchemeName1Choice::union_OrganisationIdentificationSchemeName1Choice);
#endif
}

int ns1__OrganisationIdentificationSchemeName1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, const ns1__OrganisationIdentificationSchemeName1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_OrganisationIdentificationSchemeName1Choice(soap, a->ns1__OrganisationIdentificationSchemeName1Choice::__union_OrganisationIdentificationSchemeName1Choice, &a->ns1__OrganisationIdentificationSchemeName1Choice::union_OrganisationIdentificationSchemeName1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrganisationIdentificationSchemeName1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrganisationIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in_ns1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__OrganisationIdentificationSchemeName1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrganisationIdentificationSchemeName1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, sizeof(ns1__OrganisationIdentificationSchemeName1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_OrganisationIdentificationSchemeName1Choice(soap, &a->__union_OrganisationIdentificationSchemeName1Choice, &a->union_OrganisationIdentificationSchemeName1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__OrganisationIdentificationSchemeName1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, sizeof(ns1__OrganisationIdentificationSchemeName1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OrganisationIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrganisationIdentificationSchemeName1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OrganisationIdentificationSchemeName1Choice *p;
	size_t k = sizeof(ns1__OrganisationIdentificationSchemeName1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OrganisationIdentificationSchemeName1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OrganisationIdentificationSchemeName1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OrganisationIdentificationSchemeName1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OrganisationIdentificationSchemeName1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:OrganisationIdentificationSchemeName1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrganisationIdentificationSchemeName1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrganisationIdentificationSchemeName1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrganisationIdentificationSchemeName1Choice * SOAP_FMAC4 soap_get_ns1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, ns1__OrganisationIdentificationSchemeName1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrganisationIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OrganisationIdentification29::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__OrganisationIdentification29::AnyBIC = NULL;
	this->ns1__OrganisationIdentification29::LEI = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap, &this->ns1__OrganisationIdentification29::Othr);
}

void ns1__OrganisationIdentification29::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AnyBICDec2014Identifier(soap, &this->ns1__OrganisationIdentification29::AnyBIC);
	soap_serialize_PointerTons1__LEIIdentifier(soap, &this->ns1__OrganisationIdentification29::LEI);
	soap_serialize_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap, &this->ns1__OrganisationIdentification29::Othr);
#endif
}

int ns1__OrganisationIdentification29::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrganisationIdentification29(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrganisationIdentification29(struct soap *soap, const char *tag, int id, const ns1__OrganisationIdentification29 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrganisationIdentification29), type))
		return soap->error;
	if (soap_out_PointerTons1__AnyBICDec2014Identifier(soap, "AnyBIC", -1, &a->ns1__OrganisationIdentification29::AnyBIC, ""))
		return soap->error;
	if (soap_out_PointerTons1__LEIIdentifier(soap, "LEI", -1, &a->ns1__OrganisationIdentification29::LEI, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap, "Othr", -1, &a->ns1__OrganisationIdentification29::Othr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrganisationIdentification29::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OrganisationIdentification29(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrganisationIdentification29 * SOAP_FMAC4 soap_in_ns1__OrganisationIdentification29(struct soap *soap, const char *tag, ns1__OrganisationIdentification29 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrganisationIdentification29*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrganisationIdentification29, sizeof(ns1__OrganisationIdentification29), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OrganisationIdentification29)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OrganisationIdentification29 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnyBIC1 = 1;
	size_t soap_flag_LEI1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnyBIC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__AnyBICDec2014Identifier(soap, "AnyBIC", &a->ns1__OrganisationIdentification29::AnyBIC, "ns1:AnyBICDec2014Identifier"))
				{	soap_flag_AnyBIC1--;
					continue;
				}
			}
			if (soap_flag_LEI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__LEIIdentifier(soap, "LEI", &a->ns1__OrganisationIdentification29::LEI, "ns1:LEIIdentifier"))
				{	soap_flag_LEI1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap, "Othr", &a->ns1__OrganisationIdentification29::Othr, "ns1:GenericOrganisationIdentification1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrganisationIdentification29 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrganisationIdentification29, SOAP_TYPE_ns1__OrganisationIdentification29, sizeof(ns1__OrganisationIdentification29), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OrganisationIdentification29 * SOAP_FMAC2 soap_instantiate_ns1__OrganisationIdentification29(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrganisationIdentification29(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OrganisationIdentification29 *p;
	size_t k = sizeof(ns1__OrganisationIdentification29);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OrganisationIdentification29, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OrganisationIdentification29);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OrganisationIdentification29, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OrganisationIdentification29 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OrganisationIdentification29::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OrganisationIdentification29(soap, tag ? tag : "ns1:OrganisationIdentification29", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrganisationIdentification29::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrganisationIdentification29(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrganisationIdentification29 * SOAP_FMAC4 soap_get_ns1__OrganisationIdentification29(struct soap *soap, ns1__OrganisationIdentification29 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrganisationIdentification29(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NameAndAddress16::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max140Text(soap, &this->ns1__NameAndAddress16::Nm);
	this->ns1__NameAndAddress16::Adr = NULL;
}

void ns1__NameAndAddress16::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NameAndAddress16::Nm, SOAP_TYPE_ns1__Max140Text);
	soap_serialize_ns1__Max140Text(soap, &this->ns1__NameAndAddress16::Nm);
	soap_serialize_PointerTons1__PostalAddress24(soap, &this->ns1__NameAndAddress16::Adr);
#endif
}

int ns1__NameAndAddress16::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NameAndAddress16(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NameAndAddress16(struct soap *soap, const char *tag, int id, const ns1__NameAndAddress16 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NameAndAddress16), type))
		return soap->error;
	if (soap_out_ns1__Max140Text(soap, "Nm", -1, &a->ns1__NameAndAddress16::Nm, ""))
		return soap->error;
	if (!a->ns1__NameAndAddress16::Adr)
	{	if (soap_element_empty(soap, "Adr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__PostalAddress24(soap, "Adr", -1, &a->ns1__NameAndAddress16::Adr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NameAndAddress16::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NameAndAddress16(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NameAndAddress16 * SOAP_FMAC4 soap_in_ns1__NameAndAddress16(struct soap *soap, const char *tag, ns1__NameAndAddress16 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NameAndAddress16*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NameAndAddress16, sizeof(ns1__NameAndAddress16), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NameAndAddress16)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NameAndAddress16 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_Adr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max140Text(soap, "Nm", &a->ns1__NameAndAddress16::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_Adr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PostalAddress24(soap, "Adr", &a->ns1__NameAndAddress16::Adr, "ns1:PostalAddress24"))
				{	soap_flag_Adr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Nm1 > 0 || !a->ns1__NameAndAddress16::Adr))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NameAndAddress16 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NameAndAddress16, SOAP_TYPE_ns1__NameAndAddress16, sizeof(ns1__NameAndAddress16), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NameAndAddress16 * SOAP_FMAC2 soap_instantiate_ns1__NameAndAddress16(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NameAndAddress16(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NameAndAddress16 *p;
	size_t k = sizeof(ns1__NameAndAddress16);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NameAndAddress16, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NameAndAddress16);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NameAndAddress16, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NameAndAddress16 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NameAndAddress16::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NameAndAddress16(soap, tag ? tag : "ns1:NameAndAddress16", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NameAndAddress16::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NameAndAddress16(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NameAndAddress16 * SOAP_FMAC4 soap_get_ns1__NameAndAddress16(struct soap *soap, ns1__NameAndAddress16 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NameAndAddress16(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MandateTypeInformation2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MandateTypeInformation2::SvcLvl = NULL;
	this->ns1__MandateTypeInformation2::LclInstrm = NULL;
	this->ns1__MandateTypeInformation2::CtgyPurp = NULL;
	this->ns1__MandateTypeInformation2::Clssfctn = NULL;
}

void ns1__MandateTypeInformation2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ServiceLevel8Choice(soap, &this->ns1__MandateTypeInformation2::SvcLvl);
	soap_serialize_PointerTons1__LocalInstrument2Choice(soap, &this->ns1__MandateTypeInformation2::LclInstrm);
	soap_serialize_PointerTons1__CategoryPurpose1Choice(soap, &this->ns1__MandateTypeInformation2::CtgyPurp);
	soap_serialize_PointerTons1__MandateClassification1Choice(soap, &this->ns1__MandateTypeInformation2::Clssfctn);
#endif
}

int ns1__MandateTypeInformation2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MandateTypeInformation2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MandateTypeInformation2(struct soap *soap, const char *tag, int id, const ns1__MandateTypeInformation2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MandateTypeInformation2), type))
		return soap->error;
	if (soap_out_PointerTons1__ServiceLevel8Choice(soap, "SvcLvl", -1, &a->ns1__MandateTypeInformation2::SvcLvl, ""))
		return soap->error;
	if (soap_out_PointerTons1__LocalInstrument2Choice(soap, "LclInstrm", -1, &a->ns1__MandateTypeInformation2::LclInstrm, ""))
		return soap->error;
	if (soap_out_PointerTons1__CategoryPurpose1Choice(soap, "CtgyPurp", -1, &a->ns1__MandateTypeInformation2::CtgyPurp, ""))
		return soap->error;
	if (soap_out_PointerTons1__MandateClassification1Choice(soap, "Clssfctn", -1, &a->ns1__MandateTypeInformation2::Clssfctn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MandateTypeInformation2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MandateTypeInformation2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MandateTypeInformation2 * SOAP_FMAC4 soap_in_ns1__MandateTypeInformation2(struct soap *soap, const char *tag, ns1__MandateTypeInformation2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MandateTypeInformation2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MandateTypeInformation2, sizeof(ns1__MandateTypeInformation2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MandateTypeInformation2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MandateTypeInformation2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SvcLvl1 = 1;
	size_t soap_flag_LclInstrm1 = 1;
	size_t soap_flag_CtgyPurp1 = 1;
	size_t soap_flag_Clssfctn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SvcLvl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ServiceLevel8Choice(soap, "SvcLvl", &a->ns1__MandateTypeInformation2::SvcLvl, "ns1:ServiceLevel8Choice"))
				{	soap_flag_SvcLvl1--;
					continue;
				}
			}
			if (soap_flag_LclInstrm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LocalInstrument2Choice(soap, "LclInstrm", &a->ns1__MandateTypeInformation2::LclInstrm, "ns1:LocalInstrument2Choice"))
				{	soap_flag_LclInstrm1--;
					continue;
				}
			}
			if (soap_flag_CtgyPurp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CategoryPurpose1Choice(soap, "CtgyPurp", &a->ns1__MandateTypeInformation2::CtgyPurp, "ns1:CategoryPurpose1Choice"))
				{	soap_flag_CtgyPurp1--;
					continue;
				}
			}
			if (soap_flag_Clssfctn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MandateClassification1Choice(soap, "Clssfctn", &a->ns1__MandateTypeInformation2::Clssfctn, "ns1:MandateClassification1Choice"))
				{	soap_flag_Clssfctn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MandateTypeInformation2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MandateTypeInformation2, SOAP_TYPE_ns1__MandateTypeInformation2, sizeof(ns1__MandateTypeInformation2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MandateTypeInformation2 * SOAP_FMAC2 soap_instantiate_ns1__MandateTypeInformation2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MandateTypeInformation2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MandateTypeInformation2 *p;
	size_t k = sizeof(ns1__MandateTypeInformation2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MandateTypeInformation2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MandateTypeInformation2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MandateTypeInformation2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MandateTypeInformation2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MandateTypeInformation2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MandateTypeInformation2(soap, tag ? tag : "ns1:MandateTypeInformation2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MandateTypeInformation2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MandateTypeInformation2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MandateTypeInformation2 * SOAP_FMAC4 soap_get_ns1__MandateTypeInformation2(struct soap *soap, ns1__MandateTypeInformation2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MandateTypeInformation2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MandateSetupReason1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MandateSetupReason1Choice::__union_MandateSetupReason1Choice = 0;
}

void ns1__MandateSetupReason1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_MandateSetupReason1Choice(soap, this->ns1__MandateSetupReason1Choice::__union_MandateSetupReason1Choice, &this->ns1__MandateSetupReason1Choice::union_MandateSetupReason1Choice);
#endif
}

int ns1__MandateSetupReason1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MandateSetupReason1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MandateSetupReason1Choice(struct soap *soap, const char *tag, int id, const ns1__MandateSetupReason1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MandateSetupReason1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_MandateSetupReason1Choice(soap, a->ns1__MandateSetupReason1Choice::__union_MandateSetupReason1Choice, &a->ns1__MandateSetupReason1Choice::union_MandateSetupReason1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MandateSetupReason1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MandateSetupReason1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MandateSetupReason1Choice * SOAP_FMAC4 soap_in_ns1__MandateSetupReason1Choice(struct soap *soap, const char *tag, ns1__MandateSetupReason1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MandateSetupReason1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MandateSetupReason1Choice, sizeof(ns1__MandateSetupReason1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_MandateSetupReason1Choice(soap, &a->__union_MandateSetupReason1Choice, &a->union_MandateSetupReason1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__MandateSetupReason1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MandateSetupReason1Choice, SOAP_TYPE_ns1__MandateSetupReason1Choice, sizeof(ns1__MandateSetupReason1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MandateSetupReason1Choice * SOAP_FMAC2 soap_instantiate_ns1__MandateSetupReason1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MandateSetupReason1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MandateSetupReason1Choice *p;
	size_t k = sizeof(ns1__MandateSetupReason1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MandateSetupReason1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MandateSetupReason1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MandateSetupReason1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MandateSetupReason1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MandateSetupReason1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MandateSetupReason1Choice(soap, tag ? tag : "ns1:MandateSetupReason1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MandateSetupReason1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MandateSetupReason1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MandateSetupReason1Choice * SOAP_FMAC4 soap_get_ns1__MandateSetupReason1Choice(struct soap *soap, ns1__MandateSetupReason1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MandateSetupReason1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MandateClassification1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MandateClassification1Choice::__union_MandateClassification1Choice = 0;
}

void ns1__MandateClassification1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_MandateClassification1Choice(soap, this->ns1__MandateClassification1Choice::__union_MandateClassification1Choice, &this->ns1__MandateClassification1Choice::union_MandateClassification1Choice);
#endif
}

int ns1__MandateClassification1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MandateClassification1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MandateClassification1Choice(struct soap *soap, const char *tag, int id, const ns1__MandateClassification1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MandateClassification1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_MandateClassification1Choice(soap, a->ns1__MandateClassification1Choice::__union_MandateClassification1Choice, &a->ns1__MandateClassification1Choice::union_MandateClassification1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MandateClassification1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MandateClassification1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MandateClassification1Choice * SOAP_FMAC4 soap_in_ns1__MandateClassification1Choice(struct soap *soap, const char *tag, ns1__MandateClassification1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MandateClassification1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MandateClassification1Choice, sizeof(ns1__MandateClassification1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_MandateClassification1Choice(soap, &a->__union_MandateClassification1Choice, &a->union_MandateClassification1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__MandateClassification1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MandateClassification1Choice, SOAP_TYPE_ns1__MandateClassification1Choice, sizeof(ns1__MandateClassification1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MandateClassification1Choice * SOAP_FMAC2 soap_instantiate_ns1__MandateClassification1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MandateClassification1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MandateClassification1Choice *p;
	size_t k = sizeof(ns1__MandateClassification1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MandateClassification1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MandateClassification1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MandateClassification1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MandateClassification1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MandateClassification1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MandateClassification1Choice(soap, tag ? tag : "ns1:MandateClassification1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MandateClassification1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MandateClassification1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MandateClassification1Choice * SOAP_FMAC4 soap_get_ns1__MandateClassification1Choice(struct soap *soap, ns1__MandateClassification1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MandateClassification1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LocalInstrument2Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LocalInstrument2Choice::__union_LocalInstrument2Choice = 0;
}

void ns1__LocalInstrument2Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_LocalInstrument2Choice(soap, this->ns1__LocalInstrument2Choice::__union_LocalInstrument2Choice, &this->ns1__LocalInstrument2Choice::union_LocalInstrument2Choice);
#endif
}

int ns1__LocalInstrument2Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocalInstrument2Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocalInstrument2Choice(struct soap *soap, const char *tag, int id, const ns1__LocalInstrument2Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LocalInstrument2Choice), type))
		return soap->error;
	if (soap_out__ns1__union_LocalInstrument2Choice(soap, a->ns1__LocalInstrument2Choice::__union_LocalInstrument2Choice, &a->ns1__LocalInstrument2Choice::union_LocalInstrument2Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LocalInstrument2Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__LocalInstrument2Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocalInstrument2Choice * SOAP_FMAC4 soap_in_ns1__LocalInstrument2Choice(struct soap *soap, const char *tag, ns1__LocalInstrument2Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LocalInstrument2Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocalInstrument2Choice, sizeof(ns1__LocalInstrument2Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_LocalInstrument2Choice(soap, &a->__union_LocalInstrument2Choice, &a->union_LocalInstrument2Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__LocalInstrument2Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LocalInstrument2Choice, SOAP_TYPE_ns1__LocalInstrument2Choice, sizeof(ns1__LocalInstrument2Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LocalInstrument2Choice * SOAP_FMAC2 soap_instantiate_ns1__LocalInstrument2Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocalInstrument2Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LocalInstrument2Choice *p;
	size_t k = sizeof(ns1__LocalInstrument2Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__LocalInstrument2Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__LocalInstrument2Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__LocalInstrument2Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LocalInstrument2Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__LocalInstrument2Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LocalInstrument2Choice(soap, tag ? tag : "ns1:LocalInstrument2Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LocalInstrument2Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocalInstrument2Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocalInstrument2Choice * SOAP_FMAC4 soap_get_ns1__LocalInstrument2Choice(struct soap *soap, ns1__LocalInstrument2Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocalInstrument2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InstructionForDebtorAgent1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__InstructionForDebtorAgent1::Cd = NULL;
	this->ns1__InstructionForDebtorAgent1::InstrInf = NULL;
}

void ns1__InstructionForDebtorAgent1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, &this->ns1__InstructionForDebtorAgent1::Cd);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__InstructionForDebtorAgent1::InstrInf);
#endif
}

int ns1__InstructionForDebtorAgent1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InstructionForDebtorAgent1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InstructionForDebtorAgent1(struct soap *soap, const char *tag, int id, const ns1__InstructionForDebtorAgent1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InstructionForDebtorAgent1), type))
		return soap->error;
	if (soap_out_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, "Cd", -1, &a->ns1__InstructionForDebtorAgent1::Cd, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "InstrInf", -1, &a->ns1__InstructionForDebtorAgent1::InstrInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InstructionForDebtorAgent1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InstructionForDebtorAgent1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InstructionForDebtorAgent1 * SOAP_FMAC4 soap_in_ns1__InstructionForDebtorAgent1(struct soap *soap, const char *tag, ns1__InstructionForDebtorAgent1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InstructionForDebtorAgent1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InstructionForDebtorAgent1, sizeof(ns1__InstructionForDebtorAgent1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InstructionForDebtorAgent1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InstructionForDebtorAgent1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cd1 = 1;
	size_t soap_flag_InstrInf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, "Cd", &a->ns1__InstructionForDebtorAgent1::Cd, "ns1:ExternalDebtorAgentInstruction1Code"))
				{	soap_flag_Cd1--;
					continue;
				}
			}
			if (soap_flag_InstrInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "InstrInf", &a->ns1__InstructionForDebtorAgent1::InstrInf, "ns1:Max140Text"))
				{	soap_flag_InstrInf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InstructionForDebtorAgent1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InstructionForDebtorAgent1, SOAP_TYPE_ns1__InstructionForDebtorAgent1, sizeof(ns1__InstructionForDebtorAgent1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InstructionForDebtorAgent1 * SOAP_FMAC2 soap_instantiate_ns1__InstructionForDebtorAgent1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InstructionForDebtorAgent1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InstructionForDebtorAgent1 *p;
	size_t k = sizeof(ns1__InstructionForDebtorAgent1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InstructionForDebtorAgent1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InstructionForDebtorAgent1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InstructionForDebtorAgent1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InstructionForDebtorAgent1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InstructionForDebtorAgent1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InstructionForDebtorAgent1(soap, tag ? tag : "ns1:InstructionForDebtorAgent1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InstructionForDebtorAgent1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InstructionForDebtorAgent1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InstructionForDebtorAgent1 * SOAP_FMAC4 soap_get_ns1__InstructionForDebtorAgent1(struct soap *soap, ns1__InstructionForDebtorAgent1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InstructionForDebtorAgent1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InstructionForCreditorAgent3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__InstructionForCreditorAgent3::Cd = NULL;
	this->ns1__InstructionForCreditorAgent3::InstrInf = NULL;
}

void ns1__InstructionForCreditorAgent3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, &this->ns1__InstructionForCreditorAgent3::Cd);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__InstructionForCreditorAgent3::InstrInf);
#endif
}

int ns1__InstructionForCreditorAgent3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InstructionForCreditorAgent3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, int id, const ns1__InstructionForCreditorAgent3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InstructionForCreditorAgent3), type))
		return soap->error;
	if (soap_out_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, "Cd", -1, &a->ns1__InstructionForCreditorAgent3::Cd, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "InstrInf", -1, &a->ns1__InstructionForCreditorAgent3::InstrInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InstructionForCreditorAgent3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InstructionForCreditorAgent3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InstructionForCreditorAgent3 * SOAP_FMAC4 soap_in_ns1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, ns1__InstructionForCreditorAgent3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InstructionForCreditorAgent3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InstructionForCreditorAgent3, sizeof(ns1__InstructionForCreditorAgent3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InstructionForCreditorAgent3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InstructionForCreditorAgent3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cd1 = 1;
	size_t soap_flag_InstrInf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, "Cd", &a->ns1__InstructionForCreditorAgent3::Cd, "ns1:ExternalCreditorAgentInstruction1Code"))
				{	soap_flag_Cd1--;
					continue;
				}
			}
			if (soap_flag_InstrInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "InstrInf", &a->ns1__InstructionForCreditorAgent3::InstrInf, "ns1:Max140Text"))
				{	soap_flag_InstrInf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InstructionForCreditorAgent3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InstructionForCreditorAgent3, SOAP_TYPE_ns1__InstructionForCreditorAgent3, sizeof(ns1__InstructionForCreditorAgent3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InstructionForCreditorAgent3 * SOAP_FMAC2 soap_instantiate_ns1__InstructionForCreditorAgent3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InstructionForCreditorAgent3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InstructionForCreditorAgent3 *p;
	size_t k = sizeof(ns1__InstructionForCreditorAgent3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InstructionForCreditorAgent3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InstructionForCreditorAgent3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InstructionForCreditorAgent3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InstructionForCreditorAgent3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InstructionForCreditorAgent3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InstructionForCreditorAgent3(soap, tag ? tag : "ns1:InstructionForCreditorAgent3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InstructionForCreditorAgent3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InstructionForCreditorAgent3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InstructionForCreditorAgent3 * SOAP_FMAC4 soap_get_ns1__InstructionForCreditorAgent3(struct soap *soap, ns1__InstructionForCreditorAgent3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InstructionForCreditorAgent3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GroupHeader95::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max35Text(soap, &this->ns1__GroupHeader95::MsgId);
	soap_default_ns1__ISODateTime(soap, &this->ns1__GroupHeader95::CreDtTm);
	soap_default_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap, &this->ns1__GroupHeader95::Authstn);
	soap_default_ns1__Max15NumericText(soap, &this->ns1__GroupHeader95::NbOfTxs);
	this->ns1__GroupHeader95::CtrlSum = NULL;
	this->ns1__GroupHeader95::InitgPty = NULL;
	this->ns1__GroupHeader95::FwdgAgt = NULL;
	this->ns1__GroupHeader95::InitnSrc = NULL;
}

void ns1__GroupHeader95::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GroupHeader95::MsgId, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__GroupHeader95::MsgId);
	soap_embedded(soap, &this->ns1__GroupHeader95::CreDtTm, SOAP_TYPE_ns1__ISODateTime);
	soap_serialize_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap, &this->ns1__GroupHeader95::Authstn);
	soap_embedded(soap, &this->ns1__GroupHeader95::NbOfTxs, SOAP_TYPE_ns1__Max15NumericText);
	soap_serialize_ns1__Max15NumericText(soap, &this->ns1__GroupHeader95::NbOfTxs);
	soap_serialize_PointerTons1__DecimalNumber(soap, &this->ns1__GroupHeader95::CtrlSum);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__GroupHeader95::InitgPty);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__GroupHeader95::FwdgAgt);
	soap_serialize_PointerTons1__PaymentInitiationSource1(soap, &this->ns1__GroupHeader95::InitnSrc);
#endif
}

int ns1__GroupHeader95::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GroupHeader95(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GroupHeader95(struct soap *soap, const char *tag, int id, const ns1__GroupHeader95 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GroupHeader95), type))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "MsgId", -1, &a->ns1__GroupHeader95::MsgId, ""))
		return soap->error;
	if (soap_out_ns1__ISODateTime(soap, "CreDtTm", -1, &a->ns1__GroupHeader95::CreDtTm, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap, "Authstn", -1, &a->ns1__GroupHeader95::Authstn, ""))
		return soap->error;
	if (soap_out_ns1__Max15NumericText(soap, "NbOfTxs", -1, &a->ns1__GroupHeader95::NbOfTxs, ""))
		return soap->error;
	if (soap_out_PointerTons1__DecimalNumber(soap, "CtrlSum", -1, &a->ns1__GroupHeader95::CtrlSum, ""))
		return soap->error;
	if (!a->ns1__GroupHeader95::InitgPty)
	{	if (soap_element_empty(soap, "InitgPty", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__PartyIdentification135(soap, "InitgPty", -1, &a->ns1__GroupHeader95::InitgPty, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "FwdgAgt", -1, &a->ns1__GroupHeader95::FwdgAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__PaymentInitiationSource1(soap, "InitnSrc", -1, &a->ns1__GroupHeader95::InitnSrc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GroupHeader95::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GroupHeader95(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GroupHeader95 * SOAP_FMAC4 soap_in_ns1__GroupHeader95(struct soap *soap, const char *tag, ns1__GroupHeader95 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GroupHeader95*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupHeader95, sizeof(ns1__GroupHeader95), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GroupHeader95)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GroupHeader95 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MsgId1 = 1;
	size_t soap_flag_CreDtTm1 = 1;
	size_t soap_flag_NbOfTxs1 = 1;
	size_t soap_flag_CtrlSum1 = 1;
	size_t soap_flag_InitgPty1 = 1;
	size_t soap_flag_FwdgAgt1 = 1;
	size_t soap_flag_InitnSrc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MsgId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "MsgId", &a->ns1__GroupHeader95::MsgId, "ns1:Max35Text"))
				{	soap_flag_MsgId1--;
					continue;
				}
			}
			if (soap_flag_CreDtTm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__ISODateTime(soap, "CreDtTm", &a->ns1__GroupHeader95::CreDtTm, "ns1:ISODateTime"))
				{	soap_flag_CreDtTm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap, "Authstn", &a->ns1__GroupHeader95::Authstn, "ns1:Authorisation1Choice"))
					continue;
			}
			if (soap_flag_NbOfTxs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max15NumericText(soap, "NbOfTxs", &a->ns1__GroupHeader95::NbOfTxs, "ns1:Max15NumericText"))
				{	soap_flag_NbOfTxs1--;
					continue;
				}
			}
			if (soap_flag_CtrlSum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__DecimalNumber(soap, "CtrlSum", &a->ns1__GroupHeader95::CtrlSum, "ns1:DecimalNumber"))
				{	soap_flag_CtrlSum1--;
					continue;
				}
			}
			if (soap_flag_InitgPty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "InitgPty", &a->ns1__GroupHeader95::InitgPty, "ns1:PartyIdentification135"))
				{	soap_flag_InitgPty1--;
					continue;
				}
			}
			if (soap_flag_FwdgAgt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "FwdgAgt", &a->ns1__GroupHeader95::FwdgAgt, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_FwdgAgt1--;
					continue;
				}
			}
			if (soap_flag_InitnSrc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PaymentInitiationSource1(soap, "InitnSrc", &a->ns1__GroupHeader95::InitnSrc, "ns1:PaymentInitiationSource1"))
				{	soap_flag_InitnSrc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MsgId1 > 0 || soap_flag_CreDtTm1 > 0 || a->ns1__GroupHeader95::Authstn.size() > 2 || soap_flag_NbOfTxs1 > 0 || !a->ns1__GroupHeader95::InitgPty))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GroupHeader95 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GroupHeader95, SOAP_TYPE_ns1__GroupHeader95, sizeof(ns1__GroupHeader95), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GroupHeader95 * SOAP_FMAC2 soap_instantiate_ns1__GroupHeader95(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GroupHeader95(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GroupHeader95 *p;
	size_t k = sizeof(ns1__GroupHeader95);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GroupHeader95, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GroupHeader95);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GroupHeader95, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GroupHeader95 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GroupHeader95::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GroupHeader95(soap, tag ? tag : "ns1:GroupHeader95", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GroupHeader95::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GroupHeader95(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GroupHeader95 * SOAP_FMAC4 soap_get_ns1__GroupHeader95(struct soap *soap, ns1__GroupHeader95 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GroupHeader95(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericPersonIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max35Text(soap, &this->ns1__GenericPersonIdentification1::Id);
	this->ns1__GenericPersonIdentification1::SchmeNm = NULL;
	this->ns1__GenericPersonIdentification1::Issr = NULL;
}

void ns1__GenericPersonIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GenericPersonIdentification1::Id, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__GenericPersonIdentification1::Id);
	soap_serialize_PointerTons1__PersonIdentificationSchemeName1Choice(soap, &this->ns1__GenericPersonIdentification1::SchmeNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GenericPersonIdentification1::Issr);
#endif
}

int ns1__GenericPersonIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericPersonIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericPersonIdentification1(struct soap *soap, const char *tag, int id, const ns1__GenericPersonIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericPersonIdentification1), type))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "Id", -1, &a->ns1__GenericPersonIdentification1::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__PersonIdentificationSchemeName1Choice(soap, "SchmeNm", -1, &a->ns1__GenericPersonIdentification1::SchmeNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__GenericPersonIdentification1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericPersonIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericPersonIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericPersonIdentification1 * SOAP_FMAC4 soap_in_ns1__GenericPersonIdentification1(struct soap *soap, const char *tag, ns1__GenericPersonIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericPersonIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericPersonIdentification1, sizeof(ns1__GenericPersonIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericPersonIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericPersonIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_SchmeNm1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "Id", &a->ns1__GenericPersonIdentification1::Id, "ns1:Max35Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_SchmeNm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PersonIdentificationSchemeName1Choice(soap, "SchmeNm", &a->ns1__GenericPersonIdentification1::SchmeNm, "ns1:PersonIdentificationSchemeName1Choice"))
				{	soap_flag_SchmeNm1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__GenericPersonIdentification1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericPersonIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericPersonIdentification1, SOAP_TYPE_ns1__GenericPersonIdentification1, sizeof(ns1__GenericPersonIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericPersonIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericPersonIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericPersonIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenericPersonIdentification1 *p;
	size_t k = sizeof(ns1__GenericPersonIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericPersonIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericPersonIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericPersonIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericPersonIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericPersonIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericPersonIdentification1(soap, tag ? tag : "ns1:GenericPersonIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericPersonIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericPersonIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericPersonIdentification1 * SOAP_FMAC4 soap_get_ns1__GenericPersonIdentification1(struct soap *soap, ns1__GenericPersonIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericPersonIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericOrganisationIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max35Text(soap, &this->ns1__GenericOrganisationIdentification1::Id);
	this->ns1__GenericOrganisationIdentification1::SchmeNm = NULL;
	this->ns1__GenericOrganisationIdentification1::Issr = NULL;
}

void ns1__GenericOrganisationIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GenericOrganisationIdentification1::Id, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__GenericOrganisationIdentification1::Id);
	soap_serialize_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, &this->ns1__GenericOrganisationIdentification1::SchmeNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GenericOrganisationIdentification1::Issr);
#endif
}

int ns1__GenericOrganisationIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericOrganisationIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, int id, const ns1__GenericOrganisationIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericOrganisationIdentification1), type))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "Id", -1, &a->ns1__GenericOrganisationIdentification1::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, "SchmeNm", -1, &a->ns1__GenericOrganisationIdentification1::SchmeNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__GenericOrganisationIdentification1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericOrganisationIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericOrganisationIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericOrganisationIdentification1 * SOAP_FMAC4 soap_in_ns1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, ns1__GenericOrganisationIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericOrganisationIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericOrganisationIdentification1, sizeof(ns1__GenericOrganisationIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericOrganisationIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericOrganisationIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_SchmeNm1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "Id", &a->ns1__GenericOrganisationIdentification1::Id, "ns1:Max35Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_SchmeNm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, "SchmeNm", &a->ns1__GenericOrganisationIdentification1::SchmeNm, "ns1:OrganisationIdentificationSchemeName1Choice"))
				{	soap_flag_SchmeNm1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__GenericOrganisationIdentification1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericOrganisationIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericOrganisationIdentification1, SOAP_TYPE_ns1__GenericOrganisationIdentification1, sizeof(ns1__GenericOrganisationIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericOrganisationIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericOrganisationIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericOrganisationIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenericOrganisationIdentification1 *p;
	size_t k = sizeof(ns1__GenericOrganisationIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericOrganisationIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericOrganisationIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericOrganisationIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericOrganisationIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericOrganisationIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericOrganisationIdentification1(soap, tag ? tag : "ns1:GenericOrganisationIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericOrganisationIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericOrganisationIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericOrganisationIdentification1 * SOAP_FMAC4 soap_get_ns1__GenericOrganisationIdentification1(struct soap *soap, ns1__GenericOrganisationIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericOrganisationIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericIdentification30::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Exact4AlphaNumericText(soap, &this->ns1__GenericIdentification30::Id);
	soap_default_ns1__Max35Text(soap, &this->ns1__GenericIdentification30::Issr);
	this->ns1__GenericIdentification30::SchmeNm = NULL;
}

void ns1__GenericIdentification30::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__Exact4AlphaNumericText(soap, &this->ns1__GenericIdentification30::Id);
	soap_embedded(soap, &this->ns1__GenericIdentification30::Issr, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__GenericIdentification30::Issr);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GenericIdentification30::SchmeNm);
#endif
}

int ns1__GenericIdentification30::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericIdentification30(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericIdentification30(struct soap *soap, const char *tag, int id, const ns1__GenericIdentification30 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericIdentification30), type))
		return soap->error;
	if (soap_out_ns1__Exact4AlphaNumericText(soap, "Id", -1, &a->ns1__GenericIdentification30::Id, ""))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "Issr", -1, &a->ns1__GenericIdentification30::Issr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "SchmeNm", -1, &a->ns1__GenericIdentification30::SchmeNm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericIdentification30::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericIdentification30(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericIdentification30 * SOAP_FMAC4 soap_in_ns1__GenericIdentification30(struct soap *soap, const char *tag, ns1__GenericIdentification30 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericIdentification30*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericIdentification30, sizeof(ns1__GenericIdentification30), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericIdentification30)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericIdentification30 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Issr1 = 1;
	size_t soap_flag_SchmeNm1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Exact4AlphaNumericText(soap, "Id", &a->ns1__GenericIdentification30::Id, "ns1:Exact4AlphaNumericText"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "Issr", &a->ns1__GenericIdentification30::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap_flag_SchmeNm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "SchmeNm", &a->ns1__GenericIdentification30::SchmeNm, "ns1:Max35Text"))
				{	soap_flag_SchmeNm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Issr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericIdentification30 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericIdentification30, SOAP_TYPE_ns1__GenericIdentification30, sizeof(ns1__GenericIdentification30), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericIdentification30 * SOAP_FMAC2 soap_instantiate_ns1__GenericIdentification30(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericIdentification30(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenericIdentification30 *p;
	size_t k = sizeof(ns1__GenericIdentification30);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericIdentification30, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericIdentification30);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericIdentification30, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericIdentification30 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericIdentification30::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericIdentification30(soap, tag ? tag : "ns1:GenericIdentification30", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericIdentification30::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericIdentification30(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericIdentification30 * SOAP_FMAC4 soap_get_ns1__GenericIdentification30(struct soap *soap, ns1__GenericIdentification30 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericIdentification30(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericFinancialIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max35Text(soap, &this->ns1__GenericFinancialIdentification1::Id);
	this->ns1__GenericFinancialIdentification1::SchmeNm = NULL;
	this->ns1__GenericFinancialIdentification1::Issr = NULL;
}

void ns1__GenericFinancialIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GenericFinancialIdentification1::Id, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__GenericFinancialIdentification1::Id);
	soap_serialize_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, &this->ns1__GenericFinancialIdentification1::SchmeNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GenericFinancialIdentification1::Issr);
#endif
}

int ns1__GenericFinancialIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericFinancialIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericFinancialIdentification1(struct soap *soap, const char *tag, int id, const ns1__GenericFinancialIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericFinancialIdentification1), type))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "Id", -1, &a->ns1__GenericFinancialIdentification1::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, "SchmeNm", -1, &a->ns1__GenericFinancialIdentification1::SchmeNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__GenericFinancialIdentification1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericFinancialIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericFinancialIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericFinancialIdentification1 * SOAP_FMAC4 soap_in_ns1__GenericFinancialIdentification1(struct soap *soap, const char *tag, ns1__GenericFinancialIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericFinancialIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericFinancialIdentification1, sizeof(ns1__GenericFinancialIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericFinancialIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericFinancialIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_SchmeNm1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "Id", &a->ns1__GenericFinancialIdentification1::Id, "ns1:Max35Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_SchmeNm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, "SchmeNm", &a->ns1__GenericFinancialIdentification1::SchmeNm, "ns1:FinancialIdentificationSchemeName1Choice"))
				{	soap_flag_SchmeNm1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__GenericFinancialIdentification1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericFinancialIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericFinancialIdentification1, SOAP_TYPE_ns1__GenericFinancialIdentification1, sizeof(ns1__GenericFinancialIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericFinancialIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericFinancialIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericFinancialIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenericFinancialIdentification1 *p;
	size_t k = sizeof(ns1__GenericFinancialIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericFinancialIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericFinancialIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericFinancialIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericFinancialIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericFinancialIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericFinancialIdentification1(soap, tag ? tag : "ns1:GenericFinancialIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericFinancialIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericFinancialIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericFinancialIdentification1 * SOAP_FMAC4 soap_get_ns1__GenericFinancialIdentification1(struct soap *soap, ns1__GenericFinancialIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericFinancialIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericAccountIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Max34Text(soap, &this->ns1__GenericAccountIdentification1::Id);
	this->ns1__GenericAccountIdentification1::SchmeNm = NULL;
	this->ns1__GenericAccountIdentification1::Issr = NULL;
}

void ns1__GenericAccountIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__Max34Text(soap, &this->ns1__GenericAccountIdentification1::Id);
	soap_serialize_PointerTons1__AccountSchemeName1Choice(soap, &this->ns1__GenericAccountIdentification1::SchmeNm);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GenericAccountIdentification1::Issr);
#endif
}

int ns1__GenericAccountIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericAccountIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericAccountIdentification1(struct soap *soap, const char *tag, int id, const ns1__GenericAccountIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericAccountIdentification1), type))
		return soap->error;
	if (soap_out_ns1__Max34Text(soap, "Id", -1, &a->ns1__GenericAccountIdentification1::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountSchemeName1Choice(soap, "SchmeNm", -1, &a->ns1__GenericAccountIdentification1::SchmeNm, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__GenericAccountIdentification1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericAccountIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericAccountIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericAccountIdentification1 * SOAP_FMAC4 soap_in_ns1__GenericAccountIdentification1(struct soap *soap, const char *tag, ns1__GenericAccountIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericAccountIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericAccountIdentification1, sizeof(ns1__GenericAccountIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericAccountIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericAccountIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_SchmeNm1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max34Text(soap, "Id", &a->ns1__GenericAccountIdentification1::Id, "ns1:Max34Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_SchmeNm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccountSchemeName1Choice(soap, "SchmeNm", &a->ns1__GenericAccountIdentification1::SchmeNm, "ns1:AccountSchemeName1Choice"))
				{	soap_flag_SchmeNm1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__GenericAccountIdentification1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericAccountIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericAccountIdentification1, SOAP_TYPE_ns1__GenericAccountIdentification1, sizeof(ns1__GenericAccountIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericAccountIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericAccountIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericAccountIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenericAccountIdentification1 *p;
	size_t k = sizeof(ns1__GenericAccountIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericAccountIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericAccountIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericAccountIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericAccountIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericAccountIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericAccountIdentification1(soap, tag ? tag : "ns1:GenericAccountIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericAccountIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericAccountIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericAccountIdentification1 * SOAP_FMAC4 soap_get_ns1__GenericAccountIdentification1(struct soap *soap, ns1__GenericAccountIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericAccountIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GarnishmentType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GarnishmentType1Choice::__union_GarnishmentType1Choice = 0;
}

void ns1__GarnishmentType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_GarnishmentType1Choice(soap, this->ns1__GarnishmentType1Choice::__union_GarnishmentType1Choice, &this->ns1__GarnishmentType1Choice::union_GarnishmentType1Choice);
#endif
}

int ns1__GarnishmentType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GarnishmentType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GarnishmentType1Choice(struct soap *soap, const char *tag, int id, const ns1__GarnishmentType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GarnishmentType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_GarnishmentType1Choice(soap, a->ns1__GarnishmentType1Choice::__union_GarnishmentType1Choice, &a->ns1__GarnishmentType1Choice::union_GarnishmentType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GarnishmentType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GarnishmentType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GarnishmentType1Choice * SOAP_FMAC4 soap_in_ns1__GarnishmentType1Choice(struct soap *soap, const char *tag, ns1__GarnishmentType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GarnishmentType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GarnishmentType1Choice, sizeof(ns1__GarnishmentType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_GarnishmentType1Choice(soap, &a->__union_GarnishmentType1Choice, &a->union_GarnishmentType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__GarnishmentType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GarnishmentType1Choice, SOAP_TYPE_ns1__GarnishmentType1Choice, sizeof(ns1__GarnishmentType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GarnishmentType1Choice * SOAP_FMAC2 soap_instantiate_ns1__GarnishmentType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GarnishmentType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GarnishmentType1Choice *p;
	size_t k = sizeof(ns1__GarnishmentType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GarnishmentType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GarnishmentType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GarnishmentType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GarnishmentType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GarnishmentType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GarnishmentType1Choice(soap, tag ? tag : "ns1:GarnishmentType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GarnishmentType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GarnishmentType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GarnishmentType1Choice * SOAP_FMAC4 soap_get_ns1__GarnishmentType1Choice(struct soap *soap, ns1__GarnishmentType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GarnishmentType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GarnishmentType1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GarnishmentType1::CdOrPrtry = NULL;
	this->ns1__GarnishmentType1::Issr = NULL;
}

void ns1__GarnishmentType1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GarnishmentType1Choice(soap, &this->ns1__GarnishmentType1::CdOrPrtry);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__GarnishmentType1::Issr);
#endif
}

int ns1__GarnishmentType1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GarnishmentType1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GarnishmentType1(struct soap *soap, const char *tag, int id, const ns1__GarnishmentType1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GarnishmentType1), type))
		return soap->error;
	if (!a->ns1__GarnishmentType1::CdOrPrtry)
	{	if (soap_element_empty(soap, "CdOrPrtry", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GarnishmentType1Choice(soap, "CdOrPrtry", -1, &a->ns1__GarnishmentType1::CdOrPrtry, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__GarnishmentType1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GarnishmentType1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GarnishmentType1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GarnishmentType1 * SOAP_FMAC4 soap_in_ns1__GarnishmentType1(struct soap *soap, const char *tag, ns1__GarnishmentType1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GarnishmentType1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GarnishmentType1, sizeof(ns1__GarnishmentType1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GarnishmentType1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GarnishmentType1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CdOrPrtry1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CdOrPrtry1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GarnishmentType1Choice(soap, "CdOrPrtry", &a->ns1__GarnishmentType1::CdOrPrtry, "ns1:GarnishmentType1Choice"))
				{	soap_flag_CdOrPrtry1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__GarnishmentType1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GarnishmentType1::CdOrPrtry))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GarnishmentType1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GarnishmentType1, SOAP_TYPE_ns1__GarnishmentType1, sizeof(ns1__GarnishmentType1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GarnishmentType1 * SOAP_FMAC2 soap_instantiate_ns1__GarnishmentType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GarnishmentType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GarnishmentType1 *p;
	size_t k = sizeof(ns1__GarnishmentType1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GarnishmentType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GarnishmentType1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GarnishmentType1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GarnishmentType1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GarnishmentType1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GarnishmentType1(soap, tag ? tag : "ns1:GarnishmentType1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GarnishmentType1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GarnishmentType1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GarnishmentType1 * SOAP_FMAC4 soap_get_ns1__GarnishmentType1(struct soap *soap, ns1__GarnishmentType1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GarnishmentType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Garnishment3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Garnishment3::Tp = NULL;
	this->ns1__Garnishment3::Grnshee = NULL;
	this->ns1__Garnishment3::GrnshmtAdmstr = NULL;
	this->ns1__Garnishment3::RefNb = NULL;
	this->ns1__Garnishment3::Dt = NULL;
	this->ns1__Garnishment3::RmtdAmt = NULL;
	this->ns1__Garnishment3::FmlyMdclInsrncInd = NULL;
	this->ns1__Garnishment3::MplyeeTermntnInd = NULL;
}

void ns1__Garnishment3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GarnishmentType1(soap, &this->ns1__Garnishment3::Tp);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__Garnishment3::Grnshee);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__Garnishment3::GrnshmtAdmstr);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__Garnishment3::RefNb);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__Garnishment3::Dt);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__Garnishment3::RmtdAmt);
	soap_serialize_PointerTons1__TrueFalseIndicator(soap, &this->ns1__Garnishment3::FmlyMdclInsrncInd);
	soap_serialize_PointerTons1__TrueFalseIndicator(soap, &this->ns1__Garnishment3::MplyeeTermntnInd);
#endif
}

int ns1__Garnishment3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Garnishment3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Garnishment3(struct soap *soap, const char *tag, int id, const ns1__Garnishment3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Garnishment3), type))
		return soap->error;
	if (!a->ns1__Garnishment3::Tp)
	{	if (soap_element_empty(soap, "Tp", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GarnishmentType1(soap, "Tp", -1, &a->ns1__Garnishment3::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "Grnshee", -1, &a->ns1__Garnishment3::Grnshee, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "GrnshmtAdmstr", -1, &a->ns1__Garnishment3::GrnshmtAdmstr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "RefNb", -1, &a->ns1__Garnishment3::RefNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "Dt", -1, &a->ns1__Garnishment3::Dt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", -1, &a->ns1__Garnishment3::RmtdAmt, ""))
		return soap->error;
	if (soap_out_PointerTons1__TrueFalseIndicator(soap, "FmlyMdclInsrncInd", -1, &a->ns1__Garnishment3::FmlyMdclInsrncInd, ""))
		return soap->error;
	if (soap_out_PointerTons1__TrueFalseIndicator(soap, "MplyeeTermntnInd", -1, &a->ns1__Garnishment3::MplyeeTermntnInd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Garnishment3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Garnishment3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Garnishment3 * SOAP_FMAC4 soap_in_ns1__Garnishment3(struct soap *soap, const char *tag, ns1__Garnishment3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Garnishment3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Garnishment3, sizeof(ns1__Garnishment3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Garnishment3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Garnishment3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Grnshee1 = 1;
	size_t soap_flag_GrnshmtAdmstr1 = 1;
	size_t soap_flag_RefNb1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_RmtdAmt1 = 1;
	size_t soap_flag_FmlyMdclInsrncInd1 = 1;
	size_t soap_flag_MplyeeTermntnInd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GarnishmentType1(soap, "Tp", &a->ns1__Garnishment3::Tp, "ns1:GarnishmentType1"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Grnshee1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "Grnshee", &a->ns1__Garnishment3::Grnshee, "ns1:PartyIdentification135"))
				{	soap_flag_Grnshee1--;
					continue;
				}
			}
			if (soap_flag_GrnshmtAdmstr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "GrnshmtAdmstr", &a->ns1__Garnishment3::GrnshmtAdmstr, "ns1:PartyIdentification135"))
				{	soap_flag_GrnshmtAdmstr1--;
					continue;
				}
			}
			if (soap_flag_RefNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "RefNb", &a->ns1__Garnishment3::RefNb, "ns1:Max140Text"))
				{	soap_flag_RefNb1--;
					continue;
				}
			}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "Dt", &a->ns1__Garnishment3::Dt, "ns1:ISODate"))
				{	soap_flag_Dt1--;
					continue;
				}
			}
			if (soap_flag_RmtdAmt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "RmtdAmt", &a->ns1__Garnishment3::RmtdAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_RmtdAmt1--;
					continue;
				}
			}
			if (soap_flag_FmlyMdclInsrncInd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TrueFalseIndicator(soap, "FmlyMdclInsrncInd", &a->ns1__Garnishment3::FmlyMdclInsrncInd, "ns1:TrueFalseIndicator"))
				{	soap_flag_FmlyMdclInsrncInd1--;
					continue;
				}
			}
			if (soap_flag_MplyeeTermntnInd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TrueFalseIndicator(soap, "MplyeeTermntnInd", &a->ns1__Garnishment3::MplyeeTermntnInd, "ns1:TrueFalseIndicator"))
				{	soap_flag_MplyeeTermntnInd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__Garnishment3::Tp))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Garnishment3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Garnishment3, SOAP_TYPE_ns1__Garnishment3, sizeof(ns1__Garnishment3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Garnishment3 * SOAP_FMAC2 soap_instantiate_ns1__Garnishment3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Garnishment3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Garnishment3 *p;
	size_t k = sizeof(ns1__Garnishment3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Garnishment3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Garnishment3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Garnishment3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Garnishment3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Garnishment3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Garnishment3(soap, tag ? tag : "ns1:Garnishment3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Garnishment3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Garnishment3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Garnishment3 * SOAP_FMAC4 soap_get_ns1__Garnishment3(struct soap *soap, ns1__Garnishment3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Garnishment3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FrequencyPeriod1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Frequency6Code(soap, &this->ns1__FrequencyPeriod1::Tp);
	soap_default_ns1__DecimalNumber(soap, &this->ns1__FrequencyPeriod1::CntPerPrd);
}

void ns1__FrequencyPeriod1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__FrequencyPeriod1::CntPerPrd, SOAP_TYPE_ns1__DecimalNumber);
	soap_serialize_ns1__DecimalNumber(soap, &this->ns1__FrequencyPeriod1::CntPerPrd);
#endif
}

int ns1__FrequencyPeriod1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FrequencyPeriod1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FrequencyPeriod1(struct soap *soap, const char *tag, int id, const ns1__FrequencyPeriod1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FrequencyPeriod1), type))
		return soap->error;
	if (soap_out_ns1__Frequency6Code(soap, "Tp", -1, &a->ns1__FrequencyPeriod1::Tp, ""))
		return soap->error;
	if (soap_out_ns1__DecimalNumber(soap, "CntPerPrd", -1, &a->ns1__FrequencyPeriod1::CntPerPrd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FrequencyPeriod1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FrequencyPeriod1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FrequencyPeriod1 * SOAP_FMAC4 soap_in_ns1__FrequencyPeriod1(struct soap *soap, const char *tag, ns1__FrequencyPeriod1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FrequencyPeriod1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FrequencyPeriod1, sizeof(ns1__FrequencyPeriod1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FrequencyPeriod1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FrequencyPeriod1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_CntPerPrd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__Frequency6Code(soap, "Tp", &a->ns1__FrequencyPeriod1::Tp, "ns1:Frequency6Code"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_CntPerPrd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__DecimalNumber(soap, "CntPerPrd", &a->ns1__FrequencyPeriod1::CntPerPrd, "ns1:DecimalNumber"))
				{	soap_flag_CntPerPrd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Tp1 > 0 || soap_flag_CntPerPrd1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FrequencyPeriod1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FrequencyPeriod1, SOAP_TYPE_ns1__FrequencyPeriod1, sizeof(ns1__FrequencyPeriod1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FrequencyPeriod1 * SOAP_FMAC2 soap_instantiate_ns1__FrequencyPeriod1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FrequencyPeriod1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FrequencyPeriod1 *p;
	size_t k = sizeof(ns1__FrequencyPeriod1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FrequencyPeriod1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FrequencyPeriod1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FrequencyPeriod1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FrequencyPeriod1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FrequencyPeriod1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FrequencyPeriod1(soap, tag ? tag : "ns1:FrequencyPeriod1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FrequencyPeriod1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FrequencyPeriod1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FrequencyPeriod1 * SOAP_FMAC4 soap_get_ns1__FrequencyPeriod1(struct soap *soap, ns1__FrequencyPeriod1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FrequencyPeriod1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FrequencyAndMoment1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Frequency6Code(soap, &this->ns1__FrequencyAndMoment1::Tp);
	soap_default_ns1__Exact2NumericText(soap, &this->ns1__FrequencyAndMoment1::PtInTm);
}

void ns1__FrequencyAndMoment1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__Exact2NumericText(soap, &this->ns1__FrequencyAndMoment1::PtInTm);
#endif
}

int ns1__FrequencyAndMoment1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FrequencyAndMoment1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FrequencyAndMoment1(struct soap *soap, const char *tag, int id, const ns1__FrequencyAndMoment1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FrequencyAndMoment1), type))
		return soap->error;
	if (soap_out_ns1__Frequency6Code(soap, "Tp", -1, &a->ns1__FrequencyAndMoment1::Tp, ""))
		return soap->error;
	if (soap_out_ns1__Exact2NumericText(soap, "PtInTm", -1, &a->ns1__FrequencyAndMoment1::PtInTm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FrequencyAndMoment1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FrequencyAndMoment1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FrequencyAndMoment1 * SOAP_FMAC4 soap_in_ns1__FrequencyAndMoment1(struct soap *soap, const char *tag, ns1__FrequencyAndMoment1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FrequencyAndMoment1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FrequencyAndMoment1, sizeof(ns1__FrequencyAndMoment1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FrequencyAndMoment1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FrequencyAndMoment1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_PtInTm1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__Frequency6Code(soap, "Tp", &a->ns1__FrequencyAndMoment1::Tp, "ns1:Frequency6Code"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_PtInTm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Exact2NumericText(soap, "PtInTm", &a->ns1__FrequencyAndMoment1::PtInTm, "ns1:Exact2NumericText"))
				{	soap_flag_PtInTm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Tp1 > 0 || soap_flag_PtInTm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FrequencyAndMoment1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FrequencyAndMoment1, SOAP_TYPE_ns1__FrequencyAndMoment1, sizeof(ns1__FrequencyAndMoment1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FrequencyAndMoment1 * SOAP_FMAC2 soap_instantiate_ns1__FrequencyAndMoment1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FrequencyAndMoment1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FrequencyAndMoment1 *p;
	size_t k = sizeof(ns1__FrequencyAndMoment1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FrequencyAndMoment1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FrequencyAndMoment1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FrequencyAndMoment1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FrequencyAndMoment1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FrequencyAndMoment1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FrequencyAndMoment1(soap, tag ? tag : "ns1:FrequencyAndMoment1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FrequencyAndMoment1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FrequencyAndMoment1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FrequencyAndMoment1 * SOAP_FMAC4 soap_get_ns1__FrequencyAndMoment1(struct soap *soap, ns1__FrequencyAndMoment1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FrequencyAndMoment1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Frequency36Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Frequency36Choice::__union_Frequency36Choice = 0;
}

void ns1__Frequency36Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_Frequency36Choice(soap, this->ns1__Frequency36Choice::__union_Frequency36Choice, &this->ns1__Frequency36Choice::union_Frequency36Choice);
#endif
}

int ns1__Frequency36Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Frequency36Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Frequency36Choice(struct soap *soap, const char *tag, int id, const ns1__Frequency36Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Frequency36Choice), type))
		return soap->error;
	if (soap_out__ns1__union_Frequency36Choice(soap, a->ns1__Frequency36Choice::__union_Frequency36Choice, &a->ns1__Frequency36Choice::union_Frequency36Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Frequency36Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Frequency36Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Frequency36Choice * SOAP_FMAC4 soap_in_ns1__Frequency36Choice(struct soap *soap, const char *tag, ns1__Frequency36Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Frequency36Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Frequency36Choice, sizeof(ns1__Frequency36Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_Frequency36Choice(soap, &a->__union_Frequency36Choice, &a->union_Frequency36Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__Frequency36Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Frequency36Choice, SOAP_TYPE_ns1__Frequency36Choice, sizeof(ns1__Frequency36Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Frequency36Choice * SOAP_FMAC2 soap_instantiate_ns1__Frequency36Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Frequency36Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Frequency36Choice *p;
	size_t k = sizeof(ns1__Frequency36Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Frequency36Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Frequency36Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Frequency36Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Frequency36Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Frequency36Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Frequency36Choice(soap, tag ? tag : "ns1:Frequency36Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Frequency36Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Frequency36Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Frequency36Choice * SOAP_FMAC4 soap_get_ns1__Frequency36Choice(struct soap *soap, ns1__Frequency36Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Frequency36Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FinancialInstitutionIdentification18::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FinancialInstitutionIdentification18::BICFI = NULL;
	this->ns1__FinancialInstitutionIdentification18::ClrSysMmbId = NULL;
	this->ns1__FinancialInstitutionIdentification18::LEI = NULL;
	this->ns1__FinancialInstitutionIdentification18::Nm = NULL;
	this->ns1__FinancialInstitutionIdentification18::PstlAdr = NULL;
	this->ns1__FinancialInstitutionIdentification18::Othr = NULL;
}

void ns1__FinancialInstitutionIdentification18::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BICFIDec2014Identifier(soap, &this->ns1__FinancialInstitutionIdentification18::BICFI);
	soap_serialize_PointerTons1__ClearingSystemMemberIdentification2(soap, &this->ns1__FinancialInstitutionIdentification18::ClrSysMmbId);
	soap_serialize_PointerTons1__LEIIdentifier(soap, &this->ns1__FinancialInstitutionIdentification18::LEI);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__FinancialInstitutionIdentification18::Nm);
	soap_serialize_PointerTons1__PostalAddress24(soap, &this->ns1__FinancialInstitutionIdentification18::PstlAdr);
	soap_serialize_PointerTons1__GenericFinancialIdentification1(soap, &this->ns1__FinancialInstitutionIdentification18::Othr);
#endif
}

int ns1__FinancialInstitutionIdentification18::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FinancialInstitutionIdentification18(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FinancialInstitutionIdentification18(struct soap *soap, const char *tag, int id, const ns1__FinancialInstitutionIdentification18 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FinancialInstitutionIdentification18), type))
		return soap->error;
	if (soap_out_PointerTons1__BICFIDec2014Identifier(soap, "BICFI", -1, &a->ns1__FinancialInstitutionIdentification18::BICFI, ""))
		return soap->error;
	if (soap_out_PointerTons1__ClearingSystemMemberIdentification2(soap, "ClrSysMmbId", -1, &a->ns1__FinancialInstitutionIdentification18::ClrSysMmbId, ""))
		return soap->error;
	if (soap_out_PointerTons1__LEIIdentifier(soap, "LEI", -1, &a->ns1__FinancialInstitutionIdentification18::LEI, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__FinancialInstitutionIdentification18::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__PostalAddress24(soap, "PstlAdr", -1, &a->ns1__FinancialInstitutionIdentification18::PstlAdr, ""))
		return soap->error;
	if (soap_out_PointerTons1__GenericFinancialIdentification1(soap, "Othr", -1, &a->ns1__FinancialInstitutionIdentification18::Othr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FinancialInstitutionIdentification18::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FinancialInstitutionIdentification18(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FinancialInstitutionIdentification18 * SOAP_FMAC4 soap_in_ns1__FinancialInstitutionIdentification18(struct soap *soap, const char *tag, ns1__FinancialInstitutionIdentification18 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FinancialInstitutionIdentification18*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, sizeof(ns1__FinancialInstitutionIdentification18), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FinancialInstitutionIdentification18)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FinancialInstitutionIdentification18 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BICFI1 = 1;
	size_t soap_flag_ClrSysMmbId1 = 1;
	size_t soap_flag_LEI1 = 1;
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_PstlAdr1 = 1;
	size_t soap_flag_Othr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BICFI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__BICFIDec2014Identifier(soap, "BICFI", &a->ns1__FinancialInstitutionIdentification18::BICFI, "ns1:BICFIDec2014Identifier"))
				{	soap_flag_BICFI1--;
					continue;
				}
			}
			if (soap_flag_ClrSysMmbId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ClearingSystemMemberIdentification2(soap, "ClrSysMmbId", &a->ns1__FinancialInstitutionIdentification18::ClrSysMmbId, "ns1:ClearingSystemMemberIdentification2"))
				{	soap_flag_ClrSysMmbId1--;
					continue;
				}
			}
			if (soap_flag_LEI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__LEIIdentifier(soap, "LEI", &a->ns1__FinancialInstitutionIdentification18::LEI, "ns1:LEIIdentifier"))
				{	soap_flag_LEI1--;
					continue;
				}
			}
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__FinancialInstitutionIdentification18::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_PstlAdr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PostalAddress24(soap, "PstlAdr", &a->ns1__FinancialInstitutionIdentification18::PstlAdr, "ns1:PostalAddress24"))
				{	soap_flag_PstlAdr1--;
					continue;
				}
			}
			if (soap_flag_Othr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenericFinancialIdentification1(soap, "Othr", &a->ns1__FinancialInstitutionIdentification18::Othr, "ns1:GenericFinancialIdentification1"))
				{	soap_flag_Othr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FinancialInstitutionIdentification18 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, sizeof(ns1__FinancialInstitutionIdentification18), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FinancialInstitutionIdentification18 * SOAP_FMAC2 soap_instantiate_ns1__FinancialInstitutionIdentification18(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FinancialInstitutionIdentification18(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FinancialInstitutionIdentification18 *p;
	size_t k = sizeof(ns1__FinancialInstitutionIdentification18);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FinancialInstitutionIdentification18);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FinancialInstitutionIdentification18, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FinancialInstitutionIdentification18 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FinancialInstitutionIdentification18::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FinancialInstitutionIdentification18(soap, tag ? tag : "ns1:FinancialInstitutionIdentification18", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FinancialInstitutionIdentification18::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FinancialInstitutionIdentification18(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FinancialInstitutionIdentification18 * SOAP_FMAC4 soap_get_ns1__FinancialInstitutionIdentification18(struct soap *soap, ns1__FinancialInstitutionIdentification18 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FinancialInstitutionIdentification18(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FinancialIdentificationSchemeName1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FinancialIdentificationSchemeName1Choice::__union_FinancialIdentificationSchemeName1Choice = 0;
}

void ns1__FinancialIdentificationSchemeName1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_FinancialIdentificationSchemeName1Choice(soap, this->ns1__FinancialIdentificationSchemeName1Choice::__union_FinancialIdentificationSchemeName1Choice, &this->ns1__FinancialIdentificationSchemeName1Choice::union_FinancialIdentificationSchemeName1Choice);
#endif
}

int ns1__FinancialIdentificationSchemeName1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FinancialIdentificationSchemeName1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FinancialIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, const ns1__FinancialIdentificationSchemeName1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_FinancialIdentificationSchemeName1Choice(soap, a->ns1__FinancialIdentificationSchemeName1Choice::__union_FinancialIdentificationSchemeName1Choice, &a->ns1__FinancialIdentificationSchemeName1Choice::union_FinancialIdentificationSchemeName1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FinancialIdentificationSchemeName1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FinancialIdentificationSchemeName1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FinancialIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in_ns1__FinancialIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__FinancialIdentificationSchemeName1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FinancialIdentificationSchemeName1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, sizeof(ns1__FinancialIdentificationSchemeName1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_FinancialIdentificationSchemeName1Choice(soap, &a->__union_FinancialIdentificationSchemeName1Choice, &a->union_FinancialIdentificationSchemeName1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__FinancialIdentificationSchemeName1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, sizeof(ns1__FinancialIdentificationSchemeName1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FinancialIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__FinancialIdentificationSchemeName1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FinancialIdentificationSchemeName1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FinancialIdentificationSchemeName1Choice *p;
	size_t k = sizeof(ns1__FinancialIdentificationSchemeName1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FinancialIdentificationSchemeName1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FinancialIdentificationSchemeName1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FinancialIdentificationSchemeName1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FinancialIdentificationSchemeName1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FinancialIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:FinancialIdentificationSchemeName1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FinancialIdentificationSchemeName1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FinancialIdentificationSchemeName1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FinancialIdentificationSchemeName1Choice * SOAP_FMAC4 soap_get_ns1__FinancialIdentificationSchemeName1Choice(struct soap *soap, ns1__FinancialIdentificationSchemeName1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FinancialIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ExchangeRate1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ExchangeRate1::UnitCcy = NULL;
	this->ns1__ExchangeRate1::XchgRate = NULL;
	this->ns1__ExchangeRate1::RateTp = NULL;
	this->ns1__ExchangeRate1::CtrctId = NULL;
}

void ns1__ExchangeRate1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyCode(soap, &this->ns1__ExchangeRate1::UnitCcy);
	soap_serialize_PointerTons1__BaseOneRate(soap, &this->ns1__ExchangeRate1::XchgRate);
	soap_serialize_PointerTons1__ExchangeRateType1Code(soap, &this->ns1__ExchangeRate1::RateTp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__ExchangeRate1::CtrctId);
#endif
}

int ns1__ExchangeRate1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ExchangeRate1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExchangeRate1(struct soap *soap, const char *tag, int id, const ns1__ExchangeRate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExchangeRate1), type))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyCode(soap, "UnitCcy", -1, &a->ns1__ExchangeRate1::UnitCcy, ""))
		return soap->error;
	if (soap_out_PointerTons1__BaseOneRate(soap, "XchgRate", -1, &a->ns1__ExchangeRate1::XchgRate, ""))
		return soap->error;
	if (soap_out_PointerTons1__ExchangeRateType1Code(soap, "RateTp", -1, &a->ns1__ExchangeRate1::RateTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "CtrctId", -1, &a->ns1__ExchangeRate1::CtrctId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ExchangeRate1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ExchangeRate1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ExchangeRate1 * SOAP_FMAC4 soap_in_ns1__ExchangeRate1(struct soap *soap, const char *tag, ns1__ExchangeRate1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ExchangeRate1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExchangeRate1, sizeof(ns1__ExchangeRate1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ExchangeRate1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ExchangeRate1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UnitCcy1 = 1;
	size_t soap_flag_XchgRate1 = 1;
	size_t soap_flag_RateTp1 = 1;
	size_t soap_flag_CtrctId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UnitCcy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyCode(soap, "UnitCcy", &a->ns1__ExchangeRate1::UnitCcy, "ns1:ActiveOrHistoricCurrencyCode"))
				{	soap_flag_UnitCcy1--;
					continue;
				}
			}
			if (soap_flag_XchgRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__BaseOneRate(soap, "XchgRate", &a->ns1__ExchangeRate1::XchgRate, "ns1:BaseOneRate"))
				{	soap_flag_XchgRate1--;
					continue;
				}
			}
			if (soap_flag_RateTp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ExchangeRateType1Code(soap, "RateTp", &a->ns1__ExchangeRate1::RateTp, "ns1:ExchangeRateType1Code"))
				{	soap_flag_RateTp1--;
					continue;
				}
			}
			if (soap_flag_CtrctId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "CtrctId", &a->ns1__ExchangeRate1::CtrctId, "ns1:Max35Text"))
				{	soap_flag_CtrctId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ExchangeRate1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExchangeRate1, SOAP_TYPE_ns1__ExchangeRate1, sizeof(ns1__ExchangeRate1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ExchangeRate1 * SOAP_FMAC2 soap_instantiate_ns1__ExchangeRate1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExchangeRate1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ExchangeRate1 *p;
	size_t k = sizeof(ns1__ExchangeRate1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ExchangeRate1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ExchangeRate1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ExchangeRate1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ExchangeRate1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ExchangeRate1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ExchangeRate1(soap, tag ? tag : "ns1:ExchangeRate1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ExchangeRate1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ExchangeRate1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ExchangeRate1 * SOAP_FMAC4 soap_get_ns1__ExchangeRate1(struct soap *soap, ns1__ExchangeRate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExchangeRate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__EquivalentAmount2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__EquivalentAmount2::Amt = NULL;
	soap_default_ns1__ActiveOrHistoricCurrencyCode(soap, &this->ns1__EquivalentAmount2::CcyOfTrf);
}

void ns1__EquivalentAmount2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__EquivalentAmount2::Amt);
	soap_embedded(soap, &this->ns1__EquivalentAmount2::CcyOfTrf, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode);
	soap_serialize_ns1__ActiveOrHistoricCurrencyCode(soap, &this->ns1__EquivalentAmount2::CcyOfTrf);
#endif
}

int ns1__EquivalentAmount2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EquivalentAmount2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EquivalentAmount2(struct soap *soap, const char *tag, int id, const ns1__EquivalentAmount2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EquivalentAmount2), type))
		return soap->error;
	if (!a->ns1__EquivalentAmount2::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__EquivalentAmount2::Amt, ""))
		return soap->error;
	if (soap_out_ns1__ActiveOrHistoricCurrencyCode(soap, "CcyOfTrf", -1, &a->ns1__EquivalentAmount2::CcyOfTrf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EquivalentAmount2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__EquivalentAmount2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EquivalentAmount2 * SOAP_FMAC4 soap_in_ns1__EquivalentAmount2(struct soap *soap, const char *tag, ns1__EquivalentAmount2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EquivalentAmount2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EquivalentAmount2, sizeof(ns1__EquivalentAmount2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__EquivalentAmount2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__EquivalentAmount2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Amt1 = 1;
	size_t soap_flag_CcyOfTrf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__EquivalentAmount2::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap_flag_CcyOfTrf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__ActiveOrHistoricCurrencyCode(soap, "CcyOfTrf", &a->ns1__EquivalentAmount2::CcyOfTrf, "ns1:ActiveOrHistoricCurrencyCode"))
				{	soap_flag_CcyOfTrf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__EquivalentAmount2::Amt || soap_flag_CcyOfTrf1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__EquivalentAmount2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EquivalentAmount2, SOAP_TYPE_ns1__EquivalentAmount2, sizeof(ns1__EquivalentAmount2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__EquivalentAmount2 * SOAP_FMAC2 soap_instantiate_ns1__EquivalentAmount2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EquivalentAmount2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__EquivalentAmount2 *p;
	size_t k = sizeof(ns1__EquivalentAmount2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__EquivalentAmount2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__EquivalentAmount2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__EquivalentAmount2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__EquivalentAmount2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__EquivalentAmount2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__EquivalentAmount2(soap, tag ? tag : "ns1:EquivalentAmount2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EquivalentAmount2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EquivalentAmount2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EquivalentAmount2 * SOAP_FMAC4 soap_get_ns1__EquivalentAmount2(struct soap *soap, ns1__EquivalentAmount2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EquivalentAmount2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DocumentLineType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DocumentLineType1Choice::__union_DocumentLineType1Choice = 0;
}

void ns1__DocumentLineType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_DocumentLineType1Choice(soap, this->ns1__DocumentLineType1Choice::__union_DocumentLineType1Choice, &this->ns1__DocumentLineType1Choice::union_DocumentLineType1Choice);
#endif
}

int ns1__DocumentLineType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentLineType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentLineType1Choice(struct soap *soap, const char *tag, int id, const ns1__DocumentLineType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentLineType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_DocumentLineType1Choice(soap, a->ns1__DocumentLineType1Choice::__union_DocumentLineType1Choice, &a->ns1__DocumentLineType1Choice::union_DocumentLineType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DocumentLineType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DocumentLineType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentLineType1Choice * SOAP_FMAC4 soap_in_ns1__DocumentLineType1Choice(struct soap *soap, const char *tag, ns1__DocumentLineType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DocumentLineType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentLineType1Choice, sizeof(ns1__DocumentLineType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_DocumentLineType1Choice(soap, &a->__union_DocumentLineType1Choice, &a->union_DocumentLineType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__DocumentLineType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentLineType1Choice, SOAP_TYPE_ns1__DocumentLineType1Choice, sizeof(ns1__DocumentLineType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DocumentLineType1Choice * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentLineType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DocumentLineType1Choice *p;
	size_t k = sizeof(ns1__DocumentLineType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DocumentLineType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DocumentLineType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DocumentLineType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DocumentLineType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DocumentLineType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DocumentLineType1Choice(soap, tag ? tag : "ns1:DocumentLineType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DocumentLineType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentLineType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentLineType1Choice * SOAP_FMAC4 soap_get_ns1__DocumentLineType1Choice(struct soap *soap, ns1__DocumentLineType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentLineType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DocumentLineType1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DocumentLineType1::CdOrPrtry = NULL;
	this->ns1__DocumentLineType1::Issr = NULL;
}

void ns1__DocumentLineType1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DocumentLineType1Choice(soap, &this->ns1__DocumentLineType1::CdOrPrtry);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__DocumentLineType1::Issr);
#endif
}

int ns1__DocumentLineType1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentLineType1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentLineType1(struct soap *soap, const char *tag, int id, const ns1__DocumentLineType1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentLineType1), type))
		return soap->error;
	if (!a->ns1__DocumentLineType1::CdOrPrtry)
	{	if (soap_element_empty(soap, "CdOrPrtry", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__DocumentLineType1Choice(soap, "CdOrPrtry", -1, &a->ns1__DocumentLineType1::CdOrPrtry, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__DocumentLineType1::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DocumentLineType1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DocumentLineType1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentLineType1 * SOAP_FMAC4 soap_in_ns1__DocumentLineType1(struct soap *soap, const char *tag, ns1__DocumentLineType1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DocumentLineType1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentLineType1, sizeof(ns1__DocumentLineType1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DocumentLineType1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DocumentLineType1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CdOrPrtry1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CdOrPrtry1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DocumentLineType1Choice(soap, "CdOrPrtry", &a->ns1__DocumentLineType1::CdOrPrtry, "ns1:DocumentLineType1Choice"))
				{	soap_flag_CdOrPrtry1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__DocumentLineType1::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DocumentLineType1::CdOrPrtry))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DocumentLineType1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentLineType1, SOAP_TYPE_ns1__DocumentLineType1, sizeof(ns1__DocumentLineType1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DocumentLineType1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentLineType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DocumentLineType1 *p;
	size_t k = sizeof(ns1__DocumentLineType1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DocumentLineType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DocumentLineType1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DocumentLineType1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DocumentLineType1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DocumentLineType1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DocumentLineType1(soap, tag ? tag : "ns1:DocumentLineType1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DocumentLineType1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentLineType1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentLineType1 * SOAP_FMAC4 soap_get_ns1__DocumentLineType1(struct soap *soap, ns1__DocumentLineType1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentLineType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DocumentLineInformation1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap, &this->ns1__DocumentLineInformation1::Id);
	this->ns1__DocumentLineInformation1::Desc = NULL;
	this->ns1__DocumentLineInformation1::Amt = NULL;
}

void ns1__DocumentLineInformation1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap, &this->ns1__DocumentLineInformation1::Id);
	soap_serialize_PointerTons1__Max2048Text(soap, &this->ns1__DocumentLineInformation1::Desc);
	soap_serialize_PointerTons1__RemittanceAmount3(soap, &this->ns1__DocumentLineInformation1::Amt);
#endif
}

int ns1__DocumentLineInformation1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentLineInformation1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentLineInformation1(struct soap *soap, const char *tag, int id, const ns1__DocumentLineInformation1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentLineInformation1), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap, "Id", -1, &a->ns1__DocumentLineInformation1::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max2048Text(soap, "Desc", -1, &a->ns1__DocumentLineInformation1::Desc, ""))
		return soap->error;
	if (soap_out_PointerTons1__RemittanceAmount3(soap, "Amt", -1, &a->ns1__DocumentLineInformation1::Amt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DocumentLineInformation1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DocumentLineInformation1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentLineInformation1 * SOAP_FMAC4 soap_in_ns1__DocumentLineInformation1(struct soap *soap, const char *tag, ns1__DocumentLineInformation1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DocumentLineInformation1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentLineInformation1, sizeof(ns1__DocumentLineInformation1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DocumentLineInformation1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DocumentLineInformation1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_Amt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap, "Id", &a->ns1__DocumentLineInformation1::Id, "ns1:DocumentLineIdentification1"))
					continue;
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max2048Text(soap, "Desc", &a->ns1__DocumentLineInformation1::Desc, "ns1:Max2048Text"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RemittanceAmount3(soap, "Amt", &a->ns1__DocumentLineInformation1::Amt, "ns1:RemittanceAmount3"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__DocumentLineInformation1::Id.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DocumentLineInformation1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentLineInformation1, SOAP_TYPE_ns1__DocumentLineInformation1, sizeof(ns1__DocumentLineInformation1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DocumentLineInformation1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineInformation1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentLineInformation1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DocumentLineInformation1 *p;
	size_t k = sizeof(ns1__DocumentLineInformation1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DocumentLineInformation1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DocumentLineInformation1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DocumentLineInformation1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DocumentLineInformation1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DocumentLineInformation1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DocumentLineInformation1(soap, tag ? tag : "ns1:DocumentLineInformation1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DocumentLineInformation1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentLineInformation1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentLineInformation1 * SOAP_FMAC4 soap_get_ns1__DocumentLineInformation1(struct soap *soap, ns1__DocumentLineInformation1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentLineInformation1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DocumentLineIdentification1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DocumentLineIdentification1::Tp = NULL;
	this->ns1__DocumentLineIdentification1::Nb = NULL;
	this->ns1__DocumentLineIdentification1::RltdDt = NULL;
}

void ns1__DocumentLineIdentification1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DocumentLineType1(soap, &this->ns1__DocumentLineIdentification1::Tp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__DocumentLineIdentification1::Nb);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__DocumentLineIdentification1::RltdDt);
#endif
}

int ns1__DocumentLineIdentification1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentLineIdentification1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentLineIdentification1(struct soap *soap, const char *tag, int id, const ns1__DocumentLineIdentification1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentLineIdentification1), type))
		return soap->error;
	if (soap_out_PointerTons1__DocumentLineType1(soap, "Tp", -1, &a->ns1__DocumentLineIdentification1::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Nb", -1, &a->ns1__DocumentLineIdentification1::Nb, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "RltdDt", -1, &a->ns1__DocumentLineIdentification1::RltdDt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DocumentLineIdentification1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DocumentLineIdentification1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentLineIdentification1 * SOAP_FMAC4 soap_in_ns1__DocumentLineIdentification1(struct soap *soap, const char *tag, ns1__DocumentLineIdentification1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DocumentLineIdentification1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentLineIdentification1, sizeof(ns1__DocumentLineIdentification1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DocumentLineIdentification1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DocumentLineIdentification1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Nb1 = 1;
	size_t soap_flag_RltdDt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DocumentLineType1(soap, "Tp", &a->ns1__DocumentLineIdentification1::Tp, "ns1:DocumentLineType1"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Nb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Nb", &a->ns1__DocumentLineIdentification1::Nb, "ns1:Max35Text"))
				{	soap_flag_Nb1--;
					continue;
				}
			}
			if (soap_flag_RltdDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "RltdDt", &a->ns1__DocumentLineIdentification1::RltdDt, "ns1:ISODate"))
				{	soap_flag_RltdDt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DocumentLineIdentification1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentLineIdentification1, SOAP_TYPE_ns1__DocumentLineIdentification1, sizeof(ns1__DocumentLineIdentification1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DocumentLineIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentLineIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DocumentLineIdentification1 *p;
	size_t k = sizeof(ns1__DocumentLineIdentification1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DocumentLineIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DocumentLineIdentification1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DocumentLineIdentification1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DocumentLineIdentification1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DocumentLineIdentification1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DocumentLineIdentification1(soap, tag ? tag : "ns1:DocumentLineIdentification1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DocumentLineIdentification1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentLineIdentification1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentLineIdentification1 * SOAP_FMAC4 soap_get_ns1__DocumentLineIdentification1(struct soap *soap, ns1__DocumentLineIdentification1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentLineIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DocumentAdjustment1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DocumentAdjustment1::Amt = NULL;
	this->ns1__DocumentAdjustment1::CdtDbtInd = NULL;
	this->ns1__DocumentAdjustment1::Rsn = NULL;
	this->ns1__DocumentAdjustment1::AddtlInf = NULL;
}

void ns1__DocumentAdjustment1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__DocumentAdjustment1::Amt);
	soap_serialize_PointerTons1__CreditDebitCode(soap, &this->ns1__DocumentAdjustment1::CdtDbtInd);
	soap_serialize_PointerTons1__Max4Text(soap, &this->ns1__DocumentAdjustment1::Rsn);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__DocumentAdjustment1::AddtlInf);
#endif
}

int ns1__DocumentAdjustment1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentAdjustment1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentAdjustment1(struct soap *soap, const char *tag, int id, const ns1__DocumentAdjustment1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentAdjustment1), type))
		return soap->error;
	if (!a->ns1__DocumentAdjustment1::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__DocumentAdjustment1::Amt, ""))
		return soap->error;
	if (soap_out_PointerTons1__CreditDebitCode(soap, "CdtDbtInd", -1, &a->ns1__DocumentAdjustment1::CdtDbtInd, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max4Text(soap, "Rsn", -1, &a->ns1__DocumentAdjustment1::Rsn, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "AddtlInf", -1, &a->ns1__DocumentAdjustment1::AddtlInf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DocumentAdjustment1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DocumentAdjustment1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentAdjustment1 * SOAP_FMAC4 soap_in_ns1__DocumentAdjustment1(struct soap *soap, const char *tag, ns1__DocumentAdjustment1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DocumentAdjustment1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentAdjustment1, sizeof(ns1__DocumentAdjustment1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DocumentAdjustment1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DocumentAdjustment1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Amt1 = 1;
	size_t soap_flag_CdtDbtInd1 = 1;
	size_t soap_flag_Rsn1 = 1;
	size_t soap_flag_AddtlInf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__DocumentAdjustment1::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap_flag_CdtDbtInd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CreditDebitCode(soap, "CdtDbtInd", &a->ns1__DocumentAdjustment1::CdtDbtInd, "ns1:CreditDebitCode"))
				{	soap_flag_CdtDbtInd1--;
					continue;
				}
			}
			if (soap_flag_Rsn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max4Text(soap, "Rsn", &a->ns1__DocumentAdjustment1::Rsn, "ns1:Max4Text"))
				{	soap_flag_Rsn1--;
					continue;
				}
			}
			if (soap_flag_AddtlInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "AddtlInf", &a->ns1__DocumentAdjustment1::AddtlInf, "ns1:Max140Text"))
				{	soap_flag_AddtlInf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DocumentAdjustment1::Amt))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DocumentAdjustment1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentAdjustment1, SOAP_TYPE_ns1__DocumentAdjustment1, sizeof(ns1__DocumentAdjustment1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DocumentAdjustment1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentAdjustment1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentAdjustment1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DocumentAdjustment1 *p;
	size_t k = sizeof(ns1__DocumentAdjustment1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DocumentAdjustment1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DocumentAdjustment1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DocumentAdjustment1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DocumentAdjustment1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DocumentAdjustment1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DocumentAdjustment1(soap, tag ? tag : "ns1:DocumentAdjustment1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DocumentAdjustment1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentAdjustment1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentAdjustment1 * SOAP_FMAC4 soap_get_ns1__DocumentAdjustment1(struct soap *soap, ns1__DocumentAdjustment1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentAdjustment1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Document::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Document::CstmrCdtTrfInitn = NULL;
}

void ns1__Document::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CustomerCreditTransferInitiationV11(soap, &this->ns1__Document::CstmrCdtTrfInitn);
#endif
}

int ns1__Document::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Document(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Document(struct soap *soap, const char *tag, int id, const ns1__Document *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Document), type))
		return soap->error;
	if (!a->ns1__Document::CstmrCdtTrfInitn)
	{	if (soap_element_empty(soap, "CstmrCdtTrfInitn", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__CustomerCreditTransferInitiationV11(soap, "CstmrCdtTrfInitn", -1, &a->ns1__Document::CstmrCdtTrfInitn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Document::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Document(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Document * SOAP_FMAC4 soap_in_ns1__Document(struct soap *soap, const char *tag, ns1__Document *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Document*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Document, sizeof(ns1__Document), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Document)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Document *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CstmrCdtTrfInitn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CstmrCdtTrfInitn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CustomerCreditTransferInitiationV11(soap, "CstmrCdtTrfInitn", &a->ns1__Document::CstmrCdtTrfInitn, "ns1:CustomerCreditTransferInitiationV11"))
				{	soap_flag_CstmrCdtTrfInitn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__Document::CstmrCdtTrfInitn))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Document *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Document, SOAP_TYPE_ns1__Document, sizeof(ns1__Document), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Document * SOAP_FMAC2 soap_instantiate_ns1__Document(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Document(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Document *p;
	size_t k = sizeof(ns1__Document);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Document, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Document);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Document, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Document location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Document::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Document(soap, tag ? tag : "ns1:Document", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Document::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Document(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Document * SOAP_FMAC4 soap_get_ns1__Document(struct soap *soap, ns1__Document *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Document(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DiscountAmountType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DiscountAmountType1Choice::__union_DiscountAmountType1Choice = 0;
}

void ns1__DiscountAmountType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_DiscountAmountType1Choice(soap, this->ns1__DiscountAmountType1Choice::__union_DiscountAmountType1Choice, &this->ns1__DiscountAmountType1Choice::union_DiscountAmountType1Choice);
#endif
}

int ns1__DiscountAmountType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DiscountAmountType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiscountAmountType1Choice(struct soap *soap, const char *tag, int id, const ns1__DiscountAmountType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiscountAmountType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_DiscountAmountType1Choice(soap, a->ns1__DiscountAmountType1Choice::__union_DiscountAmountType1Choice, &a->ns1__DiscountAmountType1Choice::union_DiscountAmountType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DiscountAmountType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DiscountAmountType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DiscountAmountType1Choice * SOAP_FMAC4 soap_in_ns1__DiscountAmountType1Choice(struct soap *soap, const char *tag, ns1__DiscountAmountType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DiscountAmountType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiscountAmountType1Choice, sizeof(ns1__DiscountAmountType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_DiscountAmountType1Choice(soap, &a->__union_DiscountAmountType1Choice, &a->union_DiscountAmountType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__DiscountAmountType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiscountAmountType1Choice, SOAP_TYPE_ns1__DiscountAmountType1Choice, sizeof(ns1__DiscountAmountType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DiscountAmountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__DiscountAmountType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DiscountAmountType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DiscountAmountType1Choice *p;
	size_t k = sizeof(ns1__DiscountAmountType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DiscountAmountType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DiscountAmountType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DiscountAmountType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DiscountAmountType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DiscountAmountType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DiscountAmountType1Choice(soap, tag ? tag : "ns1:DiscountAmountType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DiscountAmountType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DiscountAmountType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DiscountAmountType1Choice * SOAP_FMAC4 soap_get_ns1__DiscountAmountType1Choice(struct soap *soap, ns1__DiscountAmountType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiscountAmountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DiscountAmountAndType1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DiscountAmountAndType1::Tp = NULL;
	this->ns1__DiscountAmountAndType1::Amt = NULL;
}

void ns1__DiscountAmountAndType1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DiscountAmountType1Choice(soap, &this->ns1__DiscountAmountAndType1::Tp);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &this->ns1__DiscountAmountAndType1::Amt);
#endif
}

int ns1__DiscountAmountAndType1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DiscountAmountAndType1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiscountAmountAndType1(struct soap *soap, const char *tag, int id, const ns1__DiscountAmountAndType1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiscountAmountAndType1), type))
		return soap->error;
	if (soap_out_PointerTons1__DiscountAmountType1Choice(soap, "Tp", -1, &a->ns1__DiscountAmountAndType1::Tp, ""))
		return soap->error;
	if (!a->ns1__DiscountAmountAndType1::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", -1, &a->ns1__DiscountAmountAndType1::Amt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DiscountAmountAndType1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DiscountAmountAndType1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DiscountAmountAndType1 * SOAP_FMAC4 soap_in_ns1__DiscountAmountAndType1(struct soap *soap, const char *tag, ns1__DiscountAmountAndType1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DiscountAmountAndType1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiscountAmountAndType1, sizeof(ns1__DiscountAmountAndType1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DiscountAmountAndType1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DiscountAmountAndType1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Amt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DiscountAmountType1Choice(soap, "Tp", &a->ns1__DiscountAmountAndType1::Tp, "ns1:DiscountAmountType1Choice"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "Amt", &a->ns1__DiscountAmountAndType1::Amt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DiscountAmountAndType1::Amt))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DiscountAmountAndType1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiscountAmountAndType1, SOAP_TYPE_ns1__DiscountAmountAndType1, sizeof(ns1__DiscountAmountAndType1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DiscountAmountAndType1 * SOAP_FMAC2 soap_instantiate_ns1__DiscountAmountAndType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DiscountAmountAndType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DiscountAmountAndType1 *p;
	size_t k = sizeof(ns1__DiscountAmountAndType1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DiscountAmountAndType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DiscountAmountAndType1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DiscountAmountAndType1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DiscountAmountAndType1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DiscountAmountAndType1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DiscountAmountAndType1(soap, tag ? tag : "ns1:DiscountAmountAndType1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DiscountAmountAndType1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DiscountAmountAndType1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DiscountAmountAndType1 * SOAP_FMAC4 soap_get_ns1__DiscountAmountAndType1(struct soap *soap, ns1__DiscountAmountAndType1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiscountAmountAndType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DatePeriod2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ISODate(soap, &this->ns1__DatePeriod2::FrDt);
	soap_default_ns1__ISODate(soap, &this->ns1__DatePeriod2::ToDt);
}

void ns1__DatePeriod2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__DatePeriod2::FrDt, SOAP_TYPE_ns1__ISODate);
	soap_serialize_ns1__ISODate(soap, &this->ns1__DatePeriod2::FrDt);
	soap_embedded(soap, &this->ns1__DatePeriod2::ToDt, SOAP_TYPE_ns1__ISODate);
	soap_serialize_ns1__ISODate(soap, &this->ns1__DatePeriod2::ToDt);
#endif
}

int ns1__DatePeriod2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DatePeriod2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DatePeriod2(struct soap *soap, const char *tag, int id, const ns1__DatePeriod2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DatePeriod2), type))
		return soap->error;
	if (soap_out_ns1__ISODate(soap, "FrDt", -1, &a->ns1__DatePeriod2::FrDt, ""))
		return soap->error;
	if (soap_out_ns1__ISODate(soap, "ToDt", -1, &a->ns1__DatePeriod2::ToDt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DatePeriod2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DatePeriod2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DatePeriod2 * SOAP_FMAC4 soap_in_ns1__DatePeriod2(struct soap *soap, const char *tag, ns1__DatePeriod2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DatePeriod2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DatePeriod2, sizeof(ns1__DatePeriod2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DatePeriod2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DatePeriod2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FrDt1 = 1;
	size_t soap_flag_ToDt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__ISODate(soap, "FrDt", &a->ns1__DatePeriod2::FrDt, "ns1:ISODate"))
				{	soap_flag_FrDt1--;
					continue;
				}
			}
			if (soap_flag_ToDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__ISODate(soap, "ToDt", &a->ns1__DatePeriod2::ToDt, "ns1:ISODate"))
				{	soap_flag_ToDt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrDt1 > 0 || soap_flag_ToDt1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DatePeriod2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DatePeriod2, SOAP_TYPE_ns1__DatePeriod2, sizeof(ns1__DatePeriod2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DatePeriod2 * SOAP_FMAC2 soap_instantiate_ns1__DatePeriod2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DatePeriod2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DatePeriod2 *p;
	size_t k = sizeof(ns1__DatePeriod2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DatePeriod2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DatePeriod2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DatePeriod2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DatePeriod2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DatePeriod2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DatePeriod2(soap, tag ? tag : "ns1:DatePeriod2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DatePeriod2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DatePeriod2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DatePeriod2 * SOAP_FMAC4 soap_get_ns1__DatePeriod2(struct soap *soap, ns1__DatePeriod2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DateAndPlaceOfBirth1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ISODate(soap, &this->ns1__DateAndPlaceOfBirth1::BirthDt);
	this->ns1__DateAndPlaceOfBirth1::PrvcOfBirth = NULL;
	soap_default_ns1__Max35Text(soap, &this->ns1__DateAndPlaceOfBirth1::CityOfBirth);
	soap_default_ns1__CountryCode(soap, &this->ns1__DateAndPlaceOfBirth1::CtryOfBirth);
}

void ns1__DateAndPlaceOfBirth1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__DateAndPlaceOfBirth1::BirthDt, SOAP_TYPE_ns1__ISODate);
	soap_serialize_ns1__ISODate(soap, &this->ns1__DateAndPlaceOfBirth1::BirthDt);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__DateAndPlaceOfBirth1::PrvcOfBirth);
	soap_embedded(soap, &this->ns1__DateAndPlaceOfBirth1::CityOfBirth, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__DateAndPlaceOfBirth1::CityOfBirth);
	soap_embedded(soap, &this->ns1__DateAndPlaceOfBirth1::CtryOfBirth, SOAP_TYPE_ns1__CountryCode);
	soap_serialize_ns1__CountryCode(soap, &this->ns1__DateAndPlaceOfBirth1::CtryOfBirth);
#endif
}

int ns1__DateAndPlaceOfBirth1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DateAndPlaceOfBirth1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateAndPlaceOfBirth1(struct soap *soap, const char *tag, int id, const ns1__DateAndPlaceOfBirth1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateAndPlaceOfBirth1), type))
		return soap->error;
	if (soap_out_ns1__ISODate(soap, "BirthDt", -1, &a->ns1__DateAndPlaceOfBirth1::BirthDt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "PrvcOfBirth", -1, &a->ns1__DateAndPlaceOfBirth1::PrvcOfBirth, ""))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "CityOfBirth", -1, &a->ns1__DateAndPlaceOfBirth1::CityOfBirth, ""))
		return soap->error;
	if (soap_out_ns1__CountryCode(soap, "CtryOfBirth", -1, &a->ns1__DateAndPlaceOfBirth1::CtryOfBirth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DateAndPlaceOfBirth1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DateAndPlaceOfBirth1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DateAndPlaceOfBirth1 * SOAP_FMAC4 soap_in_ns1__DateAndPlaceOfBirth1(struct soap *soap, const char *tag, ns1__DateAndPlaceOfBirth1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DateAndPlaceOfBirth1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, sizeof(ns1__DateAndPlaceOfBirth1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DateAndPlaceOfBirth1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DateAndPlaceOfBirth1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BirthDt1 = 1;
	size_t soap_flag_PrvcOfBirth1 = 1;
	size_t soap_flag_CityOfBirth1 = 1;
	size_t soap_flag_CtryOfBirth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BirthDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__ISODate(soap, "BirthDt", &a->ns1__DateAndPlaceOfBirth1::BirthDt, "ns1:ISODate"))
				{	soap_flag_BirthDt1--;
					continue;
				}
			}
			if (soap_flag_PrvcOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "PrvcOfBirth", &a->ns1__DateAndPlaceOfBirth1::PrvcOfBirth, "ns1:Max35Text"))
				{	soap_flag_PrvcOfBirth1--;
					continue;
				}
			}
			if (soap_flag_CityOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "CityOfBirth", &a->ns1__DateAndPlaceOfBirth1::CityOfBirth, "ns1:Max35Text"))
				{	soap_flag_CityOfBirth1--;
					continue;
				}
			}
			if (soap_flag_CtryOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__CountryCode(soap, "CtryOfBirth", &a->ns1__DateAndPlaceOfBirth1::CtryOfBirth, "ns1:CountryCode"))
				{	soap_flag_CtryOfBirth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BirthDt1 > 0 || soap_flag_CityOfBirth1 > 0 || soap_flag_CtryOfBirth1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DateAndPlaceOfBirth1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, sizeof(ns1__DateAndPlaceOfBirth1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DateAndPlaceOfBirth1 * SOAP_FMAC2 soap_instantiate_ns1__DateAndPlaceOfBirth1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DateAndPlaceOfBirth1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DateAndPlaceOfBirth1 *p;
	size_t k = sizeof(ns1__DateAndPlaceOfBirth1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DateAndPlaceOfBirth1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DateAndPlaceOfBirth1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DateAndPlaceOfBirth1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DateAndPlaceOfBirth1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DateAndPlaceOfBirth1(soap, tag ? tag : "ns1:DateAndPlaceOfBirth1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DateAndPlaceOfBirth1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DateAndPlaceOfBirth1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DateAndPlaceOfBirth1 * SOAP_FMAC4 soap_get_ns1__DateAndPlaceOfBirth1(struct soap *soap, ns1__DateAndPlaceOfBirth1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateAndPlaceOfBirth1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DateAndDateTime2Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DateAndDateTime2Choice::__union_DateAndDateTime2Choice = 0;
}

void ns1__DateAndDateTime2Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_DateAndDateTime2Choice(soap, this->ns1__DateAndDateTime2Choice::__union_DateAndDateTime2Choice, &this->ns1__DateAndDateTime2Choice::union_DateAndDateTime2Choice);
#endif
}

int ns1__DateAndDateTime2Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DateAndDateTime2Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateAndDateTime2Choice(struct soap *soap, const char *tag, int id, const ns1__DateAndDateTime2Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateAndDateTime2Choice), type))
		return soap->error;
	if (soap_out__ns1__union_DateAndDateTime2Choice(soap, a->ns1__DateAndDateTime2Choice::__union_DateAndDateTime2Choice, &a->ns1__DateAndDateTime2Choice::union_DateAndDateTime2Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DateAndDateTime2Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DateAndDateTime2Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DateAndDateTime2Choice * SOAP_FMAC4 soap_in_ns1__DateAndDateTime2Choice(struct soap *soap, const char *tag, ns1__DateAndDateTime2Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DateAndDateTime2Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateAndDateTime2Choice, sizeof(ns1__DateAndDateTime2Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_DateAndDateTime2Choice(soap, &a->__union_DateAndDateTime2Choice, &a->union_DateAndDateTime2Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__DateAndDateTime2Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateAndDateTime2Choice, SOAP_TYPE_ns1__DateAndDateTime2Choice, sizeof(ns1__DateAndDateTime2Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DateAndDateTime2Choice * SOAP_FMAC2 soap_instantiate_ns1__DateAndDateTime2Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DateAndDateTime2Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DateAndDateTime2Choice *p;
	size_t k = sizeof(ns1__DateAndDateTime2Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DateAndDateTime2Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DateAndDateTime2Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DateAndDateTime2Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DateAndDateTime2Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DateAndDateTime2Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DateAndDateTime2Choice(soap, tag ? tag : "ns1:DateAndDateTime2Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DateAndDateTime2Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DateAndDateTime2Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DateAndDateTime2Choice * SOAP_FMAC4 soap_get_ns1__DateAndDateTime2Choice(struct soap *soap, ns1__DateAndDateTime2Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateAndDateTime2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CustomerCreditTransferInitiationV11::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CustomerCreditTransferInitiationV11::GrpHdr = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap, &this->ns1__CustomerCreditTransferInitiationV11::PmtInf);
	soap_default_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, &this->ns1__CustomerCreditTransferInitiationV11::SplmtryData);
}

void ns1__CustomerCreditTransferInitiationV11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GroupHeader95(soap, &this->ns1__CustomerCreditTransferInitiationV11::GrpHdr);
	soap_serialize_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap, &this->ns1__CustomerCreditTransferInitiationV11::PmtInf);
	soap_serialize_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, &this->ns1__CustomerCreditTransferInitiationV11::SplmtryData);
#endif
}

int ns1__CustomerCreditTransferInitiationV11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CustomerCreditTransferInitiationV11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomerCreditTransferInitiationV11(struct soap *soap, const char *tag, int id, const ns1__CustomerCreditTransferInitiationV11 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11), type))
		return soap->error;
	if (!a->ns1__CustomerCreditTransferInitiationV11::GrpHdr)
	{	if (soap_element_empty(soap, "GrpHdr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GroupHeader95(soap, "GrpHdr", -1, &a->ns1__CustomerCreditTransferInitiationV11::GrpHdr, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap, "PmtInf", -1, &a->ns1__CustomerCreditTransferInitiationV11::PmtInf, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, "SplmtryData", -1, &a->ns1__CustomerCreditTransferInitiationV11::SplmtryData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CustomerCreditTransferInitiationV11::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CustomerCreditTransferInitiationV11(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CustomerCreditTransferInitiationV11 * SOAP_FMAC4 soap_in_ns1__CustomerCreditTransferInitiationV11(struct soap *soap, const char *tag, ns1__CustomerCreditTransferInitiationV11 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CustomerCreditTransferInitiationV11*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, sizeof(ns1__CustomerCreditTransferInitiationV11), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CustomerCreditTransferInitiationV11 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GrpHdr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GrpHdr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GroupHeader95(soap, "GrpHdr", &a->ns1__CustomerCreditTransferInitiationV11::GrpHdr, "ns1:GroupHeader95"))
				{	soap_flag_GrpHdr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap, "PmtInf", &a->ns1__CustomerCreditTransferInitiationV11::PmtInf, "ns1:PaymentInstruction40"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, "SplmtryData", &a->ns1__CustomerCreditTransferInitiationV11::SplmtryData, "ns1:SupplementaryData1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__CustomerCreditTransferInitiationV11::GrpHdr || a->ns1__CustomerCreditTransferInitiationV11::PmtInf.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CustomerCreditTransferInitiationV11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, sizeof(ns1__CustomerCreditTransferInitiationV11), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CustomerCreditTransferInitiationV11 * SOAP_FMAC2 soap_instantiate_ns1__CustomerCreditTransferInitiationV11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CustomerCreditTransferInitiationV11(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CustomerCreditTransferInitiationV11 *p;
	size_t k = sizeof(ns1__CustomerCreditTransferInitiationV11);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CustomerCreditTransferInitiationV11);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CustomerCreditTransferInitiationV11, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CustomerCreditTransferInitiationV11 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CustomerCreditTransferInitiationV11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CustomerCreditTransferInitiationV11(soap, tag ? tag : "ns1:CustomerCreditTransferInitiationV11", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CustomerCreditTransferInitiationV11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CustomerCreditTransferInitiationV11(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CustomerCreditTransferInitiationV11 * SOAP_FMAC4 soap_get_ns1__CustomerCreditTransferInitiationV11(struct soap *soap, ns1__CustomerCreditTransferInitiationV11 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomerCreditTransferInitiationV11(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CreditorReferenceType2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreditorReferenceType2::CdOrPrtry = NULL;
	this->ns1__CreditorReferenceType2::Issr = NULL;
}

void ns1__CreditorReferenceType2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CreditorReferenceType1Choice(soap, &this->ns1__CreditorReferenceType2::CdOrPrtry);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__CreditorReferenceType2::Issr);
#endif
}

int ns1__CreditorReferenceType2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreditorReferenceType2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditorReferenceType2(struct soap *soap, const char *tag, int id, const ns1__CreditorReferenceType2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditorReferenceType2), type))
		return soap->error;
	if (!a->ns1__CreditorReferenceType2::CdOrPrtry)
	{	if (soap_element_empty(soap, "CdOrPrtry", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__CreditorReferenceType1Choice(soap, "CdOrPrtry", -1, &a->ns1__CreditorReferenceType2::CdOrPrtry, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Issr", -1, &a->ns1__CreditorReferenceType2::Issr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CreditorReferenceType2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CreditorReferenceType2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreditorReferenceType2 * SOAP_FMAC4 soap_in_ns1__CreditorReferenceType2(struct soap *soap, const char *tag, ns1__CreditorReferenceType2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreditorReferenceType2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditorReferenceType2, sizeof(ns1__CreditorReferenceType2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CreditorReferenceType2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CreditorReferenceType2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CdOrPrtry1 = 1;
	size_t soap_flag_Issr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CdOrPrtry1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CreditorReferenceType1Choice(soap, "CdOrPrtry", &a->ns1__CreditorReferenceType2::CdOrPrtry, "ns1:CreditorReferenceType1Choice"))
				{	soap_flag_CdOrPrtry1--;
					continue;
				}
			}
			if (soap_flag_Issr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Issr", &a->ns1__CreditorReferenceType2::Issr, "ns1:Max35Text"))
				{	soap_flag_Issr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__CreditorReferenceType2::CdOrPrtry))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CreditorReferenceType2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditorReferenceType2, SOAP_TYPE_ns1__CreditorReferenceType2, sizeof(ns1__CreditorReferenceType2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CreditorReferenceType2 * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceType2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreditorReferenceType2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CreditorReferenceType2 *p;
	size_t k = sizeof(ns1__CreditorReferenceType2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CreditorReferenceType2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CreditorReferenceType2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CreditorReferenceType2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CreditorReferenceType2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CreditorReferenceType2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CreditorReferenceType2(soap, tag ? tag : "ns1:CreditorReferenceType2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreditorReferenceType2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreditorReferenceType2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreditorReferenceType2 * SOAP_FMAC4 soap_get_ns1__CreditorReferenceType2(struct soap *soap, ns1__CreditorReferenceType2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditorReferenceType2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CreditorReferenceType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreditorReferenceType1Choice::__union_CreditorReferenceType1Choice = 0;
}

void ns1__CreditorReferenceType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_CreditorReferenceType1Choice(soap, this->ns1__CreditorReferenceType1Choice::__union_CreditorReferenceType1Choice, &this->ns1__CreditorReferenceType1Choice::union_CreditorReferenceType1Choice);
#endif
}

int ns1__CreditorReferenceType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreditorReferenceType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditorReferenceType1Choice(struct soap *soap, const char *tag, int id, const ns1__CreditorReferenceType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditorReferenceType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_CreditorReferenceType1Choice(soap, a->ns1__CreditorReferenceType1Choice::__union_CreditorReferenceType1Choice, &a->ns1__CreditorReferenceType1Choice::union_CreditorReferenceType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CreditorReferenceType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CreditorReferenceType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreditorReferenceType1Choice * SOAP_FMAC4 soap_in_ns1__CreditorReferenceType1Choice(struct soap *soap, const char *tag, ns1__CreditorReferenceType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreditorReferenceType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditorReferenceType1Choice, sizeof(ns1__CreditorReferenceType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_CreditorReferenceType1Choice(soap, &a->__union_CreditorReferenceType1Choice, &a->union_CreditorReferenceType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__CreditorReferenceType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditorReferenceType1Choice, SOAP_TYPE_ns1__CreditorReferenceType1Choice, sizeof(ns1__CreditorReferenceType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CreditorReferenceType1Choice * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreditorReferenceType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CreditorReferenceType1Choice *p;
	size_t k = sizeof(ns1__CreditorReferenceType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CreditorReferenceType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CreditorReferenceType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CreditorReferenceType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CreditorReferenceType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CreditorReferenceType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CreditorReferenceType1Choice(soap, tag ? tag : "ns1:CreditorReferenceType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreditorReferenceType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreditorReferenceType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreditorReferenceType1Choice * SOAP_FMAC4 soap_get_ns1__CreditorReferenceType1Choice(struct soap *soap, ns1__CreditorReferenceType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditorReferenceType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CreditorReferenceInformation2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreditorReferenceInformation2::Tp = NULL;
	this->ns1__CreditorReferenceInformation2::Ref = NULL;
}

void ns1__CreditorReferenceInformation2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CreditorReferenceType2(soap, &this->ns1__CreditorReferenceInformation2::Tp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__CreditorReferenceInformation2::Ref);
#endif
}

int ns1__CreditorReferenceInformation2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreditorReferenceInformation2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditorReferenceInformation2(struct soap *soap, const char *tag, int id, const ns1__CreditorReferenceInformation2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditorReferenceInformation2), type))
		return soap->error;
	if (soap_out_PointerTons1__CreditorReferenceType2(soap, "Tp", -1, &a->ns1__CreditorReferenceInformation2::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Ref", -1, &a->ns1__CreditorReferenceInformation2::Ref, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CreditorReferenceInformation2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CreditorReferenceInformation2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreditorReferenceInformation2 * SOAP_FMAC4 soap_in_ns1__CreditorReferenceInformation2(struct soap *soap, const char *tag, ns1__CreditorReferenceInformation2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreditorReferenceInformation2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditorReferenceInformation2, sizeof(ns1__CreditorReferenceInformation2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CreditorReferenceInformation2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CreditorReferenceInformation2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Ref1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CreditorReferenceType2(soap, "Tp", &a->ns1__CreditorReferenceInformation2::Tp, "ns1:CreditorReferenceType2"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Ref1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Ref", &a->ns1__CreditorReferenceInformation2::Ref, "ns1:Max35Text"))
				{	soap_flag_Ref1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CreditorReferenceInformation2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditorReferenceInformation2, SOAP_TYPE_ns1__CreditorReferenceInformation2, sizeof(ns1__CreditorReferenceInformation2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CreditorReferenceInformation2 * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceInformation2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreditorReferenceInformation2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CreditorReferenceInformation2 *p;
	size_t k = sizeof(ns1__CreditorReferenceInformation2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CreditorReferenceInformation2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CreditorReferenceInformation2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CreditorReferenceInformation2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CreditorReferenceInformation2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CreditorReferenceInformation2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CreditorReferenceInformation2(soap, tag ? tag : "ns1:CreditorReferenceInformation2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreditorReferenceInformation2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreditorReferenceInformation2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreditorReferenceInformation2 * SOAP_FMAC4 soap_get_ns1__CreditorReferenceInformation2(struct soap *soap, ns1__CreditorReferenceInformation2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditorReferenceInformation2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CreditTransferTransaction54::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreditTransferTransaction54::PmtId = NULL;
	this->ns1__CreditTransferTransaction54::PmtTpInf = NULL;
	this->ns1__CreditTransferTransaction54::Amt = NULL;
	this->ns1__CreditTransferTransaction54::XchgRateInf = NULL;
	this->ns1__CreditTransferTransaction54::ChrgBr = NULL;
	this->ns1__CreditTransferTransaction54::MndtRltdInf = NULL;
	this->ns1__CreditTransferTransaction54::ChqInstr = NULL;
	this->ns1__CreditTransferTransaction54::UltmtDbtr = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt1 = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt1Acct = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt2 = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt2Acct = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt3 = NULL;
	this->ns1__CreditTransferTransaction54::IntrmyAgt3Acct = NULL;
	this->ns1__CreditTransferTransaction54::CdtrAgt = NULL;
	this->ns1__CreditTransferTransaction54::CdtrAgtAcct = NULL;
	this->ns1__CreditTransferTransaction54::Cdtr = NULL;
	this->ns1__CreditTransferTransaction54::CdtrAcct = NULL;
	this->ns1__CreditTransferTransaction54::UltmtCdtr = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap, &this->ns1__CreditTransferTransaction54::InstrForCdtrAgt);
	this->ns1__CreditTransferTransaction54::InstrForDbtrAgt = NULL;
	this->ns1__CreditTransferTransaction54::Purp = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap, &this->ns1__CreditTransferTransaction54::RgltryRptg);
	this->ns1__CreditTransferTransaction54::Tax = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap, &this->ns1__CreditTransferTransaction54::RltdRmtInf);
	this->ns1__CreditTransferTransaction54::RmtInf = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, &this->ns1__CreditTransferTransaction54::SplmtryData);
}

void ns1__CreditTransferTransaction54::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__PaymentIdentification6(soap, &this->ns1__CreditTransferTransaction54::PmtId);
	soap_serialize_PointerTons1__PaymentTypeInformation26(soap, &this->ns1__CreditTransferTransaction54::PmtTpInf);
	soap_serialize_PointerTons1__AmountType4Choice(soap, &this->ns1__CreditTransferTransaction54::Amt);
	soap_serialize_PointerTons1__ExchangeRate1(soap, &this->ns1__CreditTransferTransaction54::XchgRateInf);
	soap_serialize_PointerTons1__ChargeBearerType1Code(soap, &this->ns1__CreditTransferTransaction54::ChrgBr);
	soap_serialize_PointerTons1__CreditTransferMandateData1(soap, &this->ns1__CreditTransferTransaction54::MndtRltdInf);
	soap_serialize_PointerTons1__Cheque11(soap, &this->ns1__CreditTransferTransaction54::ChqInstr);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__CreditTransferTransaction54::UltmtDbtr);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt1);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt1Acct);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt2);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt2Acct);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt3);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__CreditTransferTransaction54::IntrmyAgt3Acct);
	soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, &this->ns1__CreditTransferTransaction54::CdtrAgt);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__CreditTransferTransaction54::CdtrAgtAcct);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__CreditTransferTransaction54::Cdtr);
	soap_serialize_PointerTons1__CashAccount40(soap, &this->ns1__CreditTransferTransaction54::CdtrAcct);
	soap_serialize_PointerTons1__PartyIdentification135(soap, &this->ns1__CreditTransferTransaction54::UltmtCdtr);
	soap_serialize_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap, &this->ns1__CreditTransferTransaction54::InstrForCdtrAgt);
	soap_serialize_PointerTons1__InstructionForDebtorAgent1(soap, &this->ns1__CreditTransferTransaction54::InstrForDbtrAgt);
	soap_serialize_PointerTons1__Purpose2Choice(soap, &this->ns1__CreditTransferTransaction54::Purp);
	soap_serialize_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap, &this->ns1__CreditTransferTransaction54::RgltryRptg);
	soap_serialize_PointerTons1__TaxInformation10(soap, &this->ns1__CreditTransferTransaction54::Tax);
	soap_serialize_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap, &this->ns1__CreditTransferTransaction54::RltdRmtInf);
	soap_serialize_PointerTons1__RemittanceInformation21(soap, &this->ns1__CreditTransferTransaction54::RmtInf);
	soap_serialize_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, &this->ns1__CreditTransferTransaction54::SplmtryData);
#endif
}

int ns1__CreditTransferTransaction54::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreditTransferTransaction54(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditTransferTransaction54(struct soap *soap, const char *tag, int id, const ns1__CreditTransferTransaction54 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditTransferTransaction54), type))
		return soap->error;
	if (!a->ns1__CreditTransferTransaction54::PmtId)
	{	if (soap_element_empty(soap, "PmtId", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__PaymentIdentification6(soap, "PmtId", -1, &a->ns1__CreditTransferTransaction54::PmtId, ""))
		return soap->error;
	if (soap_out_PointerTons1__PaymentTypeInformation26(soap, "PmtTpInf", -1, &a->ns1__CreditTransferTransaction54::PmtTpInf, ""))
		return soap->error;
	if (!a->ns1__CreditTransferTransaction54::Amt)
	{	if (soap_element_empty(soap, "Amt", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__AmountType4Choice(soap, "Amt", -1, &a->ns1__CreditTransferTransaction54::Amt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ExchangeRate1(soap, "XchgRateInf", -1, &a->ns1__CreditTransferTransaction54::XchgRateInf, ""))
		return soap->error;
	if (soap_out_PointerTons1__ChargeBearerType1Code(soap, "ChrgBr", -1, &a->ns1__CreditTransferTransaction54::ChrgBr, ""))
		return soap->error;
	if (soap_out_PointerTons1__CreditTransferMandateData1(soap, "MndtRltdInf", -1, &a->ns1__CreditTransferTransaction54::MndtRltdInf, ""))
		return soap->error;
	if (soap_out_PointerTons1__Cheque11(soap, "ChqInstr", -1, &a->ns1__CreditTransferTransaction54::ChqInstr, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "UltmtDbtr", -1, &a->ns1__CreditTransferTransaction54::UltmtDbtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt1", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt1, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "IntrmyAgt1Acct", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt1Acct, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt2", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt2, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "IntrmyAgt2Acct", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt2Acct, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt3", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt3, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "IntrmyAgt3Acct", -1, &a->ns1__CreditTransferTransaction54::IntrmyAgt3Acct, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "CdtrAgt", -1, &a->ns1__CreditTransferTransaction54::CdtrAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "CdtrAgtAcct", -1, &a->ns1__CreditTransferTransaction54::CdtrAgtAcct, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "Cdtr", -1, &a->ns1__CreditTransferTransaction54::Cdtr, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccount40(soap, "CdtrAcct", -1, &a->ns1__CreditTransferTransaction54::CdtrAcct, ""))
		return soap->error;
	if (soap_out_PointerTons1__PartyIdentification135(soap, "UltmtCdtr", -1, &a->ns1__CreditTransferTransaction54::UltmtCdtr, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap, "InstrForCdtrAgt", -1, &a->ns1__CreditTransferTransaction54::InstrForCdtrAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstructionForDebtorAgent1(soap, "InstrForDbtrAgt", -1, &a->ns1__CreditTransferTransaction54::InstrForDbtrAgt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Purpose2Choice(soap, "Purp", -1, &a->ns1__CreditTransferTransaction54::Purp, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap, "RgltryRptg", -1, &a->ns1__CreditTransferTransaction54::RgltryRptg, ""))
		return soap->error;
	if (soap_out_PointerTons1__TaxInformation10(soap, "Tax", -1, &a->ns1__CreditTransferTransaction54::Tax, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap, "RltdRmtInf", -1, &a->ns1__CreditTransferTransaction54::RltdRmtInf, ""))
		return soap->error;
	if (soap_out_PointerTons1__RemittanceInformation21(soap, "RmtInf", -1, &a->ns1__CreditTransferTransaction54::RmtInf, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, "SplmtryData", -1, &a->ns1__CreditTransferTransaction54::SplmtryData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CreditTransferTransaction54::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CreditTransferTransaction54(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreditTransferTransaction54 * SOAP_FMAC4 soap_in_ns1__CreditTransferTransaction54(struct soap *soap, const char *tag, ns1__CreditTransferTransaction54 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreditTransferTransaction54*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditTransferTransaction54, sizeof(ns1__CreditTransferTransaction54), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CreditTransferTransaction54)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CreditTransferTransaction54 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PmtId1 = 1;
	size_t soap_flag_PmtTpInf1 = 1;
	size_t soap_flag_Amt1 = 1;
	size_t soap_flag_XchgRateInf1 = 1;
	size_t soap_flag_ChrgBr1 = 1;
	size_t soap_flag_MndtRltdInf1 = 1;
	size_t soap_flag_ChqInstr1 = 1;
	size_t soap_flag_UltmtDbtr1 = 1;
	size_t soap_flag_IntrmyAgt11 = 1;
	size_t soap_flag_IntrmyAgt1Acct1 = 1;
	size_t soap_flag_IntrmyAgt21 = 1;
	size_t soap_flag_IntrmyAgt2Acct1 = 1;
	size_t soap_flag_IntrmyAgt31 = 1;
	size_t soap_flag_IntrmyAgt3Acct1 = 1;
	size_t soap_flag_CdtrAgt1 = 1;
	size_t soap_flag_CdtrAgtAcct1 = 1;
	size_t soap_flag_Cdtr1 = 1;
	size_t soap_flag_CdtrAcct1 = 1;
	size_t soap_flag_UltmtCdtr1 = 1;
	size_t soap_flag_InstrForDbtrAgt1 = 1;
	size_t soap_flag_Purp1 = 1;
	size_t soap_flag_Tax1 = 1;
	size_t soap_flag_RmtInf1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PmtId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PaymentIdentification6(soap, "PmtId", &a->ns1__CreditTransferTransaction54::PmtId, "ns1:PaymentIdentification6"))
				{	soap_flag_PmtId1--;
					continue;
				}
			}
			if (soap_flag_PmtTpInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PaymentTypeInformation26(soap, "PmtTpInf", &a->ns1__CreditTransferTransaction54::PmtTpInf, "ns1:PaymentTypeInformation26"))
				{	soap_flag_PmtTpInf1--;
					continue;
				}
			}
			if (soap_flag_Amt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AmountType4Choice(soap, "Amt", &a->ns1__CreditTransferTransaction54::Amt, "ns1:AmountType4Choice"))
				{	soap_flag_Amt1--;
					continue;
				}
			}
			if (soap_flag_XchgRateInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ExchangeRate1(soap, "XchgRateInf", &a->ns1__CreditTransferTransaction54::XchgRateInf, "ns1:ExchangeRate1"))
				{	soap_flag_XchgRateInf1--;
					continue;
				}
			}
			if (soap_flag_ChrgBr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ChargeBearerType1Code(soap, "ChrgBr", &a->ns1__CreditTransferTransaction54::ChrgBr, "ns1:ChargeBearerType1Code"))
				{	soap_flag_ChrgBr1--;
					continue;
				}
			}
			if (soap_flag_MndtRltdInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CreditTransferMandateData1(soap, "MndtRltdInf", &a->ns1__CreditTransferTransaction54::MndtRltdInf, "ns1:CreditTransferMandateData1"))
				{	soap_flag_MndtRltdInf1--;
					continue;
				}
			}
			if (soap_flag_ChqInstr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Cheque11(soap, "ChqInstr", &a->ns1__CreditTransferTransaction54::ChqInstr, "ns1:Cheque11"))
				{	soap_flag_ChqInstr1--;
					continue;
				}
			}
			if (soap_flag_UltmtDbtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "UltmtDbtr", &a->ns1__CreditTransferTransaction54::UltmtDbtr, "ns1:PartyIdentification135"))
				{	soap_flag_UltmtDbtr1--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt1", &a->ns1__CreditTransferTransaction54::IntrmyAgt1, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_IntrmyAgt11--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt1Acct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "IntrmyAgt1Acct", &a->ns1__CreditTransferTransaction54::IntrmyAgt1Acct, "ns1:CashAccount40"))
				{	soap_flag_IntrmyAgt1Acct1--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt2", &a->ns1__CreditTransferTransaction54::IntrmyAgt2, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_IntrmyAgt21--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt2Acct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "IntrmyAgt2Acct", &a->ns1__CreditTransferTransaction54::IntrmyAgt2Acct, "ns1:CashAccount40"))
				{	soap_flag_IntrmyAgt2Acct1--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt31 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "IntrmyAgt3", &a->ns1__CreditTransferTransaction54::IntrmyAgt3, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_IntrmyAgt31--;
					continue;
				}
			}
			if (soap_flag_IntrmyAgt3Acct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "IntrmyAgt3Acct", &a->ns1__CreditTransferTransaction54::IntrmyAgt3Acct, "ns1:CashAccount40"))
				{	soap_flag_IntrmyAgt3Acct1--;
					continue;
				}
			}
			if (soap_flag_CdtrAgt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, "CdtrAgt", &a->ns1__CreditTransferTransaction54::CdtrAgt, "ns1:BranchAndFinancialInstitutionIdentification6"))
				{	soap_flag_CdtrAgt1--;
					continue;
				}
			}
			if (soap_flag_CdtrAgtAcct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "CdtrAgtAcct", &a->ns1__CreditTransferTransaction54::CdtrAgtAcct, "ns1:CashAccount40"))
				{	soap_flag_CdtrAgtAcct1--;
					continue;
				}
			}
			if (soap_flag_Cdtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "Cdtr", &a->ns1__CreditTransferTransaction54::Cdtr, "ns1:PartyIdentification135"))
				{	soap_flag_Cdtr1--;
					continue;
				}
			}
			if (soap_flag_CdtrAcct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccount40(soap, "CdtrAcct", &a->ns1__CreditTransferTransaction54::CdtrAcct, "ns1:CashAccount40"))
				{	soap_flag_CdtrAcct1--;
					continue;
				}
			}
			if (soap_flag_UltmtCdtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PartyIdentification135(soap, "UltmtCdtr", &a->ns1__CreditTransferTransaction54::UltmtCdtr, "ns1:PartyIdentification135"))
				{	soap_flag_UltmtCdtr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap, "InstrForCdtrAgt", &a->ns1__CreditTransferTransaction54::InstrForCdtrAgt, "ns1:InstructionForCreditorAgent3"))
					continue;
			}
			if (soap_flag_InstrForDbtrAgt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstructionForDebtorAgent1(soap, "InstrForDbtrAgt", &a->ns1__CreditTransferTransaction54::InstrForDbtrAgt, "ns1:InstructionForDebtorAgent1"))
				{	soap_flag_InstrForDbtrAgt1--;
					continue;
				}
			}
			if (soap_flag_Purp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Purpose2Choice(soap, "Purp", &a->ns1__CreditTransferTransaction54::Purp, "ns1:Purpose2Choice"))
				{	soap_flag_Purp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap, "RgltryRptg", &a->ns1__CreditTransferTransaction54::RgltryRptg, "ns1:RegulatoryReporting3"))
					continue;
			}
			if (soap_flag_Tax1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TaxInformation10(soap, "Tax", &a->ns1__CreditTransferTransaction54::Tax, "ns1:TaxInformation10"))
				{	soap_flag_Tax1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap, "RltdRmtInf", &a->ns1__CreditTransferTransaction54::RltdRmtInf, "ns1:RemittanceLocation7"))
					continue;
			}
			if (soap_flag_RmtInf1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RemittanceInformation21(soap, "RmtInf", &a->ns1__CreditTransferTransaction54::RmtInf, "ns1:RemittanceInformation21"))
				{	soap_flag_RmtInf1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap, "SplmtryData", &a->ns1__CreditTransferTransaction54::SplmtryData, "ns1:SupplementaryData1"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__CreditTransferTransaction54::PmtId || !a->ns1__CreditTransferTransaction54::Amt || a->ns1__CreditTransferTransaction54::RgltryRptg.size() > 10 || a->ns1__CreditTransferTransaction54::RltdRmtInf.size() > 10))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CreditTransferTransaction54 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditTransferTransaction54, SOAP_TYPE_ns1__CreditTransferTransaction54, sizeof(ns1__CreditTransferTransaction54), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CreditTransferTransaction54 * SOAP_FMAC2 soap_instantiate_ns1__CreditTransferTransaction54(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreditTransferTransaction54(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CreditTransferTransaction54 *p;
	size_t k = sizeof(ns1__CreditTransferTransaction54);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CreditTransferTransaction54, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CreditTransferTransaction54);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CreditTransferTransaction54, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CreditTransferTransaction54 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CreditTransferTransaction54::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CreditTransferTransaction54(soap, tag ? tag : "ns1:CreditTransferTransaction54", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreditTransferTransaction54::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreditTransferTransaction54(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreditTransferTransaction54 * SOAP_FMAC4 soap_get_ns1__CreditTransferTransaction54(struct soap *soap, ns1__CreditTransferTransaction54 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditTransferTransaction54(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CreditTransferMandateData1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreditTransferMandateData1::MndtId = NULL;
	this->ns1__CreditTransferMandateData1::Tp = NULL;
	this->ns1__CreditTransferMandateData1::DtOfSgntr = NULL;
	this->ns1__CreditTransferMandateData1::DtOfVrfctn = NULL;
	this->ns1__CreditTransferMandateData1::ElctrncSgntr = NULL;
	this->ns1__CreditTransferMandateData1::FrstPmtDt = NULL;
	this->ns1__CreditTransferMandateData1::FnlPmtDt = NULL;
	this->ns1__CreditTransferMandateData1::Frqcy = NULL;
	this->ns1__CreditTransferMandateData1::Rsn = NULL;
}

void ns1__CreditTransferMandateData1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__CreditTransferMandateData1::MndtId);
	soap_serialize_PointerTons1__MandateTypeInformation2(soap, &this->ns1__CreditTransferMandateData1::Tp);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__CreditTransferMandateData1::DtOfSgntr);
	soap_serialize_PointerTons1__ISODateTime(soap, &this->ns1__CreditTransferMandateData1::DtOfVrfctn);
	soap_serialize_PointerTons1__Max10KBinary(soap, &this->ns1__CreditTransferMandateData1::ElctrncSgntr);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__CreditTransferMandateData1::FrstPmtDt);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__CreditTransferMandateData1::FnlPmtDt);
	soap_serialize_PointerTons1__Frequency36Choice(soap, &this->ns1__CreditTransferMandateData1::Frqcy);
	soap_serialize_PointerTons1__MandateSetupReason1Choice(soap, &this->ns1__CreditTransferMandateData1::Rsn);
#endif
}

int ns1__CreditTransferMandateData1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreditTransferMandateData1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreditTransferMandateData1(struct soap *soap, const char *tag, int id, const ns1__CreditTransferMandateData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreditTransferMandateData1), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "MndtId", -1, &a->ns1__CreditTransferMandateData1::MndtId, ""))
		return soap->error;
	if (soap_out_PointerTons1__MandateTypeInformation2(soap, "Tp", -1, &a->ns1__CreditTransferMandateData1::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "DtOfSgntr", -1, &a->ns1__CreditTransferMandateData1::DtOfSgntr, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODateTime(soap, "DtOfVrfctn", -1, &a->ns1__CreditTransferMandateData1::DtOfVrfctn, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max10KBinary(soap, "ElctrncSgntr", -1, &a->ns1__CreditTransferMandateData1::ElctrncSgntr, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "FrstPmtDt", -1, &a->ns1__CreditTransferMandateData1::FrstPmtDt, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "FnlPmtDt", -1, &a->ns1__CreditTransferMandateData1::FnlPmtDt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Frequency36Choice(soap, "Frqcy", -1, &a->ns1__CreditTransferMandateData1::Frqcy, ""))
		return soap->error;
	if (soap_out_PointerTons1__MandateSetupReason1Choice(soap, "Rsn", -1, &a->ns1__CreditTransferMandateData1::Rsn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CreditTransferMandateData1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CreditTransferMandateData1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreditTransferMandateData1 * SOAP_FMAC4 soap_in_ns1__CreditTransferMandateData1(struct soap *soap, const char *tag, ns1__CreditTransferMandateData1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreditTransferMandateData1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreditTransferMandateData1, sizeof(ns1__CreditTransferMandateData1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CreditTransferMandateData1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CreditTransferMandateData1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MndtId1 = 1;
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_DtOfSgntr1 = 1;
	size_t soap_flag_DtOfVrfctn1 = 1;
	size_t soap_flag_ElctrncSgntr1 = 1;
	size_t soap_flag_FrstPmtDt1 = 1;
	size_t soap_flag_FnlPmtDt1 = 1;
	size_t soap_flag_Frqcy1 = 1;
	size_t soap_flag_Rsn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MndtId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "MndtId", &a->ns1__CreditTransferMandateData1::MndtId, "ns1:Max35Text"))
				{	soap_flag_MndtId1--;
					continue;
				}
			}
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MandateTypeInformation2(soap, "Tp", &a->ns1__CreditTransferMandateData1::Tp, "ns1:MandateTypeInformation2"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_DtOfSgntr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "DtOfSgntr", &a->ns1__CreditTransferMandateData1::DtOfSgntr, "ns1:ISODate"))
				{	soap_flag_DtOfSgntr1--;
					continue;
				}
			}
			if (soap_flag_DtOfVrfctn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ISODateTime(soap, "DtOfVrfctn", &a->ns1__CreditTransferMandateData1::DtOfVrfctn, "ns1:ISODateTime"))
				{	soap_flag_DtOfVrfctn1--;
					continue;
				}
			}
			if (soap_flag_ElctrncSgntr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Max10KBinary(soap, "ElctrncSgntr", &a->ns1__CreditTransferMandateData1::ElctrncSgntr, "ns1:Max10KBinary"))
				{	soap_flag_ElctrncSgntr1--;
					continue;
				}
			}
			if (soap_flag_FrstPmtDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "FrstPmtDt", &a->ns1__CreditTransferMandateData1::FrstPmtDt, "ns1:ISODate"))
				{	soap_flag_FrstPmtDt1--;
					continue;
				}
			}
			if (soap_flag_FnlPmtDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "FnlPmtDt", &a->ns1__CreditTransferMandateData1::FnlPmtDt, "ns1:ISODate"))
				{	soap_flag_FnlPmtDt1--;
					continue;
				}
			}
			if (soap_flag_Frqcy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Frequency36Choice(soap, "Frqcy", &a->ns1__CreditTransferMandateData1::Frqcy, "ns1:Frequency36Choice"))
				{	soap_flag_Frqcy1--;
					continue;
				}
			}
			if (soap_flag_Rsn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MandateSetupReason1Choice(soap, "Rsn", &a->ns1__CreditTransferMandateData1::Rsn, "ns1:MandateSetupReason1Choice"))
				{	soap_flag_Rsn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CreditTransferMandateData1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreditTransferMandateData1, SOAP_TYPE_ns1__CreditTransferMandateData1, sizeof(ns1__CreditTransferMandateData1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CreditTransferMandateData1 * SOAP_FMAC2 soap_instantiate_ns1__CreditTransferMandateData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreditTransferMandateData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CreditTransferMandateData1 *p;
	size_t k = sizeof(ns1__CreditTransferMandateData1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CreditTransferMandateData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CreditTransferMandateData1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CreditTransferMandateData1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CreditTransferMandateData1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CreditTransferMandateData1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CreditTransferMandateData1(soap, tag ? tag : "ns1:CreditTransferMandateData1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreditTransferMandateData1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreditTransferMandateData1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreditTransferMandateData1 * SOAP_FMAC4 soap_get_ns1__CreditTransferMandateData1(struct soap *soap, ns1__CreditTransferMandateData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreditTransferMandateData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Contact4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Contact4::NmPrfx = NULL;
	this->ns1__Contact4::Nm = NULL;
	this->ns1__Contact4::PhneNb = NULL;
	this->ns1__Contact4::MobNb = NULL;
	this->ns1__Contact4::FaxNb = NULL;
	this->ns1__Contact4::EmailAdr = NULL;
	this->ns1__Contact4::EmailPurp = NULL;
	this->ns1__Contact4::JobTitl = NULL;
	this->ns1__Contact4::Rspnsblty = NULL;
	this->ns1__Contact4::Dept = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__OtherContact1(soap, &this->ns1__Contact4::Othr);
	this->ns1__Contact4::PrefrdMtd = NULL;
}

void ns1__Contact4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NamePrefix2Code(soap, &this->ns1__Contact4::NmPrfx);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__Contact4::Nm);
	soap_serialize_PointerTons1__PhoneNumber(soap, &this->ns1__Contact4::PhneNb);
	soap_serialize_PointerTons1__PhoneNumber(soap, &this->ns1__Contact4::MobNb);
	soap_serialize_PointerTons1__PhoneNumber(soap, &this->ns1__Contact4::FaxNb);
	soap_serialize_PointerTons1__Max2048Text(soap, &this->ns1__Contact4::EmailAdr);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Contact4::EmailPurp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Contact4::JobTitl);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Contact4::Rspnsblty);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__Contact4::Dept);
	soap_serialize_std__vectorTemplateOfPointerTons1__OtherContact1(soap, &this->ns1__Contact4::Othr);
	soap_serialize_PointerTons1__PreferredContactMethod1Code(soap, &this->ns1__Contact4::PrefrdMtd);
#endif
}

int ns1__Contact4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Contact4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Contact4(struct soap *soap, const char *tag, int id, const ns1__Contact4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Contact4), type))
		return soap->error;
	if (soap_out_PointerTons1__NamePrefix2Code(soap, "NmPrfx", -1, &a->ns1__Contact4::NmPrfx, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__Contact4::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumber(soap, "PhneNb", -1, &a->ns1__Contact4::PhneNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumber(soap, "MobNb", -1, &a->ns1__Contact4::MobNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumber(soap, "FaxNb", -1, &a->ns1__Contact4::FaxNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max2048Text(soap, "EmailAdr", -1, &a->ns1__Contact4::EmailAdr, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "EmailPurp", -1, &a->ns1__Contact4::EmailPurp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "JobTitl", -1, &a->ns1__Contact4::JobTitl, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Rspnsblty", -1, &a->ns1__Contact4::Rspnsblty, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "Dept", -1, &a->ns1__Contact4::Dept, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__OtherContact1(soap, "Othr", -1, &a->ns1__Contact4::Othr, ""))
		return soap->error;
	if (soap_out_PointerTons1__PreferredContactMethod1Code(soap, "PrefrdMtd", -1, &a->ns1__Contact4::PrefrdMtd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Contact4::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Contact4(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Contact4 * SOAP_FMAC4 soap_in_ns1__Contact4(struct soap *soap, const char *tag, ns1__Contact4 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Contact4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Contact4, sizeof(ns1__Contact4), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Contact4)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Contact4 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NmPrfx1 = 1;
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_PhneNb1 = 1;
	size_t soap_flag_MobNb1 = 1;
	size_t soap_flag_FaxNb1 = 1;
	size_t soap_flag_EmailAdr1 = 1;
	size_t soap_flag_EmailPurp1 = 1;
	size_t soap_flag_JobTitl1 = 1;
	size_t soap_flag_Rspnsblty1 = 1;
	size_t soap_flag_Dept1 = 1;
	size_t soap_flag_PrefrdMtd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NmPrfx1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NamePrefix2Code(soap, "NmPrfx", &a->ns1__Contact4::NmPrfx, "ns1:NamePrefix2Code"))
				{	soap_flag_NmPrfx1--;
					continue;
				}
			}
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__Contact4::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_PhneNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__PhoneNumber(soap, "PhneNb", &a->ns1__Contact4::PhneNb, "ns1:PhoneNumber"))
				{	soap_flag_PhneNb1--;
					continue;
				}
			}
			if (soap_flag_MobNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__PhoneNumber(soap, "MobNb", &a->ns1__Contact4::MobNb, "ns1:PhoneNumber"))
				{	soap_flag_MobNb1--;
					continue;
				}
			}
			if (soap_flag_FaxNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__PhoneNumber(soap, "FaxNb", &a->ns1__Contact4::FaxNb, "ns1:PhoneNumber"))
				{	soap_flag_FaxNb1--;
					continue;
				}
			}
			if (soap_flag_EmailAdr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max2048Text(soap, "EmailAdr", &a->ns1__Contact4::EmailAdr, "ns1:Max2048Text"))
				{	soap_flag_EmailAdr1--;
					continue;
				}
			}
			if (soap_flag_EmailPurp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "EmailPurp", &a->ns1__Contact4::EmailPurp, "ns1:Max35Text"))
				{	soap_flag_EmailPurp1--;
					continue;
				}
			}
			if (soap_flag_JobTitl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "JobTitl", &a->ns1__Contact4::JobTitl, "ns1:Max35Text"))
				{	soap_flag_JobTitl1--;
					continue;
				}
			}
			if (soap_flag_Rspnsblty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Rspnsblty", &a->ns1__Contact4::Rspnsblty, "ns1:Max35Text"))
				{	soap_flag_Rspnsblty1--;
					continue;
				}
			}
			if (soap_flag_Dept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "Dept", &a->ns1__Contact4::Dept, "ns1:Max70Text"))
				{	soap_flag_Dept1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__OtherContact1(soap, "Othr", &a->ns1__Contact4::Othr, "ns1:OtherContact1"))
					continue;
			}
			if (soap_flag_PrefrdMtd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PreferredContactMethod1Code(soap, "PrefrdMtd", &a->ns1__Contact4::PrefrdMtd, "ns1:PreferredContactMethod1Code"))
				{	soap_flag_PrefrdMtd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Contact4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Contact4, SOAP_TYPE_ns1__Contact4, sizeof(ns1__Contact4), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Contact4 * SOAP_FMAC2 soap_instantiate_ns1__Contact4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Contact4(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Contact4 *p;
	size_t k = sizeof(ns1__Contact4);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Contact4, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Contact4);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Contact4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Contact4 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Contact4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Contact4(soap, tag ? tag : "ns1:Contact4", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Contact4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Contact4(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Contact4 * SOAP_FMAC4 soap_get_ns1__Contact4(struct soap *soap, ns1__Contact4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Contact4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ClearingSystemMemberIdentification2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ClearingSystemMemberIdentification2::ClrSysId = NULL;
	soap_default_ns1__Max35Text(soap, &this->ns1__ClearingSystemMemberIdentification2::MmbId);
}

void ns1__ClearingSystemMemberIdentification2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ClearingSystemIdentification2Choice(soap, &this->ns1__ClearingSystemMemberIdentification2::ClrSysId);
	soap_embedded(soap, &this->ns1__ClearingSystemMemberIdentification2::MmbId, SOAP_TYPE_ns1__Max35Text);
	soap_serialize_ns1__Max35Text(soap, &this->ns1__ClearingSystemMemberIdentification2::MmbId);
#endif
}

int ns1__ClearingSystemMemberIdentification2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClearingSystemMemberIdentification2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearingSystemMemberIdentification2(struct soap *soap, const char *tag, int id, const ns1__ClearingSystemMemberIdentification2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2), type))
		return soap->error;
	if (soap_out_PointerTons1__ClearingSystemIdentification2Choice(soap, "ClrSysId", -1, &a->ns1__ClearingSystemMemberIdentification2::ClrSysId, ""))
		return soap->error;
	if (soap_out_ns1__Max35Text(soap, "MmbId", -1, &a->ns1__ClearingSystemMemberIdentification2::MmbId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ClearingSystemMemberIdentification2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ClearingSystemMemberIdentification2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClearingSystemMemberIdentification2 * SOAP_FMAC4 soap_in_ns1__ClearingSystemMemberIdentification2(struct soap *soap, const char *tag, ns1__ClearingSystemMemberIdentification2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClearingSystemMemberIdentification2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, sizeof(ns1__ClearingSystemMemberIdentification2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ClearingSystemMemberIdentification2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ClearingSystemMemberIdentification2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ClrSysId1 = 1;
	size_t soap_flag_MmbId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClrSysId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ClearingSystemIdentification2Choice(soap, "ClrSysId", &a->ns1__ClearingSystemMemberIdentification2::ClrSysId, "ns1:ClearingSystemIdentification2Choice"))
				{	soap_flag_ClrSysId1--;
					continue;
				}
			}
			if (soap_flag_MmbId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns1__Max35Text(soap, "MmbId", &a->ns1__ClearingSystemMemberIdentification2::MmbId, "ns1:Max35Text"))
				{	soap_flag_MmbId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MmbId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ClearingSystemMemberIdentification2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, sizeof(ns1__ClearingSystemMemberIdentification2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ClearingSystemMemberIdentification2 * SOAP_FMAC2 soap_instantiate_ns1__ClearingSystemMemberIdentification2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearingSystemMemberIdentification2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ClearingSystemMemberIdentification2 *p;
	size_t k = sizeof(ns1__ClearingSystemMemberIdentification2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ClearingSystemMemberIdentification2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ClearingSystemMemberIdentification2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ClearingSystemMemberIdentification2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ClearingSystemMemberIdentification2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ClearingSystemMemberIdentification2(soap, tag ? tag : "ns1:ClearingSystemMemberIdentification2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ClearingSystemMemberIdentification2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClearingSystemMemberIdentification2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClearingSystemMemberIdentification2 * SOAP_FMAC4 soap_get_ns1__ClearingSystemMemberIdentification2(struct soap *soap, ns1__ClearingSystemMemberIdentification2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearingSystemMemberIdentification2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ClearingSystemIdentification2Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ClearingSystemIdentification2Choice::__union_ClearingSystemIdentification2Choice = 0;
}

void ns1__ClearingSystemIdentification2Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ClearingSystemIdentification2Choice(soap, this->ns1__ClearingSystemIdentification2Choice::__union_ClearingSystemIdentification2Choice, &this->ns1__ClearingSystemIdentification2Choice::union_ClearingSystemIdentification2Choice);
#endif
}

int ns1__ClearingSystemIdentification2Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClearingSystemIdentification2Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearingSystemIdentification2Choice(struct soap *soap, const char *tag, int id, const ns1__ClearingSystemIdentification2Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice), type))
		return soap->error;
	if (soap_out__ns1__union_ClearingSystemIdentification2Choice(soap, a->ns1__ClearingSystemIdentification2Choice::__union_ClearingSystemIdentification2Choice, &a->ns1__ClearingSystemIdentification2Choice::union_ClearingSystemIdentification2Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ClearingSystemIdentification2Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ClearingSystemIdentification2Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClearingSystemIdentification2Choice * SOAP_FMAC4 soap_in_ns1__ClearingSystemIdentification2Choice(struct soap *soap, const char *tag, ns1__ClearingSystemIdentification2Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClearingSystemIdentification2Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, sizeof(ns1__ClearingSystemIdentification2Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ClearingSystemIdentification2Choice(soap, &a->__union_ClearingSystemIdentification2Choice, &a->union_ClearingSystemIdentification2Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ClearingSystemIdentification2Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, sizeof(ns1__ClearingSystemIdentification2Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ClearingSystemIdentification2Choice * SOAP_FMAC2 soap_instantiate_ns1__ClearingSystemIdentification2Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearingSystemIdentification2Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ClearingSystemIdentification2Choice *p;
	size_t k = sizeof(ns1__ClearingSystemIdentification2Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ClearingSystemIdentification2Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ClearingSystemIdentification2Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ClearingSystemIdentification2Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ClearingSystemIdentification2Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ClearingSystemIdentification2Choice(soap, tag ? tag : "ns1:ClearingSystemIdentification2Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ClearingSystemIdentification2Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClearingSystemIdentification2Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClearingSystemIdentification2Choice * SOAP_FMAC4 soap_get_ns1__ClearingSystemIdentification2Choice(struct soap *soap, ns1__ClearingSystemIdentification2Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearingSystemIdentification2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ChequeDeliveryMethod1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ChequeDeliveryMethod1Choice::__union_ChequeDeliveryMethod1Choice = 0;
}

void ns1__ChequeDeliveryMethod1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ChequeDeliveryMethod1Choice(soap, this->ns1__ChequeDeliveryMethod1Choice::__union_ChequeDeliveryMethod1Choice, &this->ns1__ChequeDeliveryMethod1Choice::union_ChequeDeliveryMethod1Choice);
#endif
}

int ns1__ChequeDeliveryMethod1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChequeDeliveryMethod1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChequeDeliveryMethod1Choice(struct soap *soap, const char *tag, int id, const ns1__ChequeDeliveryMethod1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_ChequeDeliveryMethod1Choice(soap, a->ns1__ChequeDeliveryMethod1Choice::__union_ChequeDeliveryMethod1Choice, &a->ns1__ChequeDeliveryMethod1Choice::union_ChequeDeliveryMethod1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ChequeDeliveryMethod1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ChequeDeliveryMethod1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChequeDeliveryMethod1Choice * SOAP_FMAC4 soap_in_ns1__ChequeDeliveryMethod1Choice(struct soap *soap, const char *tag, ns1__ChequeDeliveryMethod1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChequeDeliveryMethod1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, sizeof(ns1__ChequeDeliveryMethod1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ChequeDeliveryMethod1Choice(soap, &a->__union_ChequeDeliveryMethod1Choice, &a->union_ChequeDeliveryMethod1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ChequeDeliveryMethod1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, sizeof(ns1__ChequeDeliveryMethod1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ChequeDeliveryMethod1Choice * SOAP_FMAC2 soap_instantiate_ns1__ChequeDeliveryMethod1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChequeDeliveryMethod1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ChequeDeliveryMethod1Choice *p;
	size_t k = sizeof(ns1__ChequeDeliveryMethod1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ChequeDeliveryMethod1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ChequeDeliveryMethod1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ChequeDeliveryMethod1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ChequeDeliveryMethod1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ChequeDeliveryMethod1Choice(soap, tag ? tag : "ns1:ChequeDeliveryMethod1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ChequeDeliveryMethod1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChequeDeliveryMethod1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChequeDeliveryMethod1Choice * SOAP_FMAC4 soap_get_ns1__ChequeDeliveryMethod1Choice(struct soap *soap, ns1__ChequeDeliveryMethod1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChequeDeliveryMethod1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Cheque11::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Cheque11::ChqTp = NULL;
	this->ns1__Cheque11::ChqNb = NULL;
	this->ns1__Cheque11::ChqFr = NULL;
	this->ns1__Cheque11::DlvryMtd = NULL;
	this->ns1__Cheque11::DlvrTo = NULL;
	this->ns1__Cheque11::InstrPrty = NULL;
	this->ns1__Cheque11::ChqMtrtyDt = NULL;
	this->ns1__Cheque11::FrmsCd = NULL;
	soap_default_std__vectorTemplateOfns1__Max35Text(soap, &this->ns1__Cheque11::MemoFld);
	this->ns1__Cheque11::RgnlClrZone = NULL;
	this->ns1__Cheque11::PrtLctn = NULL;
	soap_default_std__vectorTemplateOfns1__Max70Text(soap, &this->ns1__Cheque11::Sgntr);
}

void ns1__Cheque11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ChequeType2Code(soap, &this->ns1__Cheque11::ChqTp);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Cheque11::ChqNb);
	soap_serialize_PointerTons1__NameAndAddress16(soap, &this->ns1__Cheque11::ChqFr);
	soap_serialize_PointerTons1__ChequeDeliveryMethod1Choice(soap, &this->ns1__Cheque11::DlvryMtd);
	soap_serialize_PointerTons1__NameAndAddress16(soap, &this->ns1__Cheque11::DlvrTo);
	soap_serialize_PointerTons1__Priority2Code(soap, &this->ns1__Cheque11::InstrPrty);
	soap_serialize_PointerTons1__ISODate(soap, &this->ns1__Cheque11::ChqMtrtyDt);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Cheque11::FrmsCd);
	soap_serialize_std__vectorTemplateOfns1__Max35Text(soap, &this->ns1__Cheque11::MemoFld);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Cheque11::RgnlClrZone);
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__Cheque11::PrtLctn);
	soap_serialize_std__vectorTemplateOfns1__Max70Text(soap, &this->ns1__Cheque11::Sgntr);
#endif
}

int ns1__Cheque11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Cheque11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Cheque11(struct soap *soap, const char *tag, int id, const ns1__Cheque11 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Cheque11), type))
		return soap->error;
	if (soap_out_PointerTons1__ChequeType2Code(soap, "ChqTp", -1, &a->ns1__Cheque11::ChqTp, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "ChqNb", -1, &a->ns1__Cheque11::ChqNb, ""))
		return soap->error;
	if (soap_out_PointerTons1__NameAndAddress16(soap, "ChqFr", -1, &a->ns1__Cheque11::ChqFr, ""))
		return soap->error;
	if (soap_out_PointerTons1__ChequeDeliveryMethod1Choice(soap, "DlvryMtd", -1, &a->ns1__Cheque11::DlvryMtd, ""))
		return soap->error;
	if (soap_out_PointerTons1__NameAndAddress16(soap, "DlvrTo", -1, &a->ns1__Cheque11::DlvrTo, ""))
		return soap->error;
	if (soap_out_PointerTons1__Priority2Code(soap, "InstrPrty", -1, &a->ns1__Cheque11::InstrPrty, ""))
		return soap->error;
	if (soap_out_PointerTons1__ISODate(soap, "ChqMtrtyDt", -1, &a->ns1__Cheque11::ChqMtrtyDt, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "FrmsCd", -1, &a->ns1__Cheque11::FrmsCd, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max35Text(soap, "MemoFld", -1, &a->ns1__Cheque11::MemoFld, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "RgnlClrZone", -1, &a->ns1__Cheque11::RgnlClrZone, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "PrtLctn", -1, &a->ns1__Cheque11::PrtLctn, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Max70Text(soap, "Sgntr", -1, &a->ns1__Cheque11::Sgntr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Cheque11::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Cheque11(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Cheque11 * SOAP_FMAC4 soap_in_ns1__Cheque11(struct soap *soap, const char *tag, ns1__Cheque11 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Cheque11*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Cheque11, sizeof(ns1__Cheque11), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Cheque11)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Cheque11 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChqTp1 = 1;
	size_t soap_flag_ChqNb1 = 1;
	size_t soap_flag_ChqFr1 = 1;
	size_t soap_flag_DlvryMtd1 = 1;
	size_t soap_flag_DlvrTo1 = 1;
	size_t soap_flag_InstrPrty1 = 1;
	size_t soap_flag_ChqMtrtyDt1 = 1;
	size_t soap_flag_FrmsCd1 = 1;
	size_t soap_flag_RgnlClrZone1 = 1;
	size_t soap_flag_PrtLctn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChqTp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ChequeType2Code(soap, "ChqTp", &a->ns1__Cheque11::ChqTp, "ns1:ChequeType2Code"))
				{	soap_flag_ChqTp1--;
					continue;
				}
			}
			if (soap_flag_ChqNb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "ChqNb", &a->ns1__Cheque11::ChqNb, "ns1:Max35Text"))
				{	soap_flag_ChqNb1--;
					continue;
				}
			}
			if (soap_flag_ChqFr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NameAndAddress16(soap, "ChqFr", &a->ns1__Cheque11::ChqFr, "ns1:NameAndAddress16"))
				{	soap_flag_ChqFr1--;
					continue;
				}
			}
			if (soap_flag_DlvryMtd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ChequeDeliveryMethod1Choice(soap, "DlvryMtd", &a->ns1__Cheque11::DlvryMtd, "ns1:ChequeDeliveryMethod1Choice"))
				{	soap_flag_DlvryMtd1--;
					continue;
				}
			}
			if (soap_flag_DlvrTo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NameAndAddress16(soap, "DlvrTo", &a->ns1__Cheque11::DlvrTo, "ns1:NameAndAddress16"))
				{	soap_flag_DlvrTo1--;
					continue;
				}
			}
			if (soap_flag_InstrPrty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Priority2Code(soap, "InstrPrty", &a->ns1__Cheque11::InstrPrty, "ns1:Priority2Code"))
				{	soap_flag_InstrPrty1--;
					continue;
				}
			}
			if (soap_flag_ChqMtrtyDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ISODate(soap, "ChqMtrtyDt", &a->ns1__Cheque11::ChqMtrtyDt, "ns1:ISODate"))
				{	soap_flag_ChqMtrtyDt1--;
					continue;
				}
			}
			if (soap_flag_FrmsCd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "FrmsCd", &a->ns1__Cheque11::FrmsCd, "ns1:Max35Text"))
				{	soap_flag_FrmsCd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max35Text(soap, "MemoFld", &a->ns1__Cheque11::MemoFld, "ns1:Max35Text"))
					continue;
			}
			if (soap_flag_RgnlClrZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "RgnlClrZone", &a->ns1__Cheque11::RgnlClrZone, "ns1:Max35Text"))
				{	soap_flag_RgnlClrZone1--;
					continue;
				}
			}
			if (soap_flag_PrtLctn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "PrtLctn", &a->ns1__Cheque11::PrtLctn, "ns1:Max35Text"))
				{	soap_flag_PrtLctn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__Max70Text(soap, "Sgntr", &a->ns1__Cheque11::Sgntr, "ns1:Max70Text"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__Cheque11::MemoFld.size() > 2 || a->ns1__Cheque11::Sgntr.size() > 5))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Cheque11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Cheque11, SOAP_TYPE_ns1__Cheque11, sizeof(ns1__Cheque11), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Cheque11 * SOAP_FMAC2 soap_instantiate_ns1__Cheque11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Cheque11(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Cheque11 *p;
	size_t k = sizeof(ns1__Cheque11);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Cheque11, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Cheque11);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Cheque11, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Cheque11 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Cheque11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Cheque11(soap, tag ? tag : "ns1:Cheque11", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Cheque11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Cheque11(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Cheque11 * SOAP_FMAC4 soap_get_ns1__Cheque11(struct soap *soap, ns1__Cheque11 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Cheque11(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CategoryPurpose1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CategoryPurpose1Choice::__union_CategoryPurpose1Choice = 0;
}

void ns1__CategoryPurpose1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_CategoryPurpose1Choice(soap, this->ns1__CategoryPurpose1Choice::__union_CategoryPurpose1Choice, &this->ns1__CategoryPurpose1Choice::union_CategoryPurpose1Choice);
#endif
}

int ns1__CategoryPurpose1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CategoryPurpose1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CategoryPurpose1Choice(struct soap *soap, const char *tag, int id, const ns1__CategoryPurpose1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CategoryPurpose1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_CategoryPurpose1Choice(soap, a->ns1__CategoryPurpose1Choice::__union_CategoryPurpose1Choice, &a->ns1__CategoryPurpose1Choice::union_CategoryPurpose1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CategoryPurpose1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CategoryPurpose1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CategoryPurpose1Choice * SOAP_FMAC4 soap_in_ns1__CategoryPurpose1Choice(struct soap *soap, const char *tag, ns1__CategoryPurpose1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CategoryPurpose1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryPurpose1Choice, sizeof(ns1__CategoryPurpose1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_CategoryPurpose1Choice(soap, &a->__union_CategoryPurpose1Choice, &a->union_CategoryPurpose1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__CategoryPurpose1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CategoryPurpose1Choice, SOAP_TYPE_ns1__CategoryPurpose1Choice, sizeof(ns1__CategoryPurpose1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CategoryPurpose1Choice * SOAP_FMAC2 soap_instantiate_ns1__CategoryPurpose1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CategoryPurpose1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CategoryPurpose1Choice *p;
	size_t k = sizeof(ns1__CategoryPurpose1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CategoryPurpose1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CategoryPurpose1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CategoryPurpose1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CategoryPurpose1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CategoryPurpose1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CategoryPurpose1Choice(soap, tag ? tag : "ns1:CategoryPurpose1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CategoryPurpose1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CategoryPurpose1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CategoryPurpose1Choice * SOAP_FMAC4 soap_get_ns1__CategoryPurpose1Choice(struct soap *soap, ns1__CategoryPurpose1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CategoryPurpose1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CashAccountType2Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CashAccountType2Choice::__union_CashAccountType2Choice = 0;
}

void ns1__CashAccountType2Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_CashAccountType2Choice(soap, this->ns1__CashAccountType2Choice::__union_CashAccountType2Choice, &this->ns1__CashAccountType2Choice::union_CashAccountType2Choice);
#endif
}

int ns1__CashAccountType2Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CashAccountType2Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CashAccountType2Choice(struct soap *soap, const char *tag, int id, const ns1__CashAccountType2Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CashAccountType2Choice), type))
		return soap->error;
	if (soap_out__ns1__union_CashAccountType2Choice(soap, a->ns1__CashAccountType2Choice::__union_CashAccountType2Choice, &a->ns1__CashAccountType2Choice::union_CashAccountType2Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CashAccountType2Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CashAccountType2Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CashAccountType2Choice * SOAP_FMAC4 soap_in_ns1__CashAccountType2Choice(struct soap *soap, const char *tag, ns1__CashAccountType2Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CashAccountType2Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CashAccountType2Choice, sizeof(ns1__CashAccountType2Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_CashAccountType2Choice(soap, &a->__union_CashAccountType2Choice, &a->union_CashAccountType2Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__CashAccountType2Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CashAccountType2Choice, SOAP_TYPE_ns1__CashAccountType2Choice, sizeof(ns1__CashAccountType2Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CashAccountType2Choice * SOAP_FMAC2 soap_instantiate_ns1__CashAccountType2Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CashAccountType2Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CashAccountType2Choice *p;
	size_t k = sizeof(ns1__CashAccountType2Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CashAccountType2Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CashAccountType2Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CashAccountType2Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CashAccountType2Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CashAccountType2Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CashAccountType2Choice(soap, tag ? tag : "ns1:CashAccountType2Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CashAccountType2Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CashAccountType2Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CashAccountType2Choice * SOAP_FMAC4 soap_get_ns1__CashAccountType2Choice(struct soap *soap, ns1__CashAccountType2Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CashAccountType2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CashAccount40::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CashAccount40::Id = NULL;
	this->ns1__CashAccount40::Tp = NULL;
	this->ns1__CashAccount40::Ccy = NULL;
	this->ns1__CashAccount40::Nm = NULL;
	this->ns1__CashAccount40::Prxy = NULL;
}

void ns1__CashAccount40::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AccountIdentification4Choice(soap, &this->ns1__CashAccount40::Id);
	soap_serialize_PointerTons1__CashAccountType2Choice(soap, &this->ns1__CashAccount40::Tp);
	soap_serialize_PointerTons1__ActiveOrHistoricCurrencyCode(soap, &this->ns1__CashAccount40::Ccy);
	soap_serialize_PointerTons1__Max70Text(soap, &this->ns1__CashAccount40::Nm);
	soap_serialize_PointerTons1__ProxyAccountIdentification1(soap, &this->ns1__CashAccount40::Prxy);
#endif
}

int ns1__CashAccount40::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CashAccount40(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CashAccount40(struct soap *soap, const char *tag, int id, const ns1__CashAccount40 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CashAccount40), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountIdentification4Choice(soap, "Id", -1, &a->ns1__CashAccount40::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__CashAccountType2Choice(soap, "Tp", -1, &a->ns1__CashAccount40::Tp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyCode(soap, "Ccy", -1, &a->ns1__CashAccount40::Ccy, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max70Text(soap, "Nm", -1, &a->ns1__CashAccount40::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProxyAccountIdentification1(soap, "Prxy", -1, &a->ns1__CashAccount40::Prxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CashAccount40::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CashAccount40(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CashAccount40 * SOAP_FMAC4 soap_in_ns1__CashAccount40(struct soap *soap, const char *tag, ns1__CashAccount40 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CashAccount40*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CashAccount40, sizeof(ns1__CashAccount40), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CashAccount40)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CashAccount40 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Tp1 = 1;
	size_t soap_flag_Ccy1 = 1;
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_Prxy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccountIdentification4Choice(soap, "Id", &a->ns1__CashAccount40::Id, "ns1:AccountIdentification4Choice"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Tp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CashAccountType2Choice(soap, "Tp", &a->ns1__CashAccount40::Tp, "ns1:CashAccountType2Choice"))
				{	soap_flag_Tp1--;
					continue;
				}
			}
			if (soap_flag_Ccy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__ActiveOrHistoricCurrencyCode(soap, "Ccy", &a->ns1__CashAccount40::Ccy, "ns1:ActiveOrHistoricCurrencyCode"))
				{	soap_flag_Ccy1--;
					continue;
				}
			}
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max70Text(soap, "Nm", &a->ns1__CashAccount40::Nm, "ns1:Max70Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_Prxy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProxyAccountIdentification1(soap, "Prxy", &a->ns1__CashAccount40::Prxy, "ns1:ProxyAccountIdentification1"))
				{	soap_flag_Prxy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CashAccount40 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CashAccount40, SOAP_TYPE_ns1__CashAccount40, sizeof(ns1__CashAccount40), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CashAccount40 * SOAP_FMAC2 soap_instantiate_ns1__CashAccount40(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CashAccount40(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CashAccount40 *p;
	size_t k = sizeof(ns1__CashAccount40);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CashAccount40, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CashAccount40);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CashAccount40, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CashAccount40 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CashAccount40::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CashAccount40(soap, tag ? tag : "ns1:CashAccount40", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CashAccount40::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CashAccount40(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CashAccount40 * SOAP_FMAC4 soap_get_ns1__CashAccount40(struct soap *soap, ns1__CashAccount40 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CashAccount40(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BranchData3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BranchData3::Id = NULL;
	this->ns1__BranchData3::LEI = NULL;
	this->ns1__BranchData3::Nm = NULL;
	this->ns1__BranchData3::PstlAdr = NULL;
}

void ns1__BranchData3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Max35Text(soap, &this->ns1__BranchData3::Id);
	soap_serialize_PointerTons1__LEIIdentifier(soap, &this->ns1__BranchData3::LEI);
	soap_serialize_PointerTons1__Max140Text(soap, &this->ns1__BranchData3::Nm);
	soap_serialize_PointerTons1__PostalAddress24(soap, &this->ns1__BranchData3::PstlAdr);
#endif
}

int ns1__BranchData3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BranchData3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BranchData3(struct soap *soap, const char *tag, int id, const ns1__BranchData3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BranchData3), type))
		return soap->error;
	if (soap_out_PointerTons1__Max35Text(soap, "Id", -1, &a->ns1__BranchData3::Id, ""))
		return soap->error;
	if (soap_out_PointerTons1__LEIIdentifier(soap, "LEI", -1, &a->ns1__BranchData3::LEI, ""))
		return soap->error;
	if (soap_out_PointerTons1__Max140Text(soap, "Nm", -1, &a->ns1__BranchData3::Nm, ""))
		return soap->error;
	if (soap_out_PointerTons1__PostalAddress24(soap, "PstlAdr", -1, &a->ns1__BranchData3::PstlAdr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BranchData3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BranchData3(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BranchData3 * SOAP_FMAC4 soap_in_ns1__BranchData3(struct soap *soap, const char *tag, ns1__BranchData3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BranchData3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BranchData3, sizeof(ns1__BranchData3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BranchData3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BranchData3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_LEI1 = 1;
	size_t soap_flag_Nm1 = 1;
	size_t soap_flag_PstlAdr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max35Text(soap, "Id", &a->ns1__BranchData3::Id, "ns1:Max35Text"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_LEI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__LEIIdentifier(soap, "LEI", &a->ns1__BranchData3::LEI, "ns1:LEIIdentifier"))
				{	soap_flag_LEI1--;
					continue;
				}
			}
			if (soap_flag_Nm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons1__Max140Text(soap, "Nm", &a->ns1__BranchData3::Nm, "ns1:Max140Text"))
				{	soap_flag_Nm1--;
					continue;
				}
			}
			if (soap_flag_PstlAdr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PostalAddress24(soap, "PstlAdr", &a->ns1__BranchData3::PstlAdr, "ns1:PostalAddress24"))
				{	soap_flag_PstlAdr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BranchData3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BranchData3, SOAP_TYPE_ns1__BranchData3, sizeof(ns1__BranchData3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BranchData3 * SOAP_FMAC2 soap_instantiate_ns1__BranchData3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BranchData3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BranchData3 *p;
	size_t k = sizeof(ns1__BranchData3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BranchData3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BranchData3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BranchData3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BranchData3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BranchData3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BranchData3(soap, tag ? tag : "ns1:BranchData3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BranchData3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BranchData3(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BranchData3 * SOAP_FMAC4 soap_get_ns1__BranchData3(struct soap *soap, ns1__BranchData3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BranchData3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BranchAndFinancialInstitutionIdentification6::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId = NULL;
	this->ns1__BranchAndFinancialInstitutionIdentification6::BrnchId = NULL;
}

void ns1__BranchAndFinancialInstitutionIdentification6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FinancialInstitutionIdentification18(soap, &this->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId);
	soap_serialize_PointerTons1__BranchData3(soap, &this->ns1__BranchAndFinancialInstitutionIdentification6::BrnchId);
#endif
}

int ns1__BranchAndFinancialInstitutionIdentification6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, const char *tag, int id, const ns1__BranchAndFinancialInstitutionIdentification6 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6), type))
		return soap->error;
	if (!a->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId)
	{	if (soap_element_empty(soap, "FinInstnId", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__FinancialInstitutionIdentification18(soap, "FinInstnId", -1, &a->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId, ""))
		return soap->error;
	if (soap_out_PointerTons1__BranchData3(soap, "BrnchId", -1, &a->ns1__BranchAndFinancialInstitutionIdentification6::BrnchId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BranchAndFinancialInstitutionIdentification6::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BranchAndFinancialInstitutionIdentification6 * SOAP_FMAC4 soap_in_ns1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, const char *tag, ns1__BranchAndFinancialInstitutionIdentification6 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BranchAndFinancialInstitutionIdentification6*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, sizeof(ns1__BranchAndFinancialInstitutionIdentification6), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BranchAndFinancialInstitutionIdentification6 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FinInstnId1 = 1;
	size_t soap_flag_BrnchId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FinInstnId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FinancialInstitutionIdentification18(soap, "FinInstnId", &a->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId, "ns1:FinancialInstitutionIdentification18"))
				{	soap_flag_FinInstnId1--;
					continue;
				}
			}
			if (soap_flag_BrnchId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BranchData3(soap, "BrnchId", &a->ns1__BranchAndFinancialInstitutionIdentification6::BrnchId, "ns1:BranchData3"))
				{	soap_flag_BrnchId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__BranchAndFinancialInstitutionIdentification6::FinInstnId))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BranchAndFinancialInstitutionIdentification6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, sizeof(ns1__BranchAndFinancialInstitutionIdentification6), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BranchAndFinancialInstitutionIdentification6 * SOAP_FMAC2 soap_instantiate_ns1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BranchAndFinancialInstitutionIdentification6(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BranchAndFinancialInstitutionIdentification6 *p;
	size_t k = sizeof(ns1__BranchAndFinancialInstitutionIdentification6);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BranchAndFinancialInstitutionIdentification6);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BranchAndFinancialInstitutionIdentification6, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BranchAndFinancialInstitutionIdentification6 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BranchAndFinancialInstitutionIdentification6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag ? tag : "ns1:BranchAndFinancialInstitutionIdentification6", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BranchAndFinancialInstitutionIdentification6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BranchAndFinancialInstitutionIdentification6(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BranchAndFinancialInstitutionIdentification6 * SOAP_FMAC4 soap_get_ns1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, ns1__BranchAndFinancialInstitutionIdentification6 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BranchAndFinancialInstitutionIdentification6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Authorisation1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Authorisation1Choice::__union_Authorisation1Choice = 0;
}

void ns1__Authorisation1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_Authorisation1Choice(soap, this->ns1__Authorisation1Choice::__union_Authorisation1Choice, &this->ns1__Authorisation1Choice::union_Authorisation1Choice);
#endif
}

int ns1__Authorisation1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Authorisation1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Authorisation1Choice(struct soap *soap, const char *tag, int id, const ns1__Authorisation1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Authorisation1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_Authorisation1Choice(soap, a->ns1__Authorisation1Choice::__union_Authorisation1Choice, &a->ns1__Authorisation1Choice::union_Authorisation1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Authorisation1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Authorisation1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Authorisation1Choice * SOAP_FMAC4 soap_in_ns1__Authorisation1Choice(struct soap *soap, const char *tag, ns1__Authorisation1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Authorisation1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Authorisation1Choice, sizeof(ns1__Authorisation1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_Authorisation1Choice(soap, &a->__union_Authorisation1Choice, &a->union_Authorisation1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__Authorisation1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Authorisation1Choice, SOAP_TYPE_ns1__Authorisation1Choice, sizeof(ns1__Authorisation1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Authorisation1Choice * SOAP_FMAC2 soap_instantiate_ns1__Authorisation1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Authorisation1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Authorisation1Choice *p;
	size_t k = sizeof(ns1__Authorisation1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Authorisation1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Authorisation1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Authorisation1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Authorisation1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Authorisation1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Authorisation1Choice(soap, tag ? tag : "ns1:Authorisation1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Authorisation1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Authorisation1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Authorisation1Choice * SOAP_FMAC4 soap_get_ns1__Authorisation1Choice(struct soap *soap, ns1__Authorisation1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Authorisation1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AmountType4Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AmountType4Choice::__union_AmountType4Choice = 0;
}

void ns1__AmountType4Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_AmountType4Choice(soap, this->ns1__AmountType4Choice::__union_AmountType4Choice, &this->ns1__AmountType4Choice::union_AmountType4Choice);
#endif
}

int ns1__AmountType4Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AmountType4Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AmountType4Choice(struct soap *soap, const char *tag, int id, const ns1__AmountType4Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AmountType4Choice), type))
		return soap->error;
	if (soap_out__ns1__union_AmountType4Choice(soap, a->ns1__AmountType4Choice::__union_AmountType4Choice, &a->ns1__AmountType4Choice::union_AmountType4Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AmountType4Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AmountType4Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AmountType4Choice * SOAP_FMAC4 soap_in_ns1__AmountType4Choice(struct soap *soap, const char *tag, ns1__AmountType4Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AmountType4Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AmountType4Choice, sizeof(ns1__AmountType4Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_AmountType4Choice(soap, &a->__union_AmountType4Choice, &a->union_AmountType4Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__AmountType4Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AmountType4Choice, SOAP_TYPE_ns1__AmountType4Choice, sizeof(ns1__AmountType4Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AmountType4Choice * SOAP_FMAC2 soap_instantiate_ns1__AmountType4Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AmountType4Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AmountType4Choice *p;
	size_t k = sizeof(ns1__AmountType4Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AmountType4Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AmountType4Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AmountType4Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AmountType4Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AmountType4Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AmountType4Choice(soap, tag ? tag : "ns1:AmountType4Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AmountType4Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AmountType4Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AmountType4Choice * SOAP_FMAC4 soap_get_ns1__AmountType4Choice(struct soap *soap, ns1__AmountType4Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AmountType4Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AdviceType1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AdviceType1Choice::__union_AdviceType1Choice = 0;
}

void ns1__AdviceType1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_AdviceType1Choice(soap, this->ns1__AdviceType1Choice::__union_AdviceType1Choice, &this->ns1__AdviceType1Choice::union_AdviceType1Choice);
#endif
}

int ns1__AdviceType1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AdviceType1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AdviceType1Choice(struct soap *soap, const char *tag, int id, const ns1__AdviceType1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AdviceType1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_AdviceType1Choice(soap, a->ns1__AdviceType1Choice::__union_AdviceType1Choice, &a->ns1__AdviceType1Choice::union_AdviceType1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AdviceType1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AdviceType1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AdviceType1Choice * SOAP_FMAC4 soap_in_ns1__AdviceType1Choice(struct soap *soap, const char *tag, ns1__AdviceType1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AdviceType1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AdviceType1Choice, sizeof(ns1__AdviceType1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_AdviceType1Choice(soap, &a->__union_AdviceType1Choice, &a->union_AdviceType1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__AdviceType1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AdviceType1Choice, SOAP_TYPE_ns1__AdviceType1Choice, sizeof(ns1__AdviceType1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AdviceType1Choice * SOAP_FMAC2 soap_instantiate_ns1__AdviceType1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AdviceType1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AdviceType1Choice *p;
	size_t k = sizeof(ns1__AdviceType1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AdviceType1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AdviceType1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AdviceType1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AdviceType1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AdviceType1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AdviceType1Choice(soap, tag ? tag : "ns1:AdviceType1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AdviceType1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AdviceType1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AdviceType1Choice * SOAP_FMAC4 soap_get_ns1__AdviceType1Choice(struct soap *soap, ns1__AdviceType1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AdviceType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AdviceType1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AdviceType1::CdtAdvc = NULL;
	this->ns1__AdviceType1::DbtAdvc = NULL;
}

void ns1__AdviceType1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AdviceType1Choice(soap, &this->ns1__AdviceType1::CdtAdvc);
	soap_serialize_PointerTons1__AdviceType1Choice(soap, &this->ns1__AdviceType1::DbtAdvc);
#endif
}

int ns1__AdviceType1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AdviceType1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AdviceType1(struct soap *soap, const char *tag, int id, const ns1__AdviceType1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AdviceType1), type))
		return soap->error;
	if (soap_out_PointerTons1__AdviceType1Choice(soap, "CdtAdvc", -1, &a->ns1__AdviceType1::CdtAdvc, ""))
		return soap->error;
	if (soap_out_PointerTons1__AdviceType1Choice(soap, "DbtAdvc", -1, &a->ns1__AdviceType1::DbtAdvc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AdviceType1::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AdviceType1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AdviceType1 * SOAP_FMAC4 soap_in_ns1__AdviceType1(struct soap *soap, const char *tag, ns1__AdviceType1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AdviceType1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AdviceType1, sizeof(ns1__AdviceType1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AdviceType1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AdviceType1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CdtAdvc1 = 1;
	size_t soap_flag_DbtAdvc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CdtAdvc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AdviceType1Choice(soap, "CdtAdvc", &a->ns1__AdviceType1::CdtAdvc, "ns1:AdviceType1Choice"))
				{	soap_flag_CdtAdvc1--;
					continue;
				}
			}
			if (soap_flag_DbtAdvc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AdviceType1Choice(soap, "DbtAdvc", &a->ns1__AdviceType1::DbtAdvc, "ns1:AdviceType1Choice"))
				{	soap_flag_DbtAdvc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AdviceType1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AdviceType1, SOAP_TYPE_ns1__AdviceType1, sizeof(ns1__AdviceType1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AdviceType1 * SOAP_FMAC2 soap_instantiate_ns1__AdviceType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AdviceType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AdviceType1 *p;
	size_t k = sizeof(ns1__AdviceType1);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AdviceType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AdviceType1);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AdviceType1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AdviceType1 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AdviceType1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AdviceType1(soap, tag ? tag : "ns1:AdviceType1", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AdviceType1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AdviceType1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AdviceType1 * SOAP_FMAC4 soap_get_ns1__AdviceType1(struct soap *soap, ns1__AdviceType1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AdviceType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AddressType3Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AddressType3Choice::__union_AddressType3Choice = 0;
}

void ns1__AddressType3Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_AddressType3Choice(soap, this->ns1__AddressType3Choice::__union_AddressType3Choice, &this->ns1__AddressType3Choice::union_AddressType3Choice);
#endif
}

int ns1__AddressType3Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddressType3Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddressType3Choice(struct soap *soap, const char *tag, int id, const ns1__AddressType3Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddressType3Choice), type))
		return soap->error;
	if (soap_out__ns1__union_AddressType3Choice(soap, a->ns1__AddressType3Choice::__union_AddressType3Choice, &a->ns1__AddressType3Choice::union_AddressType3Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AddressType3Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AddressType3Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddressType3Choice * SOAP_FMAC4 soap_in_ns1__AddressType3Choice(struct soap *soap, const char *tag, ns1__AddressType3Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AddressType3Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressType3Choice, sizeof(ns1__AddressType3Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_AddressType3Choice(soap, &a->__union_AddressType3Choice, &a->union_AddressType3Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__AddressType3Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddressType3Choice, SOAP_TYPE_ns1__AddressType3Choice, sizeof(ns1__AddressType3Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AddressType3Choice * SOAP_FMAC2 soap_instantiate_ns1__AddressType3Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddressType3Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AddressType3Choice *p;
	size_t k = sizeof(ns1__AddressType3Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AddressType3Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AddressType3Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AddressType3Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AddressType3Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AddressType3Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AddressType3Choice(soap, tag ? tag : "ns1:AddressType3Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AddressType3Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddressType3Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddressType3Choice * SOAP_FMAC4 soap_get_ns1__AddressType3Choice(struct soap *soap, ns1__AddressType3Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddressType3Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ActiveOrHistoricCurrencyAndAmount::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, &this->ns1__ActiveOrHistoricCurrencyAndAmount::__item);
	soap_default_ns1__ActiveOrHistoricCurrencyCode(soap, &this->ns1__ActiveOrHistoricCurrencyAndAmount::Ccy);
}

void ns1__ActiveOrHistoricCurrencyAndAmount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, &this->ns1__ActiveOrHistoricCurrencyAndAmount::__item);
#endif
}

int ns1__ActiveOrHistoricCurrencyAndAmount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, const char *tag, int id, const ns1__ActiveOrHistoricCurrencyAndAmount *a, const char *type)
{
	soap_set_attr(soap, "Ccy", soap_ns1__ActiveOrHistoricCurrencyCode2s(soap, ((ns1__ActiveOrHistoricCurrencyAndAmount*)a)->Ccy), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, tag, id, &a->ns1__ActiveOrHistoricCurrencyAndAmount::__item, "");
}

void *ns1__ActiveOrHistoricCurrencyAndAmount::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ActiveOrHistoricCurrencyAndAmount * SOAP_FMAC4 soap_in_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, const char *tag, ns1__ActiveOrHistoricCurrencyAndAmount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__ActiveOrHistoricCurrencyAndAmount*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount, sizeof(ns1__ActiveOrHistoricCurrencyAndAmount), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount)
		return (ns1__ActiveOrHistoricCurrencyAndAmount *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns1__ActiveOrHistoricCurrencyCode(soap, soap_attr_value(soap, "Ccy", 1, 1), &((ns1__ActiveOrHistoricCurrencyAndAmount*)a)->Ccy))
		return NULL;
	if (!soap_in_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType(soap, tag, &a->ns1__ActiveOrHistoricCurrencyAndAmount::__item, "ns1:ActiveOrHistoricCurrencyAndAmount"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns1__ActiveOrHistoricCurrencyAndAmount * SOAP_FMAC2 soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ActiveOrHistoricCurrencyAndAmount *p;
	size_t k = sizeof(ns1__ActiveOrHistoricCurrencyAndAmount);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ActiveOrHistoricCurrencyAndAmount);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ActiveOrHistoricCurrencyAndAmount, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ActiveOrHistoricCurrencyAndAmount location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ActiveOrHistoricCurrencyAndAmount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag ? tag : "ns1:ActiveOrHistoricCurrencyAndAmount", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ActiveOrHistoricCurrencyAndAmount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ActiveOrHistoricCurrencyAndAmount(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ActiveOrHistoricCurrencyAndAmount * SOAP_FMAC4 soap_get_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, ns1__ActiveOrHistoricCurrencyAndAmount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActiveOrHistoricCurrencyAndAmount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AccountSchemeName1Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AccountSchemeName1Choice::__union_AccountSchemeName1Choice = 0;
}

void ns1__AccountSchemeName1Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_AccountSchemeName1Choice(soap, this->ns1__AccountSchemeName1Choice::__union_AccountSchemeName1Choice, &this->ns1__AccountSchemeName1Choice::union_AccountSchemeName1Choice);
#endif
}

int ns1__AccountSchemeName1Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccountSchemeName1Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccountSchemeName1Choice(struct soap *soap, const char *tag, int id, const ns1__AccountSchemeName1Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccountSchemeName1Choice), type))
		return soap->error;
	if (soap_out__ns1__union_AccountSchemeName1Choice(soap, a->ns1__AccountSchemeName1Choice::__union_AccountSchemeName1Choice, &a->ns1__AccountSchemeName1Choice::union_AccountSchemeName1Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AccountSchemeName1Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AccountSchemeName1Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccountSchemeName1Choice * SOAP_FMAC4 soap_in_ns1__AccountSchemeName1Choice(struct soap *soap, const char *tag, ns1__AccountSchemeName1Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AccountSchemeName1Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccountSchemeName1Choice, sizeof(ns1__AccountSchemeName1Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_AccountSchemeName1Choice(soap, &a->__union_AccountSchemeName1Choice, &a->union_AccountSchemeName1Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__AccountSchemeName1Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccountSchemeName1Choice, SOAP_TYPE_ns1__AccountSchemeName1Choice, sizeof(ns1__AccountSchemeName1Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AccountSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__AccountSchemeName1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccountSchemeName1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AccountSchemeName1Choice *p;
	size_t k = sizeof(ns1__AccountSchemeName1Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AccountSchemeName1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AccountSchemeName1Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AccountSchemeName1Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AccountSchemeName1Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AccountSchemeName1Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AccountSchemeName1Choice(soap, tag ? tag : "ns1:AccountSchemeName1Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AccountSchemeName1Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccountSchemeName1Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccountSchemeName1Choice * SOAP_FMAC4 soap_get_ns1__AccountSchemeName1Choice(struct soap *soap, ns1__AccountSchemeName1Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccountSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AccountIdentification4Choice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AccountIdentification4Choice::__union_AccountIdentification4Choice = 0;
}

void ns1__AccountIdentification4Choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_AccountIdentification4Choice(soap, this->ns1__AccountIdentification4Choice::__union_AccountIdentification4Choice, &this->ns1__AccountIdentification4Choice::union_AccountIdentification4Choice);
#endif
}

int ns1__AccountIdentification4Choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccountIdentification4Choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccountIdentification4Choice(struct soap *soap, const char *tag, int id, const ns1__AccountIdentification4Choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccountIdentification4Choice), type))
		return soap->error;
	if (soap_out__ns1__union_AccountIdentification4Choice(soap, a->ns1__AccountIdentification4Choice::__union_AccountIdentification4Choice, &a->ns1__AccountIdentification4Choice::union_AccountIdentification4Choice))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AccountIdentification4Choice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AccountIdentification4Choice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccountIdentification4Choice * SOAP_FMAC4 soap_in_ns1__AccountIdentification4Choice(struct soap *soap, const char *tag, ns1__AccountIdentification4Choice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AccountIdentification4Choice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccountIdentification4Choice, sizeof(ns1__AccountIdentification4Choice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_AccountIdentification4Choice(soap, &a->__union_AccountIdentification4Choice, &a->union_AccountIdentification4Choice))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__AccountIdentification4Choice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccountIdentification4Choice, SOAP_TYPE_ns1__AccountIdentification4Choice, sizeof(ns1__AccountIdentification4Choice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AccountIdentification4Choice * SOAP_FMAC2 soap_instantiate_ns1__AccountIdentification4Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccountIdentification4Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AccountIdentification4Choice *p;
	size_t k = sizeof(ns1__AccountIdentification4Choice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AccountIdentification4Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AccountIdentification4Choice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AccountIdentification4Choice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AccountIdentification4Choice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AccountIdentification4Choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AccountIdentification4Choice(soap, tag ? tag : "ns1:AccountIdentification4Choice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AccountIdentification4Choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccountIdentification4Choice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccountIdentification4Choice * SOAP_FMAC4 soap_get_ns1__AccountIdentification4Choice(struct soap *soap, ns1__AccountIdentification4Choice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccountIdentification4Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__gYear(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__gYear(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__gYear), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__gYear(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "([-+]?\\d{4,})(Z|[-+]\\d{2}:\\d{2})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__gYear, SOAP_TYPE_xsd__gYear, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__gYear(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__gYear(soap, tag ? tag : "xsd:gYear", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__gYear(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d{4,}-\\d{2}-\\d{2}(Z|[-+]\\d{2}:\\d{2})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__date, SOAP_TYPE_xsd__date, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__date(soap, tag ? tag : "xsd:date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_TaxAmountType1Choice(struct soap *soap, int choice, const union _ns1__union_TaxAmountType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_TaxAmountType1Choice_Cd:
		soap_serialize_PointerTons1__ExternalTaxAmountType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_TaxAmountType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_TaxAmountType1Choice(struct soap *soap, int choice, const union _ns1__union_TaxAmountType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_TaxAmountType1Choice_Cd:
		return soap_out_PointerTons1__ExternalTaxAmountType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_TaxAmountType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_TaxAmountType1Choice * SOAP_FMAC4 soap_in__ns1__union_TaxAmountType1Choice(struct soap *soap, int *choice, union _ns1__union_TaxAmountType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalTaxAmountType1Code(soap, "Cd", &a->Cd, "ns1:ExternalTaxAmountType1Code"))
	{	*choice = SOAP_UNION__ns1__union_TaxAmountType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_TaxAmountType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ServiceLevel8Choice(struct soap *soap, int choice, const union _ns1__union_ServiceLevel8Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ServiceLevel8Choice_Cd:
		soap_serialize_PointerTons1__ExternalServiceLevel1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_ServiceLevel8Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ServiceLevel8Choice(struct soap *soap, int choice, const union _ns1__union_ServiceLevel8Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ServiceLevel8Choice_Cd:
		return soap_out_PointerTons1__ExternalServiceLevel1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_ServiceLevel8Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ServiceLevel8Choice * SOAP_FMAC4 soap_in__ns1__union_ServiceLevel8Choice(struct soap *soap, int *choice, union _ns1__union_ServiceLevel8Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalServiceLevel1Code(soap, "Cd", &a->Cd, "ns1:ExternalServiceLevel1Code"))
	{	*choice = SOAP_UNION__ns1__union_ServiceLevel8Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_ServiceLevel8Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ReferredDocumentType3Choice(struct soap *soap, int choice, const union _ns1__union_ReferredDocumentType3Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ReferredDocumentType3Choice(struct soap *soap, int choice, const union _ns1__union_ReferredDocumentType3Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Cd:
		return soap_out_ns1__DocumentType6Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ReferredDocumentType3Choice * SOAP_FMAC4 soap_in__ns1__union_ReferredDocumentType3Choice(struct soap *soap, int *choice, union _ns1__union_ReferredDocumentType3Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__DocumentType6Code(soap, "Cd", &a->Cd, "ns1:DocumentType6Code"))
	{	*choice = SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_Purpose2Choice(struct soap *soap, int choice, const union _ns1__union_Purpose2Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Purpose2Choice_Cd:
		soap_serialize_PointerTons1__ExternalPurpose1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_Purpose2Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_Purpose2Choice(struct soap *soap, int choice, const union _ns1__union_Purpose2Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Purpose2Choice_Cd:
		return soap_out_PointerTons1__ExternalPurpose1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_Purpose2Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_Purpose2Choice * SOAP_FMAC4 soap_in__ns1__union_Purpose2Choice(struct soap *soap, int *choice, union _ns1__union_Purpose2Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalPurpose1Code(soap, "Cd", &a->Cd, "ns1:ExternalPurpose1Code"))
	{	*choice = SOAP_UNION__ns1__union_Purpose2Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_Purpose2Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ProxyAccountType1Choice(struct soap *soap, int choice, const union _ns1__union_ProxyAccountType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ProxyAccountType1Choice_Cd:
		soap_serialize_PointerTons1__ExternalProxyAccountType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_ProxyAccountType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ProxyAccountType1Choice(struct soap *soap, int choice, const union _ns1__union_ProxyAccountType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ProxyAccountType1Choice_Cd:
		return soap_out_PointerTons1__ExternalProxyAccountType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_ProxyAccountType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ProxyAccountType1Choice * SOAP_FMAC4 soap_in__ns1__union_ProxyAccountType1Choice(struct soap *soap, int *choice, union _ns1__union_ProxyAccountType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalProxyAccountType1Code(soap, "Cd", &a->Cd, "ns1:ExternalProxyAccountType1Code"))
	{	*choice = SOAP_UNION__ns1__union_ProxyAccountType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_ProxyAccountType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_PersonIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_PersonIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Cd:
		soap_serialize_PointerTons1__ExternalPersonIdentification1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_PersonIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_PersonIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Cd:
		return soap_out_PointerTons1__ExternalPersonIdentification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_PersonIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in__ns1__union_PersonIdentificationSchemeName1Choice(struct soap *soap, int *choice, union _ns1__union_PersonIdentificationSchemeName1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalPersonIdentification1Code(soap, "Cd", &a->Cd, "ns1:ExternalPersonIdentification1Code"))
	{	*choice = SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_Party38Choice(struct soap *soap, int choice, const union _ns1__union_Party38Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Party38Choice_OrgId:
		soap_serialize_PointerTons1__OrganisationIdentification29(soap, &a->OrgId);
		break;
	case SOAP_UNION__ns1__union_Party38Choice_PrvtId:
		soap_serialize_PointerTons1__PersonIdentification13(soap, &a->PrvtId);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_Party38Choice(struct soap *soap, int choice, const union _ns1__union_Party38Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Party38Choice_OrgId:
		return soap_out_PointerTons1__OrganisationIdentification29(soap, "OrgId", -1, &a->OrgId, "");
	case SOAP_UNION__ns1__union_Party38Choice_PrvtId:
		return soap_out_PointerTons1__PersonIdentification13(soap, "PrvtId", -1, &a->PrvtId, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_Party38Choice * SOAP_FMAC4 soap_in__ns1__union_Party38Choice(struct soap *soap, int *choice, union _ns1__union_Party38Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->OrgId = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__OrganisationIdentification29(soap, "OrgId", &a->OrgId, "ns1:OrganisationIdentification29"))
	{	*choice = SOAP_UNION__ns1__union_Party38Choice_OrgId;
		return a;
	}
	a->PrvtId = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__PersonIdentification13(soap, "PrvtId", &a->PrvtId, "ns1:PersonIdentification13"))
	{	*choice = SOAP_UNION__ns1__union_Party38Choice_PrvtId;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_OrganisationIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_OrganisationIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Cd:
		soap_serialize_PointerTons1__ExternalOrganisationIdentification1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_OrganisationIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_OrganisationIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Cd:
		return soap_out_PointerTons1__ExternalOrganisationIdentification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_OrganisationIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in__ns1__union_OrganisationIdentificationSchemeName1Choice(struct soap *soap, int *choice, union _ns1__union_OrganisationIdentificationSchemeName1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalOrganisationIdentification1Code(soap, "Cd", &a->Cd, "ns1:ExternalOrganisationIdentification1Code"))
	{	*choice = SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_MandateSetupReason1Choice(struct soap *soap, int choice, const union _ns1__union_MandateSetupReason1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_MandateSetupReason1Choice_Cd:
		soap_serialize_PointerTons1__ExternalMandateSetupReason1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_MandateSetupReason1Choice_Prtry:
		soap_serialize_PointerTons1__Max70Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_MandateSetupReason1Choice(struct soap *soap, int choice, const union _ns1__union_MandateSetupReason1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_MandateSetupReason1Choice_Cd:
		return soap_out_PointerTons1__ExternalMandateSetupReason1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_MandateSetupReason1Choice_Prtry:
		return soap_out_PointerTons1__Max70Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_MandateSetupReason1Choice * SOAP_FMAC4 soap_in__ns1__union_MandateSetupReason1Choice(struct soap *soap, int *choice, union _ns1__union_MandateSetupReason1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalMandateSetupReason1Code(soap, "Cd", &a->Cd, "ns1:ExternalMandateSetupReason1Code"))
	{	*choice = SOAP_UNION__ns1__union_MandateSetupReason1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max70Text(soap, "Prtry", &a->Prtry, "ns1:Max70Text"))
	{	*choice = SOAP_UNION__ns1__union_MandateSetupReason1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_MandateClassification1Choice(struct soap *soap, int choice, const union _ns1__union_MandateClassification1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_MandateClassification1Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_MandateClassification1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_MandateClassification1Choice(struct soap *soap, int choice, const union _ns1__union_MandateClassification1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_MandateClassification1Choice_Cd:
		return soap_out_ns1__MandateClassification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_MandateClassification1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_MandateClassification1Choice * SOAP_FMAC4 soap_in__ns1__union_MandateClassification1Choice(struct soap *soap, int *choice, union _ns1__union_MandateClassification1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__MandateClassification1Code(soap, "Cd", &a->Cd, "ns1:MandateClassification1Code"))
	{	*choice = SOAP_UNION__ns1__union_MandateClassification1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_MandateClassification1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_LocalInstrument2Choice(struct soap *soap, int choice, const union _ns1__union_LocalInstrument2Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_LocalInstrument2Choice_Cd:
		soap_serialize_PointerTons1__ExternalLocalInstrument1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_LocalInstrument2Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_LocalInstrument2Choice(struct soap *soap, int choice, const union _ns1__union_LocalInstrument2Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_LocalInstrument2Choice_Cd:
		return soap_out_PointerTons1__ExternalLocalInstrument1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_LocalInstrument2Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_LocalInstrument2Choice * SOAP_FMAC4 soap_in__ns1__union_LocalInstrument2Choice(struct soap *soap, int *choice, union _ns1__union_LocalInstrument2Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalLocalInstrument1Code(soap, "Cd", &a->Cd, "ns1:ExternalLocalInstrument1Code"))
	{	*choice = SOAP_UNION__ns1__union_LocalInstrument2Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_LocalInstrument2Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_GarnishmentType1Choice(struct soap *soap, int choice, const union _ns1__union_GarnishmentType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_GarnishmentType1Choice_Cd:
		soap_serialize_PointerTons1__ExternalGarnishmentType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_GarnishmentType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_GarnishmentType1Choice(struct soap *soap, int choice, const union _ns1__union_GarnishmentType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_GarnishmentType1Choice_Cd:
		return soap_out_PointerTons1__ExternalGarnishmentType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_GarnishmentType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_GarnishmentType1Choice * SOAP_FMAC4 soap_in__ns1__union_GarnishmentType1Choice(struct soap *soap, int *choice, union _ns1__union_GarnishmentType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalGarnishmentType1Code(soap, "Cd", &a->Cd, "ns1:ExternalGarnishmentType1Code"))
	{	*choice = SOAP_UNION__ns1__union_GarnishmentType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_GarnishmentType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_Frequency36Choice(struct soap *soap, int choice, const union _ns1__union_Frequency36Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Frequency36Choice_Tp:
		break;
	case SOAP_UNION__ns1__union_Frequency36Choice_Prd:
		soap_serialize_PointerTons1__FrequencyPeriod1(soap, &a->Prd);
		break;
	case SOAP_UNION__ns1__union_Frequency36Choice_PtInTm:
		soap_serialize_PointerTons1__FrequencyAndMoment1(soap, &a->PtInTm);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_Frequency36Choice(struct soap *soap, int choice, const union _ns1__union_Frequency36Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Frequency36Choice_Tp:
		return soap_out_ns1__Frequency6Code(soap, "Tp", -1, &a->Tp, "");
	case SOAP_UNION__ns1__union_Frequency36Choice_Prd:
		return soap_out_PointerTons1__FrequencyPeriod1(soap, "Prd", -1, &a->Prd, "");
	case SOAP_UNION__ns1__union_Frequency36Choice_PtInTm:
		return soap_out_PointerTons1__FrequencyAndMoment1(soap, "PtInTm", -1, &a->PtInTm, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_Frequency36Choice * SOAP_FMAC4 soap_in__ns1__union_Frequency36Choice(struct soap *soap, int *choice, union _ns1__union_Frequency36Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__Frequency6Code(soap, "Tp", &a->Tp, "ns1:Frequency6Code"))
	{	*choice = SOAP_UNION__ns1__union_Frequency36Choice_Tp;
		return a;
	}
	a->Prd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FrequencyPeriod1(soap, "Prd", &a->Prd, "ns1:FrequencyPeriod1"))
	{	*choice = SOAP_UNION__ns1__union_Frequency36Choice_Prd;
		return a;
	}
	a->PtInTm = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FrequencyAndMoment1(soap, "PtInTm", &a->PtInTm, "ns1:FrequencyAndMoment1"))
	{	*choice = SOAP_UNION__ns1__union_Frequency36Choice_PtInTm;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_FinancialIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_FinancialIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Cd:
		soap_serialize_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_FinancialIdentificationSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_FinancialIdentificationSchemeName1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Cd:
		return soap_out_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_FinancialIdentificationSchemeName1Choice * SOAP_FMAC4 soap_in__ns1__union_FinancialIdentificationSchemeName1Choice(struct soap *soap, int *choice, union _ns1__union_FinancialIdentificationSchemeName1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, "Cd", &a->Cd, "ns1:ExternalFinancialInstitutionIdentification1Code"))
	{	*choice = SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_DocumentLineType1Choice(struct soap *soap, int choice, const union _ns1__union_DocumentLineType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DocumentLineType1Choice_Cd:
		soap_serialize_PointerTons1__ExternalDocumentLineType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_DocumentLineType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_DocumentLineType1Choice(struct soap *soap, int choice, const union _ns1__union_DocumentLineType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DocumentLineType1Choice_Cd:
		return soap_out_PointerTons1__ExternalDocumentLineType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_DocumentLineType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_DocumentLineType1Choice * SOAP_FMAC4 soap_in__ns1__union_DocumentLineType1Choice(struct soap *soap, int *choice, union _ns1__union_DocumentLineType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalDocumentLineType1Code(soap, "Cd", &a->Cd, "ns1:ExternalDocumentLineType1Code"))
	{	*choice = SOAP_UNION__ns1__union_DocumentLineType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_DocumentLineType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_DiscountAmountType1Choice(struct soap *soap, int choice, const union _ns1__union_DiscountAmountType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DiscountAmountType1Choice_Cd:
		soap_serialize_PointerTons1__ExternalDiscountAmountType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_DiscountAmountType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_DiscountAmountType1Choice(struct soap *soap, int choice, const union _ns1__union_DiscountAmountType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DiscountAmountType1Choice_Cd:
		return soap_out_PointerTons1__ExternalDiscountAmountType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_DiscountAmountType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_DiscountAmountType1Choice * SOAP_FMAC4 soap_in__ns1__union_DiscountAmountType1Choice(struct soap *soap, int *choice, union _ns1__union_DiscountAmountType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalDiscountAmountType1Code(soap, "Cd", &a->Cd, "ns1:ExternalDiscountAmountType1Code"))
	{	*choice = SOAP_UNION__ns1__union_DiscountAmountType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_DiscountAmountType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_DateAndDateTime2Choice(struct soap *soap, int choice, const union _ns1__union_DateAndDateTime2Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DateAndDateTime2Choice_Dt:
		soap_serialize_PointerTons1__ISODate(soap, &a->Dt);
		break;
	case SOAP_UNION__ns1__union_DateAndDateTime2Choice_DtTm:
		soap_serialize_PointerTons1__ISODateTime(soap, &a->DtTm);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_DateAndDateTime2Choice(struct soap *soap, int choice, const union _ns1__union_DateAndDateTime2Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DateAndDateTime2Choice_Dt:
		return soap_out_PointerTons1__ISODate(soap, "Dt", -1, &a->Dt, "");
	case SOAP_UNION__ns1__union_DateAndDateTime2Choice_DtTm:
		return soap_out_PointerTons1__ISODateTime(soap, "DtTm", -1, &a->DtTm, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_DateAndDateTime2Choice * SOAP_FMAC4 soap_in__ns1__union_DateAndDateTime2Choice(struct soap *soap, int *choice, union _ns1__union_DateAndDateTime2Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Dt = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ISODate(soap, "Dt", &a->Dt, "ns1:ISODate"))
	{	*choice = SOAP_UNION__ns1__union_DateAndDateTime2Choice_Dt;
		return a;
	}
	a->DtTm = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ISODateTime(soap, "DtTm", &a->DtTm, "ns1:ISODateTime"))
	{	*choice = SOAP_UNION__ns1__union_DateAndDateTime2Choice_DtTm;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_CreditorReferenceType1Choice(struct soap *soap, int choice, const union _ns1__union_CreditorReferenceType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_CreditorReferenceType1Choice(struct soap *soap, int choice, const union _ns1__union_CreditorReferenceType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Cd:
		return soap_out_ns1__DocumentType3Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_CreditorReferenceType1Choice * SOAP_FMAC4 soap_in__ns1__union_CreditorReferenceType1Choice(struct soap *soap, int *choice, union _ns1__union_CreditorReferenceType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__DocumentType3Code(soap, "Cd", &a->Cd, "ns1:DocumentType3Code"))
	{	*choice = SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ClearingSystemIdentification2Choice(struct soap *soap, int choice, const union _ns1__union_ClearingSystemIdentification2Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Cd:
		soap_serialize_PointerTons1__ExternalClearingSystemIdentification1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ClearingSystemIdentification2Choice(struct soap *soap, int choice, const union _ns1__union_ClearingSystemIdentification2Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Cd:
		return soap_out_PointerTons1__ExternalClearingSystemIdentification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ClearingSystemIdentification2Choice * SOAP_FMAC4 soap_in__ns1__union_ClearingSystemIdentification2Choice(struct soap *soap, int *choice, union _ns1__union_ClearingSystemIdentification2Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalClearingSystemIdentification1Code(soap, "Cd", &a->Cd, "ns1:ExternalClearingSystemIdentification1Code"))
	{	*choice = SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ChequeDeliveryMethod1Choice(struct soap *soap, int choice, const union _ns1__union_ChequeDeliveryMethod1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ChequeDeliveryMethod1Choice(struct soap *soap, int choice, const union _ns1__union_ChequeDeliveryMethod1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Cd:
		return soap_out_ns1__ChequeDelivery1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ChequeDeliveryMethod1Choice * SOAP_FMAC4 soap_in__ns1__union_ChequeDeliveryMethod1Choice(struct soap *soap, int *choice, union _ns1__union_ChequeDeliveryMethod1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__ChequeDelivery1Code(soap, "Cd", &a->Cd, "ns1:ChequeDelivery1Code"))
	{	*choice = SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_CategoryPurpose1Choice(struct soap *soap, int choice, const union _ns1__union_CategoryPurpose1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CategoryPurpose1Choice_Cd:
		soap_serialize_PointerTons1__ExternalCategoryPurpose1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_CategoryPurpose1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_CategoryPurpose1Choice(struct soap *soap, int choice, const union _ns1__union_CategoryPurpose1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CategoryPurpose1Choice_Cd:
		return soap_out_PointerTons1__ExternalCategoryPurpose1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_CategoryPurpose1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_CategoryPurpose1Choice * SOAP_FMAC4 soap_in__ns1__union_CategoryPurpose1Choice(struct soap *soap, int *choice, union _ns1__union_CategoryPurpose1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalCategoryPurpose1Code(soap, "Cd", &a->Cd, "ns1:ExternalCategoryPurpose1Code"))
	{	*choice = SOAP_UNION__ns1__union_CategoryPurpose1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_CategoryPurpose1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_CashAccountType2Choice(struct soap *soap, int choice, const union _ns1__union_CashAccountType2Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CashAccountType2Choice_Cd:
		soap_serialize_PointerTons1__ExternalCashAccountType1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_CashAccountType2Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_CashAccountType2Choice(struct soap *soap, int choice, const union _ns1__union_CashAccountType2Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_CashAccountType2Choice_Cd:
		return soap_out_PointerTons1__ExternalCashAccountType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_CashAccountType2Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_CashAccountType2Choice * SOAP_FMAC4 soap_in__ns1__union_CashAccountType2Choice(struct soap *soap, int *choice, union _ns1__union_CashAccountType2Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalCashAccountType1Code(soap, "Cd", &a->Cd, "ns1:ExternalCashAccountType1Code"))
	{	*choice = SOAP_UNION__ns1__union_CashAccountType2Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_CashAccountType2Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_Authorisation1Choice(struct soap *soap, int choice, const union _ns1__union_Authorisation1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Authorisation1Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_Authorisation1Choice_Prtry:
		soap_serialize_PointerTons1__Max128Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_Authorisation1Choice(struct soap *soap, int choice, const union _ns1__union_Authorisation1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Authorisation1Choice_Cd:
		return soap_out_ns1__Authorisation1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_Authorisation1Choice_Prtry:
		return soap_out_PointerTons1__Max128Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_Authorisation1Choice * SOAP_FMAC4 soap_in__ns1__union_Authorisation1Choice(struct soap *soap, int *choice, union _ns1__union_Authorisation1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__Authorisation1Code(soap, "Cd", &a->Cd, "ns1:Authorisation1Code"))
	{	*choice = SOAP_UNION__ns1__union_Authorisation1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max128Text(soap, "Prtry", &a->Prtry, "ns1:Max128Text"))
	{	*choice = SOAP_UNION__ns1__union_Authorisation1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_AmountType4Choice(struct soap *soap, int choice, const union _ns1__union_AmountType4Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AmountType4Choice_InstdAmt:
		soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, &a->InstdAmt);
		break;
	case SOAP_UNION__ns1__union_AmountType4Choice_EqvtAmt:
		soap_serialize_PointerTons1__EquivalentAmount2(soap, &a->EqvtAmt);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_AmountType4Choice(struct soap *soap, int choice, const union _ns1__union_AmountType4Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AmountType4Choice_InstdAmt:
		return soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "InstdAmt", -1, &a->InstdAmt, "");
	case SOAP_UNION__ns1__union_AmountType4Choice_EqvtAmt:
		return soap_out_PointerTons1__EquivalentAmount2(soap, "EqvtAmt", -1, &a->EqvtAmt, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_AmountType4Choice * SOAP_FMAC4 soap_in__ns1__union_AmountType4Choice(struct soap *soap, int *choice, union _ns1__union_AmountType4Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->InstdAmt = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, "InstdAmt", &a->InstdAmt, "ns1:ActiveOrHistoricCurrencyAndAmount"))
	{	*choice = SOAP_UNION__ns1__union_AmountType4Choice_InstdAmt;
		return a;
	}
	a->EqvtAmt = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__EquivalentAmount2(soap, "EqvtAmt", &a->EqvtAmt, "ns1:EquivalentAmount2"))
	{	*choice = SOAP_UNION__ns1__union_AmountType4Choice_EqvtAmt;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_AdviceType1Choice(struct soap *soap, int choice, const union _ns1__union_AdviceType1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AdviceType1Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_AdviceType1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_AdviceType1Choice(struct soap *soap, int choice, const union _ns1__union_AdviceType1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AdviceType1Choice_Cd:
		return soap_out_ns1__AdviceType1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_AdviceType1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_AdviceType1Choice * SOAP_FMAC4 soap_in__ns1__union_AdviceType1Choice(struct soap *soap, int *choice, union _ns1__union_AdviceType1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__AdviceType1Code(soap, "Cd", &a->Cd, "ns1:AdviceType1Code"))
	{	*choice = SOAP_UNION__ns1__union_AdviceType1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_AdviceType1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_AddressType3Choice(struct soap *soap, int choice, const union _ns1__union_AddressType3Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AddressType3Choice_Cd:
		break;
	case SOAP_UNION__ns1__union_AddressType3Choice_Prtry:
		soap_serialize_PointerTons1__GenericIdentification30(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_AddressType3Choice(struct soap *soap, int choice, const union _ns1__union_AddressType3Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AddressType3Choice_Cd:
		return soap_out_ns1__AddressType2Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_AddressType3Choice_Prtry:
		return soap_out_PointerTons1__GenericIdentification30(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_AddressType3Choice * SOAP_FMAC4 soap_in__ns1__union_AddressType3Choice(struct soap *soap, int *choice, union _ns1__union_AddressType3Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__AddressType2Code(soap, "Cd", &a->Cd, "ns1:AddressType2Code"))
	{	*choice = SOAP_UNION__ns1__union_AddressType3Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__GenericIdentification30(soap, "Prtry", &a->Prtry, "ns1:GenericIdentification30"))
	{	*choice = SOAP_UNION__ns1__union_AddressType3Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_AccountSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_AccountSchemeName1Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AccountSchemeName1Choice_Cd:
		soap_serialize_PointerTons1__ExternalAccountIdentification1Code(soap, &a->Cd);
		break;
	case SOAP_UNION__ns1__union_AccountSchemeName1Choice_Prtry:
		soap_serialize_PointerTons1__Max35Text(soap, &a->Prtry);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_AccountSchemeName1Choice(struct soap *soap, int choice, const union _ns1__union_AccountSchemeName1Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AccountSchemeName1Choice_Cd:
		return soap_out_PointerTons1__ExternalAccountIdentification1Code(soap, "Cd", -1, &a->Cd, "");
	case SOAP_UNION__ns1__union_AccountSchemeName1Choice_Prtry:
		return soap_out_PointerTons1__Max35Text(soap, "Prtry", -1, &a->Prtry, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_AccountSchemeName1Choice * SOAP_FMAC4 soap_in__ns1__union_AccountSchemeName1Choice(struct soap *soap, int *choice, union _ns1__union_AccountSchemeName1Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Cd = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExternalAccountIdentification1Code(soap, "Cd", &a->Cd, "ns1:ExternalAccountIdentification1Code"))
	{	*choice = SOAP_UNION__ns1__union_AccountSchemeName1Choice_Cd;
		return a;
	}
	a->Prtry = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Max35Text(soap, "Prtry", &a->Prtry, "ns1:Max35Text"))
	{	*choice = SOAP_UNION__ns1__union_AccountSchemeName1Choice_Prtry;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_AccountIdentification4Choice(struct soap *soap, int choice, const union _ns1__union_AccountIdentification4Choice *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AccountIdentification4Choice_IBAN:
		soap_serialize_PointerTons1__IBAN2007Identifier(soap, &a->IBAN);
		break;
	case SOAP_UNION__ns1__union_AccountIdentification4Choice_Othr:
		soap_serialize_PointerTons1__GenericAccountIdentification1(soap, &a->Othr);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_AccountIdentification4Choice(struct soap *soap, int choice, const union _ns1__union_AccountIdentification4Choice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_AccountIdentification4Choice_IBAN:
		return soap_out_PointerTons1__IBAN2007Identifier(soap, "IBAN", -1, &a->IBAN, "");
	case SOAP_UNION__ns1__union_AccountIdentification4Choice_Othr:
		return soap_out_PointerTons1__GenericAccountIdentification1(soap, "Othr", -1, &a->Othr, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_AccountIdentification4Choice * SOAP_FMAC4 soap_in__ns1__union_AccountIdentification4Choice(struct soap *soap, int *choice, union _ns1__union_AccountIdentification4Choice *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->IBAN = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__IBAN2007Identifier(soap, "IBAN", &a->IBAN, "ns1:IBAN2007Identifier"))
	{	*choice = SOAP_UNION__ns1__union_AccountIdentification4Choice_IBAN;
		return a;
	}
	a->Othr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__GenericAccountIdentification1(soap, "Othr", &a->Othr, "ns1:GenericAccountIdentification1"))
	{	*choice = SOAP_UNION__ns1__union_AccountIdentification4Choice_Othr;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxAmount3(struct soap *soap, ns1__TaxAmount3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxAmount3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxAmount3(struct soap *soap, const char *tag, int id, ns1__TaxAmount3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxAmount3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxAmount3 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxAmount3 ** SOAP_FMAC4 soap_in_PointerTons1__TaxAmount3(struct soap *soap, const char *tag, ns1__TaxAmount3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxAmount3 **)soap_malloc(soap, sizeof(ns1__TaxAmount3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxAmount3 *)soap_instantiate_ns1__TaxAmount3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxAmount3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxAmount3, sizeof(ns1__TaxAmount3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxAmount3(struct soap *soap, ns1__TaxAmount3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxAmount3(soap, tag ? tag : "ns1:TaxAmount3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxAmount3 ** SOAP_FMAC4 soap_get_PointerTons1__TaxAmount3(struct soap *soap, ns1__TaxAmount3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxAmount3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxPeriod3(struct soap *soap, ns1__TaxPeriod3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxPeriod3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxPeriod3(struct soap *soap, const char *tag, int id, ns1__TaxPeriod3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxPeriod3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxPeriod3 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxPeriod3 ** SOAP_FMAC4 soap_in_PointerTons1__TaxPeriod3(struct soap *soap, const char *tag, ns1__TaxPeriod3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxPeriod3 **)soap_malloc(soap, sizeof(ns1__TaxPeriod3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxPeriod3 *)soap_instantiate_ns1__TaxPeriod3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxPeriod3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxPeriod3, sizeof(ns1__TaxPeriod3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxPeriod3(struct soap *soap, ns1__TaxPeriod3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxPeriod3(soap, tag ? tag : "ns1:TaxPeriod3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxPeriod3 ** SOAP_FMAC4 soap_get_PointerTons1__TaxPeriod3(struct soap *soap, ns1__TaxPeriod3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxPeriod3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DatePeriod2(struct soap *soap, ns1__DatePeriod2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DatePeriod2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DatePeriod2(struct soap *soap, const char *tag, int id, ns1__DatePeriod2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DatePeriod2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DatePeriod2 ? type : NULL);
}

SOAP_FMAC3 ns1__DatePeriod2 ** SOAP_FMAC4 soap_in_PointerTons1__DatePeriod2(struct soap *soap, const char *tag, ns1__DatePeriod2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DatePeriod2 **)soap_malloc(soap, sizeof(ns1__DatePeriod2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DatePeriod2 *)soap_instantiate_ns1__DatePeriod2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DatePeriod2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DatePeriod2, sizeof(ns1__DatePeriod2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DatePeriod2(struct soap *soap, ns1__DatePeriod2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DatePeriod2(soap, tag ? tag : "ns1:DatePeriod2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DatePeriod2 ** SOAP_FMAC4 soap_get_PointerTons1__DatePeriod2(struct soap *soap, ns1__DatePeriod2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxRecordPeriod1Code(struct soap *soap, enum ns1__TaxRecordPeriod1Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__TaxRecordPeriod1Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxRecordPeriod1Code(struct soap *soap, const char *tag, int id, enum ns1__TaxRecordPeriod1Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxRecordPeriod1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TaxRecordPeriod1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TaxRecordPeriod1Code ** SOAP_FMAC4 soap_in_PointerTons1__TaxRecordPeriod1Code(struct soap *soap, const char *tag, enum ns1__TaxRecordPeriod1Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TaxRecordPeriod1Code **)soap_malloc(soap, sizeof(enum ns1__TaxRecordPeriod1Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TaxRecordPeriod1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TaxRecordPeriod1Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxRecordPeriod1Code, sizeof(enum ns1__TaxRecordPeriod1Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxRecordPeriod1Code(struct soap *soap, enum ns1__TaxRecordPeriod1Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxRecordPeriod1Code(soap, tag ? tag : "ns1:TaxRecordPeriod1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TaxRecordPeriod1Code ** SOAP_FMAC4 soap_get_PointerTons1__TaxRecordPeriod1Code(struct soap *soap, enum ns1__TaxRecordPeriod1Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxRecordPeriod1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ISOYear(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ISOYear))
		soap_serialize_ns1__ISOYear(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ISOYear(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ISOYear, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ISOYear(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ISOYear(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ISOYear(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ISOYear, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ISOYear(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ISOYear(soap, tag ? tag : "ns1:ISOYear", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ISOYear(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ISOYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxAuthorisation1(struct soap *soap, ns1__TaxAuthorisation1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxAuthorisation1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxAuthorisation1(struct soap *soap, const char *tag, int id, ns1__TaxAuthorisation1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxAuthorisation1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxAuthorisation1 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxAuthorisation1 ** SOAP_FMAC4 soap_in_PointerTons1__TaxAuthorisation1(struct soap *soap, const char *tag, ns1__TaxAuthorisation1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxAuthorisation1 **)soap_malloc(soap, sizeof(ns1__TaxAuthorisation1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxAuthorisation1 *)soap_instantiate_ns1__TaxAuthorisation1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxAuthorisation1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxAuthorisation1, sizeof(ns1__TaxAuthorisation1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxAuthorisation1(struct soap *soap, ns1__TaxAuthorisation1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxAuthorisation1(soap, tag ? tag : "ns1:TaxAuthorisation1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxAuthorisation1 ** SOAP_FMAC4 soap_get_PointerTons1__TaxAuthorisation1(struct soap *soap, ns1__TaxAuthorisation1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxAuthorisation1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxRecord3(struct soap *soap, ns1__TaxRecord3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxRecord3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxRecord3(struct soap *soap, const char *tag, int id, ns1__TaxRecord3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxRecord3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxRecord3 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxRecord3 ** SOAP_FMAC4 soap_in_PointerTons1__TaxRecord3(struct soap *soap, const char *tag, ns1__TaxRecord3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxRecord3 **)soap_malloc(soap, sizeof(ns1__TaxRecord3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxRecord3 *)soap_instantiate_ns1__TaxRecord3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxRecord3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxRecord3, sizeof(ns1__TaxRecord3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxRecord3(struct soap *soap, ns1__TaxRecord3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxRecord3(soap, tag ? tag : "ns1:TaxRecord3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxRecord3 ** SOAP_FMAC4 soap_get_PointerTons1__TaxRecord3(struct soap *soap, ns1__TaxRecord3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxRecord3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Number(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Number))
		soap_serialize_ns1__Number(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Number(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Number, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Number(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Number(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Number(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Number, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Number(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Number(soap, tag ? tag : "ns1:Number", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Number(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Number(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxParty2(struct soap *soap, ns1__TaxParty2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxParty2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxParty2(struct soap *soap, const char *tag, int id, ns1__TaxParty2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxParty2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxParty2 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxParty2 ** SOAP_FMAC4 soap_in_PointerTons1__TaxParty2(struct soap *soap, const char *tag, ns1__TaxParty2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxParty2 **)soap_malloc(soap, sizeof(ns1__TaxParty2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxParty2 *)soap_instantiate_ns1__TaxParty2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxParty2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxParty2, sizeof(ns1__TaxParty2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxParty2(struct soap *soap, ns1__TaxParty2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxParty2(soap, tag ? tag : "ns1:TaxParty2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxParty2 ** SOAP_FMAC4 soap_get_PointerTons1__TaxParty2(struct soap *soap, ns1__TaxParty2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxParty2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxParty1(struct soap *soap, ns1__TaxParty1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxParty1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxParty1(struct soap *soap, const char *tag, int id, ns1__TaxParty1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxParty1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxParty1 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxParty1 ** SOAP_FMAC4 soap_in_PointerTons1__TaxParty1(struct soap *soap, const char *tag, ns1__TaxParty1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxParty1 **)soap_malloc(soap, sizeof(ns1__TaxParty1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxParty1 *)soap_instantiate_ns1__TaxParty1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxParty1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxParty1, sizeof(ns1__TaxParty1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxParty1(struct soap *soap, ns1__TaxParty1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxParty1(soap, tag ? tag : "ns1:TaxParty1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxParty1 ** SOAP_FMAC4 soap_get_PointerTons1__TaxParty1(struct soap *soap, ns1__TaxParty1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxParty1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalTaxAmountType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalTaxAmountType1Code))
		soap_serialize_ns1__ExternalTaxAmountType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalTaxAmountType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalTaxAmountType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalTaxAmountType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalTaxAmountType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalTaxAmountType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalTaxAmountType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalTaxAmountType1Code(soap, tag ? tag : "ns1:ExternalTaxAmountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalTaxAmountType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalTaxAmountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxAmountType1Choice(struct soap *soap, ns1__TaxAmountType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxAmountType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxAmountType1Choice(struct soap *soap, const char *tag, int id, ns1__TaxAmountType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxAmountType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxAmountType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__TaxAmountType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__TaxAmountType1Choice(struct soap *soap, const char *tag, ns1__TaxAmountType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxAmountType1Choice **)soap_malloc(soap, sizeof(ns1__TaxAmountType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxAmountType1Choice *)soap_instantiate_ns1__TaxAmountType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxAmountType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxAmountType1Choice, sizeof(ns1__TaxAmountType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxAmountType1Choice(struct soap *soap, ns1__TaxAmountType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxAmountType1Choice(soap, tag ? tag : "ns1:TaxAmountType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxAmountType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__TaxAmountType1Choice(struct soap *soap, ns1__TaxAmountType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxAmountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxRecordDetails3(struct soap *soap, ns1__TaxRecordDetails3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxRecordDetails3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxRecordDetails3(struct soap *soap, const char *tag, int id, ns1__TaxRecordDetails3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxRecordDetails3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxRecordDetails3 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxRecordDetails3 ** SOAP_FMAC4 soap_in_PointerTons1__TaxRecordDetails3(struct soap *soap, const char *tag, ns1__TaxRecordDetails3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxRecordDetails3 **)soap_malloc(soap, sizeof(ns1__TaxRecordDetails3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxRecordDetails3 *)soap_instantiate_ns1__TaxRecordDetails3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxRecordDetails3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxRecordDetails3, sizeof(ns1__TaxRecordDetails3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxRecordDetails3(struct soap *soap, ns1__TaxRecordDetails3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxRecordDetails3(soap, tag ? tag : "ns1:TaxRecordDetails3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxRecordDetails3 ** SOAP_FMAC4 soap_get_PointerTons1__TaxRecordDetails3(struct soap *soap, ns1__TaxRecordDetails3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxRecordDetails3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PercentageRate(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PercentageRate))
		soap_serialize_ns1__PercentageRate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PercentageRate(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PercentageRate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PercentageRate(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__PercentageRate(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PercentageRate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PercentageRate, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PercentageRate(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PercentageRate(soap, tag ? tag : "ns1:PercentageRate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__PercentageRate(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PercentageRate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SupplementaryDataEnvelope1(struct soap *soap, ns1__SupplementaryDataEnvelope1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SupplementaryDataEnvelope1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SupplementaryDataEnvelope1(struct soap *soap, const char *tag, int id, ns1__SupplementaryDataEnvelope1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SupplementaryDataEnvelope1 ? type : NULL);
}

SOAP_FMAC3 ns1__SupplementaryDataEnvelope1 ** SOAP_FMAC4 soap_in_PointerTons1__SupplementaryDataEnvelope1(struct soap *soap, const char *tag, ns1__SupplementaryDataEnvelope1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SupplementaryDataEnvelope1 **)soap_malloc(soap, sizeof(ns1__SupplementaryDataEnvelope1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SupplementaryDataEnvelope1 *)soap_instantiate_ns1__SupplementaryDataEnvelope1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SupplementaryDataEnvelope1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupplementaryDataEnvelope1, sizeof(ns1__SupplementaryDataEnvelope1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SupplementaryDataEnvelope1(struct soap *soap, ns1__SupplementaryDataEnvelope1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SupplementaryDataEnvelope1(soap, tag ? tag : "ns1:SupplementaryDataEnvelope1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SupplementaryDataEnvelope1 ** SOAP_FMAC4 soap_get_PointerTons1__SupplementaryDataEnvelope1(struct soap *soap, ns1__SupplementaryDataEnvelope1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SupplementaryDataEnvelope1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max350Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max350Text))
		soap_serialize_ns1__Max350Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max350Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max350Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max350Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max350Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max350Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max350Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max350Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max350Text(soap, tag ? tag : "ns1:Max350Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max350Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max350Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Garnishment3(struct soap *soap, ns1__Garnishment3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Garnishment3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Garnishment3(struct soap *soap, const char *tag, int id, ns1__Garnishment3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Garnishment3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Garnishment3 ? type : NULL);
}

SOAP_FMAC3 ns1__Garnishment3 ** SOAP_FMAC4 soap_in_PointerTons1__Garnishment3(struct soap *soap, const char *tag, ns1__Garnishment3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Garnishment3 **)soap_malloc(soap, sizeof(ns1__Garnishment3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Garnishment3 *)soap_instantiate_ns1__Garnishment3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Garnishment3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Garnishment3, sizeof(ns1__Garnishment3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Garnishment3(struct soap *soap, ns1__Garnishment3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Garnishment3(soap, tag ? tag : "ns1:Garnishment3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Garnishment3 ** SOAP_FMAC4 soap_get_PointerTons1__Garnishment3(struct soap *soap, ns1__Garnishment3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Garnishment3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxData1(struct soap *soap, ns1__TaxData1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxData1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxData1(struct soap *soap, const char *tag, int id, ns1__TaxData1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxData1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxData1 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxData1 ** SOAP_FMAC4 soap_in_PointerTons1__TaxData1(struct soap *soap, const char *tag, ns1__TaxData1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxData1 **)soap_malloc(soap, sizeof(ns1__TaxData1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxData1 *)soap_instantiate_ns1__TaxData1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxData1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxData1, sizeof(ns1__TaxData1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxData1(struct soap *soap, ns1__TaxData1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxData1(soap, tag ? tag : "ns1:TaxData1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxData1 ** SOAP_FMAC4 soap_get_PointerTons1__TaxData1(struct soap *soap, ns1__TaxData1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditorReferenceInformation2(struct soap *soap, ns1__CreditorReferenceInformation2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreditorReferenceInformation2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditorReferenceInformation2(struct soap *soap, const char *tag, int id, ns1__CreditorReferenceInformation2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditorReferenceInformation2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CreditorReferenceInformation2 ? type : NULL);
}

SOAP_FMAC3 ns1__CreditorReferenceInformation2 ** SOAP_FMAC4 soap_in_PointerTons1__CreditorReferenceInformation2(struct soap *soap, const char *tag, ns1__CreditorReferenceInformation2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreditorReferenceInformation2 **)soap_malloc(soap, sizeof(ns1__CreditorReferenceInformation2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreditorReferenceInformation2 *)soap_instantiate_ns1__CreditorReferenceInformation2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CreditorReferenceInformation2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditorReferenceInformation2, sizeof(ns1__CreditorReferenceInformation2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditorReferenceInformation2(struct soap *soap, ns1__CreditorReferenceInformation2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditorReferenceInformation2(soap, tag ? tag : "ns1:CreditorReferenceInformation2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreditorReferenceInformation2 ** SOAP_FMAC4 soap_get_PointerTons1__CreditorReferenceInformation2(struct soap *soap, ns1__CreditorReferenceInformation2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditorReferenceInformation2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemittanceAmount2(struct soap *soap, ns1__RemittanceAmount2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemittanceAmount2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemittanceAmount2(struct soap *soap, const char *tag, int id, ns1__RemittanceAmount2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemittanceAmount2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RemittanceAmount2 ? type : NULL);
}

SOAP_FMAC3 ns1__RemittanceAmount2 ** SOAP_FMAC4 soap_in_PointerTons1__RemittanceAmount2(struct soap *soap, const char *tag, ns1__RemittanceAmount2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemittanceAmount2 **)soap_malloc(soap, sizeof(ns1__RemittanceAmount2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemittanceAmount2 *)soap_instantiate_ns1__RemittanceAmount2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RemittanceAmount2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemittanceAmount2, sizeof(ns1__RemittanceAmount2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemittanceAmount2(struct soap *soap, ns1__RemittanceAmount2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RemittanceAmount2(soap, tag ? tag : "ns1:RemittanceAmount2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RemittanceAmount2 ** SOAP_FMAC4 soap_get_PointerTons1__RemittanceAmount2(struct soap *soap, ns1__RemittanceAmount2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemittanceAmount2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReferredDocumentInformation7(struct soap *soap, ns1__ReferredDocumentInformation7 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReferredDocumentInformation7))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReferredDocumentInformation7(struct soap *soap, const char *tag, int id, ns1__ReferredDocumentInformation7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReferredDocumentInformation7, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ReferredDocumentInformation7 ? type : NULL);
}

SOAP_FMAC3 ns1__ReferredDocumentInformation7 ** SOAP_FMAC4 soap_in_PointerTons1__ReferredDocumentInformation7(struct soap *soap, const char *tag, ns1__ReferredDocumentInformation7 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReferredDocumentInformation7 **)soap_malloc(soap, sizeof(ns1__ReferredDocumentInformation7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReferredDocumentInformation7 *)soap_instantiate_ns1__ReferredDocumentInformation7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReferredDocumentInformation7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReferredDocumentInformation7, sizeof(ns1__ReferredDocumentInformation7), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReferredDocumentInformation7(struct soap *soap, ns1__ReferredDocumentInformation7 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ReferredDocumentInformation7(soap, tag ? tag : "ns1:ReferredDocumentInformation7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReferredDocumentInformation7 ** SOAP_FMAC4 soap_get_PointerTons1__ReferredDocumentInformation7(struct soap *soap, ns1__ReferredDocumentInformation7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReferredDocumentInformation7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max10Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max10Text))
		soap_serialize_ns1__Max10Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max10Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max10Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max10Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max10Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max10Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max10Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max10Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max10Text(soap, tag ? tag : "ns1:Max10Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max10Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max10Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalServiceLevel1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalServiceLevel1Code))
		soap_serialize_ns1__ExternalServiceLevel1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalServiceLevel1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalServiceLevel1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalServiceLevel1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalServiceLevel1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalServiceLevel1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalServiceLevel1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalServiceLevel1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalServiceLevel1Code(soap, tag ? tag : "ns1:ExternalServiceLevel1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalServiceLevel1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalServiceLevel1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemittanceLocationData1(struct soap *soap, ns1__RemittanceLocationData1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemittanceLocationData1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemittanceLocationData1(struct soap *soap, const char *tag, int id, ns1__RemittanceLocationData1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemittanceLocationData1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RemittanceLocationData1 ? type : NULL);
}

SOAP_FMAC3 ns1__RemittanceLocationData1 ** SOAP_FMAC4 soap_in_PointerTons1__RemittanceLocationData1(struct soap *soap, const char *tag, ns1__RemittanceLocationData1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemittanceLocationData1 **)soap_malloc(soap, sizeof(ns1__RemittanceLocationData1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemittanceLocationData1 *)soap_instantiate_ns1__RemittanceLocationData1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RemittanceLocationData1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemittanceLocationData1, sizeof(ns1__RemittanceLocationData1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemittanceLocationData1(struct soap *soap, ns1__RemittanceLocationData1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RemittanceLocationData1(soap, tag ? tag : "ns1:RemittanceLocationData1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RemittanceLocationData1 ** SOAP_FMAC4 soap_get_PointerTons1__RemittanceLocationData1(struct soap *soap, ns1__RemittanceLocationData1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemittanceLocationData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StructuredRemittanceInformation17(struct soap *soap, ns1__StructuredRemittanceInformation17 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StructuredRemittanceInformation17))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, int id, ns1__StructuredRemittanceInformation17 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StructuredRemittanceInformation17, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StructuredRemittanceInformation17 ? type : NULL);
}

SOAP_FMAC3 ns1__StructuredRemittanceInformation17 ** SOAP_FMAC4 soap_in_PointerTons1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, ns1__StructuredRemittanceInformation17 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StructuredRemittanceInformation17 **)soap_malloc(soap, sizeof(ns1__StructuredRemittanceInformation17 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StructuredRemittanceInformation17 *)soap_instantiate_ns1__StructuredRemittanceInformation17(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StructuredRemittanceInformation17 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StructuredRemittanceInformation17, sizeof(ns1__StructuredRemittanceInformation17), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StructuredRemittanceInformation17(struct soap *soap, ns1__StructuredRemittanceInformation17 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StructuredRemittanceInformation17(soap, tag ? tag : "ns1:StructuredRemittanceInformation17", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StructuredRemittanceInformation17 ** SOAP_FMAC4 soap_get_PointerTons1__StructuredRemittanceInformation17(struct soap *soap, ns1__StructuredRemittanceInformation17 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StructuredRemittanceInformation17(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentAdjustment1(struct soap *soap, ns1__DocumentAdjustment1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentAdjustment1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentAdjustment1(struct soap *soap, const char *tag, int id, ns1__DocumentAdjustment1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentAdjustment1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DocumentAdjustment1 ? type : NULL);
}

SOAP_FMAC3 ns1__DocumentAdjustment1 ** SOAP_FMAC4 soap_in_PointerTons1__DocumentAdjustment1(struct soap *soap, const char *tag, ns1__DocumentAdjustment1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DocumentAdjustment1 **)soap_malloc(soap, sizeof(ns1__DocumentAdjustment1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DocumentAdjustment1 *)soap_instantiate_ns1__DocumentAdjustment1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentAdjustment1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentAdjustment1, sizeof(ns1__DocumentAdjustment1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentAdjustment1(struct soap *soap, ns1__DocumentAdjustment1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DocumentAdjustment1(soap, tag ? tag : "ns1:DocumentAdjustment1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DocumentAdjustment1 ** SOAP_FMAC4 soap_get_PointerTons1__DocumentAdjustment1(struct soap *soap, ns1__DocumentAdjustment1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentAdjustment1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxAmountAndType1(struct soap *soap, ns1__TaxAmountAndType1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxAmountAndType1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxAmountAndType1(struct soap *soap, const char *tag, int id, ns1__TaxAmountAndType1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxAmountAndType1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxAmountAndType1 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxAmountAndType1 ** SOAP_FMAC4 soap_in_PointerTons1__TaxAmountAndType1(struct soap *soap, const char *tag, ns1__TaxAmountAndType1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxAmountAndType1 **)soap_malloc(soap, sizeof(ns1__TaxAmountAndType1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxAmountAndType1 *)soap_instantiate_ns1__TaxAmountAndType1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxAmountAndType1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxAmountAndType1, sizeof(ns1__TaxAmountAndType1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxAmountAndType1(struct soap *soap, ns1__TaxAmountAndType1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxAmountAndType1(soap, tag ? tag : "ns1:TaxAmountAndType1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxAmountAndType1 ** SOAP_FMAC4 soap_get_PointerTons1__TaxAmountAndType1(struct soap *soap, ns1__TaxAmountAndType1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxAmountAndType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DiscountAmountAndType1(struct soap *soap, ns1__DiscountAmountAndType1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DiscountAmountAndType1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DiscountAmountAndType1(struct soap *soap, const char *tag, int id, ns1__DiscountAmountAndType1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DiscountAmountAndType1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DiscountAmountAndType1 ? type : NULL);
}

SOAP_FMAC3 ns1__DiscountAmountAndType1 ** SOAP_FMAC4 soap_in_PointerTons1__DiscountAmountAndType1(struct soap *soap, const char *tag, ns1__DiscountAmountAndType1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DiscountAmountAndType1 **)soap_malloc(soap, sizeof(ns1__DiscountAmountAndType1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DiscountAmountAndType1 *)soap_instantiate_ns1__DiscountAmountAndType1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DiscountAmountAndType1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DiscountAmountAndType1, sizeof(ns1__DiscountAmountAndType1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DiscountAmountAndType1(struct soap *soap, ns1__DiscountAmountAndType1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DiscountAmountAndType1(soap, tag ? tag : "ns1:DiscountAmountAndType1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DiscountAmountAndType1 ** SOAP_FMAC4 soap_get_PointerTons1__DiscountAmountAndType1(struct soap *soap, ns1__DiscountAmountAndType1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DiscountAmountAndType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StructuredRegulatoryReporting3(struct soap *soap, ns1__StructuredRegulatoryReporting3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StructuredRegulatoryReporting3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, int id, ns1__StructuredRegulatoryReporting3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StructuredRegulatoryReporting3 ? type : NULL);
}

SOAP_FMAC3 ns1__StructuredRegulatoryReporting3 ** SOAP_FMAC4 soap_in_PointerTons1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, ns1__StructuredRegulatoryReporting3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StructuredRegulatoryReporting3 **)soap_malloc(soap, sizeof(ns1__StructuredRegulatoryReporting3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StructuredRegulatoryReporting3 *)soap_instantiate_ns1__StructuredRegulatoryReporting3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StructuredRegulatoryReporting3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StructuredRegulatoryReporting3, sizeof(ns1__StructuredRegulatoryReporting3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StructuredRegulatoryReporting3(struct soap *soap, ns1__StructuredRegulatoryReporting3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StructuredRegulatoryReporting3(soap, tag ? tag : "ns1:StructuredRegulatoryReporting3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StructuredRegulatoryReporting3 ** SOAP_FMAC4 soap_get_PointerTons1__StructuredRegulatoryReporting3(struct soap *soap, ns1__StructuredRegulatoryReporting3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StructuredRegulatoryReporting3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegulatoryAuthority2(struct soap *soap, ns1__RegulatoryAuthority2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RegulatoryAuthority2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegulatoryAuthority2(struct soap *soap, const char *tag, int id, ns1__RegulatoryAuthority2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegulatoryAuthority2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RegulatoryAuthority2 ? type : NULL);
}

SOAP_FMAC3 ns1__RegulatoryAuthority2 ** SOAP_FMAC4 soap_in_PointerTons1__RegulatoryAuthority2(struct soap *soap, const char *tag, ns1__RegulatoryAuthority2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegulatoryAuthority2 **)soap_malloc(soap, sizeof(ns1__RegulatoryAuthority2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RegulatoryAuthority2 *)soap_instantiate_ns1__RegulatoryAuthority2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RegulatoryAuthority2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegulatoryAuthority2, sizeof(ns1__RegulatoryAuthority2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegulatoryAuthority2(struct soap *soap, ns1__RegulatoryAuthority2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RegulatoryAuthority2(soap, tag ? tag : "ns1:RegulatoryAuthority2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RegulatoryAuthority2 ** SOAP_FMAC4 soap_get_PointerTons1__RegulatoryAuthority2(struct soap *soap, ns1__RegulatoryAuthority2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegulatoryAuthority2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegulatoryReportingType1Code(struct soap *soap, enum ns1__RegulatoryReportingType1Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__RegulatoryReportingType1Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegulatoryReportingType1Code(struct soap *soap, const char *tag, int id, enum ns1__RegulatoryReportingType1Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegulatoryReportingType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RegulatoryReportingType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__RegulatoryReportingType1Code ** SOAP_FMAC4 soap_in_PointerTons1__RegulatoryReportingType1Code(struct soap *soap, const char *tag, enum ns1__RegulatoryReportingType1Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__RegulatoryReportingType1Code **)soap_malloc(soap, sizeof(enum ns1__RegulatoryReportingType1Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RegulatoryReportingType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__RegulatoryReportingType1Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegulatoryReportingType1Code, sizeof(enum ns1__RegulatoryReportingType1Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegulatoryReportingType1Code(struct soap *soap, enum ns1__RegulatoryReportingType1Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RegulatoryReportingType1Code(soap, tag ? tag : "ns1:RegulatoryReportingType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RegulatoryReportingType1Code ** SOAP_FMAC4 soap_get_PointerTons1__RegulatoryReportingType1Code(struct soap *soap, enum ns1__RegulatoryReportingType1Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegulatoryReportingType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReferredDocumentType3Choice(struct soap *soap, ns1__ReferredDocumentType3Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReferredDocumentType3Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReferredDocumentType3Choice(struct soap *soap, const char *tag, int id, ns1__ReferredDocumentType3Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReferredDocumentType3Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ReferredDocumentType3Choice ? type : NULL);
}

SOAP_FMAC3 ns1__ReferredDocumentType3Choice ** SOAP_FMAC4 soap_in_PointerTons1__ReferredDocumentType3Choice(struct soap *soap, const char *tag, ns1__ReferredDocumentType3Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReferredDocumentType3Choice **)soap_malloc(soap, sizeof(ns1__ReferredDocumentType3Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReferredDocumentType3Choice *)soap_instantiate_ns1__ReferredDocumentType3Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReferredDocumentType3Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReferredDocumentType3Choice, sizeof(ns1__ReferredDocumentType3Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReferredDocumentType3Choice(struct soap *soap, ns1__ReferredDocumentType3Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ReferredDocumentType3Choice(soap, tag ? tag : "ns1:ReferredDocumentType3Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReferredDocumentType3Choice ** SOAP_FMAC4 soap_get_PointerTons1__ReferredDocumentType3Choice(struct soap *soap, ns1__ReferredDocumentType3Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReferredDocumentType3Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentLineInformation1(struct soap *soap, ns1__DocumentLineInformation1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentLineInformation1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentLineInformation1(struct soap *soap, const char *tag, int id, ns1__DocumentLineInformation1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentLineInformation1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DocumentLineInformation1 ? type : NULL);
}

SOAP_FMAC3 ns1__DocumentLineInformation1 ** SOAP_FMAC4 soap_in_PointerTons1__DocumentLineInformation1(struct soap *soap, const char *tag, ns1__DocumentLineInformation1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DocumentLineInformation1 **)soap_malloc(soap, sizeof(ns1__DocumentLineInformation1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DocumentLineInformation1 *)soap_instantiate_ns1__DocumentLineInformation1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentLineInformation1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentLineInformation1, sizeof(ns1__DocumentLineInformation1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentLineInformation1(struct soap *soap, ns1__DocumentLineInformation1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DocumentLineInformation1(soap, tag ? tag : "ns1:DocumentLineInformation1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DocumentLineInformation1 ** SOAP_FMAC4 soap_get_PointerTons1__DocumentLineInformation1(struct soap *soap, ns1__DocumentLineInformation1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentLineInformation1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReferredDocumentType4(struct soap *soap, ns1__ReferredDocumentType4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReferredDocumentType4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReferredDocumentType4(struct soap *soap, const char *tag, int id, ns1__ReferredDocumentType4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReferredDocumentType4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ReferredDocumentType4 ? type : NULL);
}

SOAP_FMAC3 ns1__ReferredDocumentType4 ** SOAP_FMAC4 soap_in_PointerTons1__ReferredDocumentType4(struct soap *soap, const char *tag, ns1__ReferredDocumentType4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReferredDocumentType4 **)soap_malloc(soap, sizeof(ns1__ReferredDocumentType4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReferredDocumentType4 *)soap_instantiate_ns1__ReferredDocumentType4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReferredDocumentType4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReferredDocumentType4, sizeof(ns1__ReferredDocumentType4), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReferredDocumentType4(struct soap *soap, ns1__ReferredDocumentType4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ReferredDocumentType4(soap, tag ? tag : "ns1:ReferredDocumentType4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReferredDocumentType4 ** SOAP_FMAC4 soap_get_PointerTons1__ReferredDocumentType4(struct soap *soap, ns1__ReferredDocumentType4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReferredDocumentType4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalPurpose1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalPurpose1Code))
		soap_serialize_ns1__ExternalPurpose1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalPurpose1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalPurpose1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalPurpose1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalPurpose1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalPurpose1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalPurpose1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalPurpose1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalPurpose1Code(soap, tag ? tag : "ns1:ExternalPurpose1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalPurpose1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalPurpose1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalProxyAccountType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalProxyAccountType1Code))
		soap_serialize_ns1__ExternalProxyAccountType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalProxyAccountType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalProxyAccountType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalProxyAccountType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalProxyAccountType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalProxyAccountType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalProxyAccountType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalProxyAccountType1Code(soap, tag ? tag : "ns1:ExternalProxyAccountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalProxyAccountType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalProxyAccountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProxyAccountType1Choice(struct soap *soap, ns1__ProxyAccountType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProxyAccountType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProxyAccountType1Choice(struct soap *soap, const char *tag, int id, ns1__ProxyAccountType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProxyAccountType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ProxyAccountType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__ProxyAccountType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__ProxyAccountType1Choice(struct soap *soap, const char *tag, ns1__ProxyAccountType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProxyAccountType1Choice **)soap_malloc(soap, sizeof(ns1__ProxyAccountType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProxyAccountType1Choice *)soap_instantiate_ns1__ProxyAccountType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ProxyAccountType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProxyAccountType1Choice, sizeof(ns1__ProxyAccountType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProxyAccountType1Choice(struct soap *soap, ns1__ProxyAccountType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ProxyAccountType1Choice(soap, tag ? tag : "ns1:ProxyAccountType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ProxyAccountType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__ProxyAccountType1Choice(struct soap *soap, ns1__ProxyAccountType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProxyAccountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max16Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max16Text))
		soap_serialize_ns1__Max16Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max16Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max16Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max16Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max16Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max16Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max16Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max16Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max16Text(soap, tag ? tag : "ns1:Max16Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max16Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max16Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddressType3Choice(struct soap *soap, ns1__AddressType3Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddressType3Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddressType3Choice(struct soap *soap, const char *tag, int id, ns1__AddressType3Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AddressType3Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AddressType3Choice ? type : NULL);
}

SOAP_FMAC3 ns1__AddressType3Choice ** SOAP_FMAC4 soap_in_PointerTons1__AddressType3Choice(struct soap *soap, const char *tag, ns1__AddressType3Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AddressType3Choice **)soap_malloc(soap, sizeof(ns1__AddressType3Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AddressType3Choice *)soap_instantiate_ns1__AddressType3Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AddressType3Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AddressType3Choice, sizeof(ns1__AddressType3Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddressType3Choice(struct soap *soap, ns1__AddressType3Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AddressType3Choice(soap, tag ? tag : "ns1:AddressType3Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AddressType3Choice ** SOAP_FMAC4 soap_get_PointerTons1__AddressType3Choice(struct soap *soap, ns1__AddressType3Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddressType3Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalPersonIdentification1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalPersonIdentification1Code))
		soap_serialize_ns1__ExternalPersonIdentification1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalPersonIdentification1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalPersonIdentification1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalPersonIdentification1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalPersonIdentification1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalPersonIdentification1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalPersonIdentification1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalPersonIdentification1Code(soap, tag ? tag : "ns1:ExternalPersonIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalPersonIdentification1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalPersonIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericPersonIdentification1(struct soap *soap, ns1__GenericPersonIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericPersonIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericPersonIdentification1(struct soap *soap, const char *tag, int id, ns1__GenericPersonIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericPersonIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericPersonIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__GenericPersonIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__GenericPersonIdentification1(struct soap *soap, const char *tag, ns1__GenericPersonIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericPersonIdentification1 **)soap_malloc(soap, sizeof(ns1__GenericPersonIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericPersonIdentification1 *)soap_instantiate_ns1__GenericPersonIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericPersonIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericPersonIdentification1, sizeof(ns1__GenericPersonIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericPersonIdentification1(struct soap *soap, ns1__GenericPersonIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericPersonIdentification1(soap, tag ? tag : "ns1:GenericPersonIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericPersonIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__GenericPersonIdentification1(struct soap *soap, ns1__GenericPersonIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericPersonIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateAndPlaceOfBirth1(struct soap *soap, ns1__DateAndPlaceOfBirth1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DateAndPlaceOfBirth1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateAndPlaceOfBirth1(struct soap *soap, const char *tag, int id, ns1__DateAndPlaceOfBirth1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DateAndPlaceOfBirth1 ? type : NULL);
}

SOAP_FMAC3 ns1__DateAndPlaceOfBirth1 ** SOAP_FMAC4 soap_in_PointerTons1__DateAndPlaceOfBirth1(struct soap *soap, const char *tag, ns1__DateAndPlaceOfBirth1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DateAndPlaceOfBirth1 **)soap_malloc(soap, sizeof(ns1__DateAndPlaceOfBirth1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DateAndPlaceOfBirth1 *)soap_instantiate_ns1__DateAndPlaceOfBirth1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DateAndPlaceOfBirth1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateAndPlaceOfBirth1, sizeof(ns1__DateAndPlaceOfBirth1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateAndPlaceOfBirth1(struct soap *soap, ns1__DateAndPlaceOfBirth1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateAndPlaceOfBirth1(soap, tag ? tag : "ns1:DateAndPlaceOfBirth1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DateAndPlaceOfBirth1 ** SOAP_FMAC4 soap_get_PointerTons1__DateAndPlaceOfBirth1(struct soap *soap, ns1__DateAndPlaceOfBirth1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateAndPlaceOfBirth1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditTransferTransaction54(struct soap *soap, ns1__CreditTransferTransaction54 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreditTransferTransaction54))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditTransferTransaction54(struct soap *soap, const char *tag, int id, ns1__CreditTransferTransaction54 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditTransferTransaction54, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CreditTransferTransaction54 ? type : NULL);
}

SOAP_FMAC3 ns1__CreditTransferTransaction54 ** SOAP_FMAC4 soap_in_PointerTons1__CreditTransferTransaction54(struct soap *soap, const char *tag, ns1__CreditTransferTransaction54 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreditTransferTransaction54 **)soap_malloc(soap, sizeof(ns1__CreditTransferTransaction54 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreditTransferTransaction54 *)soap_instantiate_ns1__CreditTransferTransaction54(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CreditTransferTransaction54 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditTransferTransaction54, sizeof(ns1__CreditTransferTransaction54), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditTransferTransaction54(struct soap *soap, ns1__CreditTransferTransaction54 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditTransferTransaction54(soap, tag ? tag : "ns1:CreditTransferTransaction54", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreditTransferTransaction54 ** SOAP_FMAC4 soap_get_PointerTons1__CreditTransferTransaction54(struct soap *soap, ns1__CreditTransferTransaction54 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditTransferTransaction54(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateAndDateTime2Choice(struct soap *soap, ns1__DateAndDateTime2Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DateAndDateTime2Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateAndDateTime2Choice(struct soap *soap, const char *tag, int id, ns1__DateAndDateTime2Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateAndDateTime2Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DateAndDateTime2Choice ? type : NULL);
}

SOAP_FMAC3 ns1__DateAndDateTime2Choice ** SOAP_FMAC4 soap_in_PointerTons1__DateAndDateTime2Choice(struct soap *soap, const char *tag, ns1__DateAndDateTime2Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DateAndDateTime2Choice **)soap_malloc(soap, sizeof(ns1__DateAndDateTime2Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DateAndDateTime2Choice *)soap_instantiate_ns1__DateAndDateTime2Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DateAndDateTime2Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateAndDateTime2Choice, sizeof(ns1__DateAndDateTime2Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateAndDateTime2Choice(struct soap *soap, ns1__DateAndDateTime2Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateAndDateTime2Choice(soap, tag ? tag : "ns1:DateAndDateTime2Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DateAndDateTime2Choice ** SOAP_FMAC4 soap_get_PointerTons1__DateAndDateTime2Choice(struct soap *soap, ns1__DateAndDateTime2Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateAndDateTime2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max15NumericText(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max15NumericText))
		soap_serialize_ns1__Max15NumericText(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max15NumericText(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max15NumericText, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max15NumericText(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max15NumericText(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max15NumericText(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max15NumericText, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max15NumericText(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max15NumericText(soap, tag ? tag : "ns1:Max15NumericText", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max15NumericText(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max15NumericText(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BatchBookingIndicator(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__BatchBookingIndicator);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BatchBookingIndicator(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BatchBookingIndicator, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BatchBookingIndicator(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTons1__BatchBookingIndicator(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BatchBookingIndicator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BatchBookingIndicator, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BatchBookingIndicator(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BatchBookingIndicator(soap, tag ? tag : "ns1:BatchBookingIndicator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTons1__BatchBookingIndicator(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BatchBookingIndicator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AdviceType1(struct soap *soap, ns1__AdviceType1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AdviceType1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AdviceType1(struct soap *soap, const char *tag, int id, ns1__AdviceType1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AdviceType1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AdviceType1 ? type : NULL);
}

SOAP_FMAC3 ns1__AdviceType1 ** SOAP_FMAC4 soap_in_PointerTons1__AdviceType1(struct soap *soap, const char *tag, ns1__AdviceType1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AdviceType1 **)soap_malloc(soap, sizeof(ns1__AdviceType1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AdviceType1 *)soap_instantiate_ns1__AdviceType1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AdviceType1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AdviceType1, sizeof(ns1__AdviceType1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AdviceType1(struct soap *soap, ns1__AdviceType1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AdviceType1(soap, tag ? tag : "ns1:AdviceType1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AdviceType1 ** SOAP_FMAC4 soap_get_PointerTons1__AdviceType1(struct soap *soap, ns1__AdviceType1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AdviceType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UUIDv4Identifier(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UUIDv4Identifier))
		soap_serialize_ns1__UUIDv4Identifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UUIDv4Identifier(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UUIDv4Identifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__UUIDv4Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__UUIDv4Identifier(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__UUIDv4Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UUIDv4Identifier, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UUIDv4Identifier(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__UUIDv4Identifier(soap, tag ? tag : "ns1:UUIDv4Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__UUIDv4Identifier(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UUIDv4Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Contact4(struct soap *soap, ns1__Contact4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Contact4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Contact4(struct soap *soap, const char *tag, int id, ns1__Contact4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Contact4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Contact4 ? type : NULL);
}

SOAP_FMAC3 ns1__Contact4 ** SOAP_FMAC4 soap_in_PointerTons1__Contact4(struct soap *soap, const char *tag, ns1__Contact4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Contact4 **)soap_malloc(soap, sizeof(ns1__Contact4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Contact4 *)soap_instantiate_ns1__Contact4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Contact4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Contact4, sizeof(ns1__Contact4), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Contact4(struct soap *soap, ns1__Contact4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Contact4(soap, tag ? tag : "ns1:Contact4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Contact4 ** SOAP_FMAC4 soap_get_PointerTons1__Contact4(struct soap *soap, ns1__Contact4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Contact4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryCode(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CountryCode))
		soap_serialize_ns1__CountryCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryCode(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CountryCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__CountryCode(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CountryCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryCode, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryCode(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CountryCode(soap, tag ? tag : "ns1:CountryCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__CountryCode(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Party38Choice(struct soap *soap, ns1__Party38Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Party38Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Party38Choice(struct soap *soap, const char *tag, int id, ns1__Party38Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Party38Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Party38Choice ? type : NULL);
}

SOAP_FMAC3 ns1__Party38Choice ** SOAP_FMAC4 soap_in_PointerTons1__Party38Choice(struct soap *soap, const char *tag, ns1__Party38Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Party38Choice **)soap_malloc(soap, sizeof(ns1__Party38Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Party38Choice *)soap_instantiate_ns1__Party38Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Party38Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Party38Choice, sizeof(ns1__Party38Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Party38Choice(struct soap *soap, ns1__Party38Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Party38Choice(soap, tag ? tag : "ns1:Party38Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Party38Choice ** SOAP_FMAC4 soap_get_PointerTons1__Party38Choice(struct soap *soap, ns1__Party38Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Party38Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PersonIdentification13(struct soap *soap, ns1__PersonIdentification13 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PersonIdentification13))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PersonIdentification13(struct soap *soap, const char *tag, int id, ns1__PersonIdentification13 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PersonIdentification13, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PersonIdentification13 ? type : NULL);
}

SOAP_FMAC3 ns1__PersonIdentification13 ** SOAP_FMAC4 soap_in_PointerTons1__PersonIdentification13(struct soap *soap, const char *tag, ns1__PersonIdentification13 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PersonIdentification13 **)soap_malloc(soap, sizeof(ns1__PersonIdentification13 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PersonIdentification13 *)soap_instantiate_ns1__PersonIdentification13(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PersonIdentification13 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PersonIdentification13, sizeof(ns1__PersonIdentification13), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PersonIdentification13(struct soap *soap, ns1__PersonIdentification13 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PersonIdentification13(soap, tag ? tag : "ns1:PersonIdentification13", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PersonIdentification13 ** SOAP_FMAC4 soap_get_PointerTons1__PersonIdentification13(struct soap *soap, ns1__PersonIdentification13 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PersonIdentification13(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrganisationIdentification29(struct soap *soap, ns1__OrganisationIdentification29 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrganisationIdentification29))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrganisationIdentification29(struct soap *soap, const char *tag, int id, ns1__OrganisationIdentification29 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrganisationIdentification29, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OrganisationIdentification29 ? type : NULL);
}

SOAP_FMAC3 ns1__OrganisationIdentification29 ** SOAP_FMAC4 soap_in_PointerTons1__OrganisationIdentification29(struct soap *soap, const char *tag, ns1__OrganisationIdentification29 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrganisationIdentification29 **)soap_malloc(soap, sizeof(ns1__OrganisationIdentification29 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrganisationIdentification29 *)soap_instantiate_ns1__OrganisationIdentification29(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OrganisationIdentification29 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrganisationIdentification29, sizeof(ns1__OrganisationIdentification29), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrganisationIdentification29(struct soap *soap, ns1__OrganisationIdentification29 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OrganisationIdentification29(soap, tag ? tag : "ns1:OrganisationIdentification29", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrganisationIdentification29 ** SOAP_FMAC4 soap_get_PointerTons1__OrganisationIdentification29(struct soap *soap, ns1__OrganisationIdentification29 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrganisationIdentification29(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalOrganisationIdentification1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code))
		soap_serialize_ns1__ExternalOrganisationIdentification1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalOrganisationIdentification1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalOrganisationIdentification1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalOrganisationIdentification1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalOrganisationIdentification1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalOrganisationIdentification1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalOrganisationIdentification1Code(soap, tag ? tag : "ns1:ExternalOrganisationIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalOrganisationIdentification1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalOrganisationIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericOrganisationIdentification1(struct soap *soap, ns1__GenericOrganisationIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericOrganisationIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, int id, ns1__GenericOrganisationIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericOrganisationIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericOrganisationIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__GenericOrganisationIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, ns1__GenericOrganisationIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericOrganisationIdentification1 **)soap_malloc(soap, sizeof(ns1__GenericOrganisationIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericOrganisationIdentification1 *)soap_instantiate_ns1__GenericOrganisationIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericOrganisationIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericOrganisationIdentification1, sizeof(ns1__GenericOrganisationIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericOrganisationIdentification1(struct soap *soap, ns1__GenericOrganisationIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericOrganisationIdentification1(soap, tag ? tag : "ns1:GenericOrganisationIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericOrganisationIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__GenericOrganisationIdentification1(struct soap *soap, ns1__GenericOrganisationIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericOrganisationIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AnyBICDec2014Identifier(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AnyBICDec2014Identifier))
		soap_serialize_ns1__AnyBICDec2014Identifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AnyBICDec2014Identifier(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AnyBICDec2014Identifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AnyBICDec2014Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__AnyBICDec2014Identifier(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AnyBICDec2014Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AnyBICDec2014Identifier, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AnyBICDec2014Identifier(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AnyBICDec2014Identifier(soap, tag ? tag : "ns1:AnyBICDec2014Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__AnyBICDec2014Identifier(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AnyBICDec2014Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MandateClassification1Choice(struct soap *soap, ns1__MandateClassification1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MandateClassification1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MandateClassification1Choice(struct soap *soap, const char *tag, int id, ns1__MandateClassification1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MandateClassification1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MandateClassification1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__MandateClassification1Choice ** SOAP_FMAC4 soap_in_PointerTons1__MandateClassification1Choice(struct soap *soap, const char *tag, ns1__MandateClassification1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MandateClassification1Choice **)soap_malloc(soap, sizeof(ns1__MandateClassification1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MandateClassification1Choice *)soap_instantiate_ns1__MandateClassification1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MandateClassification1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MandateClassification1Choice, sizeof(ns1__MandateClassification1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MandateClassification1Choice(struct soap *soap, ns1__MandateClassification1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MandateClassification1Choice(soap, tag ? tag : "ns1:MandateClassification1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MandateClassification1Choice ** SOAP_FMAC4 soap_get_PointerTons1__MandateClassification1Choice(struct soap *soap, ns1__MandateClassification1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MandateClassification1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CategoryPurpose1Choice(struct soap *soap, ns1__CategoryPurpose1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CategoryPurpose1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CategoryPurpose1Choice(struct soap *soap, const char *tag, int id, ns1__CategoryPurpose1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CategoryPurpose1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CategoryPurpose1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__CategoryPurpose1Choice ** SOAP_FMAC4 soap_in_PointerTons1__CategoryPurpose1Choice(struct soap *soap, const char *tag, ns1__CategoryPurpose1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CategoryPurpose1Choice **)soap_malloc(soap, sizeof(ns1__CategoryPurpose1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CategoryPurpose1Choice *)soap_instantiate_ns1__CategoryPurpose1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CategoryPurpose1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CategoryPurpose1Choice, sizeof(ns1__CategoryPurpose1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CategoryPurpose1Choice(struct soap *soap, ns1__CategoryPurpose1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CategoryPurpose1Choice(soap, tag ? tag : "ns1:CategoryPurpose1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CategoryPurpose1Choice ** SOAP_FMAC4 soap_get_PointerTons1__CategoryPurpose1Choice(struct soap *soap, ns1__CategoryPurpose1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CategoryPurpose1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LocalInstrument2Choice(struct soap *soap, ns1__LocalInstrument2Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LocalInstrument2Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LocalInstrument2Choice(struct soap *soap, const char *tag, int id, ns1__LocalInstrument2Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LocalInstrument2Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LocalInstrument2Choice ? type : NULL);
}

SOAP_FMAC3 ns1__LocalInstrument2Choice ** SOAP_FMAC4 soap_in_PointerTons1__LocalInstrument2Choice(struct soap *soap, const char *tag, ns1__LocalInstrument2Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LocalInstrument2Choice **)soap_malloc(soap, sizeof(ns1__LocalInstrument2Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LocalInstrument2Choice *)soap_instantiate_ns1__LocalInstrument2Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LocalInstrument2Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LocalInstrument2Choice, sizeof(ns1__LocalInstrument2Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LocalInstrument2Choice(struct soap *soap, ns1__LocalInstrument2Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LocalInstrument2Choice(soap, tag ? tag : "ns1:LocalInstrument2Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LocalInstrument2Choice ** SOAP_FMAC4 soap_get_PointerTons1__LocalInstrument2Choice(struct soap *soap, ns1__LocalInstrument2Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LocalInstrument2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServiceLevel8Choice(struct soap *soap, ns1__ServiceLevel8Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServiceLevel8Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServiceLevel8Choice(struct soap *soap, const char *tag, int id, ns1__ServiceLevel8Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServiceLevel8Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ServiceLevel8Choice ? type : NULL);
}

SOAP_FMAC3 ns1__ServiceLevel8Choice ** SOAP_FMAC4 soap_in_PointerTons1__ServiceLevel8Choice(struct soap *soap, const char *tag, ns1__ServiceLevel8Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ServiceLevel8Choice **)soap_malloc(soap, sizeof(ns1__ServiceLevel8Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ServiceLevel8Choice *)soap_instantiate_ns1__ServiceLevel8Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ServiceLevel8Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServiceLevel8Choice, sizeof(ns1__ServiceLevel8Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServiceLevel8Choice(struct soap *soap, ns1__ServiceLevel8Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ServiceLevel8Choice(soap, tag ? tag : "ns1:ServiceLevel8Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ServiceLevel8Choice ** SOAP_FMAC4 soap_get_PointerTons1__ServiceLevel8Choice(struct soap *soap, ns1__ServiceLevel8Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServiceLevel8Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalMandateSetupReason1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code))
		soap_serialize_ns1__ExternalMandateSetupReason1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalMandateSetupReason1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalMandateSetupReason1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalMandateSetupReason1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalMandateSetupReason1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalMandateSetupReason1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalMandateSetupReason1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalMandateSetupReason1Code(soap, tag ? tag : "ns1:ExternalMandateSetupReason1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalMandateSetupReason1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalMandateSetupReason1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalLocalInstrument1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalLocalInstrument1Code))
		soap_serialize_ns1__ExternalLocalInstrument1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalLocalInstrument1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalLocalInstrument1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalLocalInstrument1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalLocalInstrument1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalLocalInstrument1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalLocalInstrument1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalLocalInstrument1Code(soap, tag ? tag : "ns1:ExternalLocalInstrument1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalLocalInstrument1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalLocalInstrument1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalDebtorAgentInstruction1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code))
		soap_serialize_ns1__ExternalDebtorAgentInstruction1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalDebtorAgentInstruction1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalDebtorAgentInstruction1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalDebtorAgentInstruction1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, tag ? tag : "ns1:ExternalDebtorAgentInstruction1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalDebtorAgentInstruction1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalDebtorAgentInstruction1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalCreditorAgentInstruction1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code))
		soap_serialize_ns1__ExternalCreditorAgentInstruction1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalCreditorAgentInstruction1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalCreditorAgentInstruction1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalCreditorAgentInstruction1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, tag ? tag : "ns1:ExternalCreditorAgentInstruction1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalCreditorAgentInstruction1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalCreditorAgentInstruction1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PaymentInitiationSource1(struct soap *soap, ns1__PaymentInitiationSource1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PaymentInitiationSource1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PaymentInitiationSource1(struct soap *soap, const char *tag, int id, ns1__PaymentInitiationSource1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PaymentInitiationSource1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PaymentInitiationSource1 ? type : NULL);
}

SOAP_FMAC3 ns1__PaymentInitiationSource1 ** SOAP_FMAC4 soap_in_PointerTons1__PaymentInitiationSource1(struct soap *soap, const char *tag, ns1__PaymentInitiationSource1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentInitiationSource1 **)soap_malloc(soap, sizeof(ns1__PaymentInitiationSource1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PaymentInitiationSource1 *)soap_instantiate_ns1__PaymentInitiationSource1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PaymentInitiationSource1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PaymentInitiationSource1, sizeof(ns1__PaymentInitiationSource1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PaymentInitiationSource1(struct soap *soap, ns1__PaymentInitiationSource1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PaymentInitiationSource1(soap, tag ? tag : "ns1:PaymentInitiationSource1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentInitiationSource1 ** SOAP_FMAC4 soap_get_PointerTons1__PaymentInitiationSource1(struct soap *soap, ns1__PaymentInitiationSource1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PaymentInitiationSource1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DecimalNumber(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DecimalNumber))
		soap_serialize_ns1__DecimalNumber(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DecimalNumber(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DecimalNumber, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DecimalNumber(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__DecimalNumber(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DecimalNumber(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DecimalNumber, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DecimalNumber(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DecimalNumber(soap, tag ? tag : "ns1:DecimalNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__DecimalNumber(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DecimalNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Authorisation1Choice(struct soap *soap, ns1__Authorisation1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Authorisation1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Authorisation1Choice(struct soap *soap, const char *tag, int id, ns1__Authorisation1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Authorisation1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Authorisation1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__Authorisation1Choice ** SOAP_FMAC4 soap_in_PointerTons1__Authorisation1Choice(struct soap *soap, const char *tag, ns1__Authorisation1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Authorisation1Choice **)soap_malloc(soap, sizeof(ns1__Authorisation1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Authorisation1Choice *)soap_instantiate_ns1__Authorisation1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Authorisation1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Authorisation1Choice, sizeof(ns1__Authorisation1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Authorisation1Choice(struct soap *soap, ns1__Authorisation1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Authorisation1Choice(soap, tag ? tag : "ns1:Authorisation1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Authorisation1Choice ** SOAP_FMAC4 soap_get_PointerTons1__Authorisation1Choice(struct soap *soap, ns1__Authorisation1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Authorisation1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PersonIdentificationSchemeName1Choice(struct soap *soap, ns1__PersonIdentificationSchemeName1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PersonIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, ns1__PersonIdentificationSchemeName1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__PersonIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_in_PointerTons1__PersonIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__PersonIdentificationSchemeName1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PersonIdentificationSchemeName1Choice **)soap_malloc(soap, sizeof(ns1__PersonIdentificationSchemeName1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PersonIdentificationSchemeName1Choice *)soap_instantiate_ns1__PersonIdentificationSchemeName1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PersonIdentificationSchemeName1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice, sizeof(ns1__PersonIdentificationSchemeName1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PersonIdentificationSchemeName1Choice(struct soap *soap, ns1__PersonIdentificationSchemeName1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PersonIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:PersonIdentificationSchemeName1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PersonIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_get_PointerTons1__PersonIdentificationSchemeName1Choice(struct soap *soap, ns1__PersonIdentificationSchemeName1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PersonIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, ns1__OrganisationIdentificationSchemeName1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, ns1__OrganisationIdentificationSchemeName1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__OrganisationIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_in_PointerTons1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__OrganisationIdentificationSchemeName1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrganisationIdentificationSchemeName1Choice **)soap_malloc(soap, sizeof(ns1__OrganisationIdentificationSchemeName1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrganisationIdentificationSchemeName1Choice *)soap_instantiate_ns1__OrganisationIdentificationSchemeName1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OrganisationIdentificationSchemeName1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice, sizeof(ns1__OrganisationIdentificationSchemeName1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, ns1__OrganisationIdentificationSchemeName1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:OrganisationIdentificationSchemeName1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrganisationIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_get_PointerTons1__OrganisationIdentificationSchemeName1Choice(struct soap *soap, ns1__OrganisationIdentificationSchemeName1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrganisationIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FinancialIdentificationSchemeName1Choice(struct soap *soap, ns1__FinancialIdentificationSchemeName1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FinancialIdentificationSchemeName1Choice(struct soap *soap, const char *tag, int id, ns1__FinancialIdentificationSchemeName1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__FinancialIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_in_PointerTons1__FinancialIdentificationSchemeName1Choice(struct soap *soap, const char *tag, ns1__FinancialIdentificationSchemeName1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FinancialIdentificationSchemeName1Choice **)soap_malloc(soap, sizeof(ns1__FinancialIdentificationSchemeName1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FinancialIdentificationSchemeName1Choice *)soap_instantiate_ns1__FinancialIdentificationSchemeName1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FinancialIdentificationSchemeName1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice, sizeof(ns1__FinancialIdentificationSchemeName1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FinancialIdentificationSchemeName1Choice(struct soap *soap, ns1__FinancialIdentificationSchemeName1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, tag ? tag : "ns1:FinancialIdentificationSchemeName1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FinancialIdentificationSchemeName1Choice ** SOAP_FMAC4 soap_get_PointerTons1__FinancialIdentificationSchemeName1Choice(struct soap *soap, ns1__FinancialIdentificationSchemeName1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FinancialIdentificationSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccountSchemeName1Choice(struct soap *soap, ns1__AccountSchemeName1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccountSchemeName1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccountSchemeName1Choice(struct soap *soap, const char *tag, int id, ns1__AccountSchemeName1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccountSchemeName1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AccountSchemeName1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__AccountSchemeName1Choice ** SOAP_FMAC4 soap_in_PointerTons1__AccountSchemeName1Choice(struct soap *soap, const char *tag, ns1__AccountSchemeName1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AccountSchemeName1Choice **)soap_malloc(soap, sizeof(ns1__AccountSchemeName1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AccountSchemeName1Choice *)soap_instantiate_ns1__AccountSchemeName1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AccountSchemeName1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccountSchemeName1Choice, sizeof(ns1__AccountSchemeName1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccountSchemeName1Choice(struct soap *soap, ns1__AccountSchemeName1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AccountSchemeName1Choice(soap, tag ? tag : "ns1:AccountSchemeName1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AccountSchemeName1Choice ** SOAP_FMAC4 soap_get_PointerTons1__AccountSchemeName1Choice(struct soap *soap, ns1__AccountSchemeName1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccountSchemeName1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalGarnishmentType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalGarnishmentType1Code))
		soap_serialize_ns1__ExternalGarnishmentType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalGarnishmentType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalGarnishmentType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalGarnishmentType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalGarnishmentType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalGarnishmentType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalGarnishmentType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalGarnishmentType1Code(soap, tag ? tag : "ns1:ExternalGarnishmentType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalGarnishmentType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalGarnishmentType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GarnishmentType1Choice(struct soap *soap, ns1__GarnishmentType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GarnishmentType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GarnishmentType1Choice(struct soap *soap, const char *tag, int id, ns1__GarnishmentType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GarnishmentType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GarnishmentType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__GarnishmentType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__GarnishmentType1Choice(struct soap *soap, const char *tag, ns1__GarnishmentType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GarnishmentType1Choice **)soap_malloc(soap, sizeof(ns1__GarnishmentType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GarnishmentType1Choice *)soap_instantiate_ns1__GarnishmentType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GarnishmentType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GarnishmentType1Choice, sizeof(ns1__GarnishmentType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GarnishmentType1Choice(struct soap *soap, ns1__GarnishmentType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GarnishmentType1Choice(soap, tag ? tag : "ns1:GarnishmentType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GarnishmentType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__GarnishmentType1Choice(struct soap *soap, ns1__GarnishmentType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GarnishmentType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrueFalseIndicator(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__TrueFalseIndicator);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrueFalseIndicator(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrueFalseIndicator, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TrueFalseIndicator(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTons1__TrueFalseIndicator(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TrueFalseIndicator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrueFalseIndicator, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrueFalseIndicator(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrueFalseIndicator(soap, tag ? tag : "ns1:TrueFalseIndicator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTons1__TrueFalseIndicator(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrueFalseIndicator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GarnishmentType1(struct soap *soap, ns1__GarnishmentType1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GarnishmentType1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GarnishmentType1(struct soap *soap, const char *tag, int id, ns1__GarnishmentType1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GarnishmentType1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GarnishmentType1 ? type : NULL);
}

SOAP_FMAC3 ns1__GarnishmentType1 ** SOAP_FMAC4 soap_in_PointerTons1__GarnishmentType1(struct soap *soap, const char *tag, ns1__GarnishmentType1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GarnishmentType1 **)soap_malloc(soap, sizeof(ns1__GarnishmentType1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GarnishmentType1 *)soap_instantiate_ns1__GarnishmentType1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GarnishmentType1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GarnishmentType1, sizeof(ns1__GarnishmentType1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GarnishmentType1(struct soap *soap, ns1__GarnishmentType1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GarnishmentType1(soap, tag ? tag : "ns1:GarnishmentType1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GarnishmentType1 ** SOAP_FMAC4 soap_get_PointerTons1__GarnishmentType1(struct soap *soap, ns1__GarnishmentType1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GarnishmentType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FrequencyAndMoment1(struct soap *soap, ns1__FrequencyAndMoment1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FrequencyAndMoment1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FrequencyAndMoment1(struct soap *soap, const char *tag, int id, ns1__FrequencyAndMoment1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FrequencyAndMoment1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FrequencyAndMoment1 ? type : NULL);
}

SOAP_FMAC3 ns1__FrequencyAndMoment1 ** SOAP_FMAC4 soap_in_PointerTons1__FrequencyAndMoment1(struct soap *soap, const char *tag, ns1__FrequencyAndMoment1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FrequencyAndMoment1 **)soap_malloc(soap, sizeof(ns1__FrequencyAndMoment1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FrequencyAndMoment1 *)soap_instantiate_ns1__FrequencyAndMoment1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FrequencyAndMoment1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FrequencyAndMoment1, sizeof(ns1__FrequencyAndMoment1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FrequencyAndMoment1(struct soap *soap, ns1__FrequencyAndMoment1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FrequencyAndMoment1(soap, tag ? tag : "ns1:FrequencyAndMoment1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FrequencyAndMoment1 ** SOAP_FMAC4 soap_get_PointerTons1__FrequencyAndMoment1(struct soap *soap, ns1__FrequencyAndMoment1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FrequencyAndMoment1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FrequencyPeriod1(struct soap *soap, ns1__FrequencyPeriod1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FrequencyPeriod1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FrequencyPeriod1(struct soap *soap, const char *tag, int id, ns1__FrequencyPeriod1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FrequencyPeriod1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FrequencyPeriod1 ? type : NULL);
}

SOAP_FMAC3 ns1__FrequencyPeriod1 ** SOAP_FMAC4 soap_in_PointerTons1__FrequencyPeriod1(struct soap *soap, const char *tag, ns1__FrequencyPeriod1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FrequencyPeriod1 **)soap_malloc(soap, sizeof(ns1__FrequencyPeriod1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FrequencyPeriod1 *)soap_instantiate_ns1__FrequencyPeriod1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FrequencyPeriod1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FrequencyPeriod1, sizeof(ns1__FrequencyPeriod1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FrequencyPeriod1(struct soap *soap, ns1__FrequencyPeriod1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FrequencyPeriod1(soap, tag ? tag : "ns1:FrequencyPeriod1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FrequencyPeriod1 ** SOAP_FMAC4 soap_get_PointerTons1__FrequencyPeriod1(struct soap *soap, ns1__FrequencyPeriod1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FrequencyPeriod1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericFinancialIdentification1(struct soap *soap, ns1__GenericFinancialIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericFinancialIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericFinancialIdentification1(struct soap *soap, const char *tag, int id, ns1__GenericFinancialIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericFinancialIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericFinancialIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__GenericFinancialIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__GenericFinancialIdentification1(struct soap *soap, const char *tag, ns1__GenericFinancialIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericFinancialIdentification1 **)soap_malloc(soap, sizeof(ns1__GenericFinancialIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericFinancialIdentification1 *)soap_instantiate_ns1__GenericFinancialIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericFinancialIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericFinancialIdentification1, sizeof(ns1__GenericFinancialIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericFinancialIdentification1(struct soap *soap, ns1__GenericFinancialIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericFinancialIdentification1(soap, tag ? tag : "ns1:GenericFinancialIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericFinancialIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__GenericFinancialIdentification1(struct soap *soap, ns1__GenericFinancialIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericFinancialIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClearingSystemMemberIdentification2(struct soap *soap, ns1__ClearingSystemMemberIdentification2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClearingSystemMemberIdentification2(struct soap *soap, const char *tag, int id, ns1__ClearingSystemMemberIdentification2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ClearingSystemMemberIdentification2 ? type : NULL);
}

SOAP_FMAC3 ns1__ClearingSystemMemberIdentification2 ** SOAP_FMAC4 soap_in_PointerTons1__ClearingSystemMemberIdentification2(struct soap *soap, const char *tag, ns1__ClearingSystemMemberIdentification2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ClearingSystemMemberIdentification2 **)soap_malloc(soap, sizeof(ns1__ClearingSystemMemberIdentification2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ClearingSystemMemberIdentification2 *)soap_instantiate_ns1__ClearingSystemMemberIdentification2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ClearingSystemMemberIdentification2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClearingSystemMemberIdentification2, sizeof(ns1__ClearingSystemMemberIdentification2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClearingSystemMemberIdentification2(struct soap *soap, ns1__ClearingSystemMemberIdentification2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ClearingSystemMemberIdentification2(soap, tag ? tag : "ns1:ClearingSystemMemberIdentification2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ClearingSystemMemberIdentification2 ** SOAP_FMAC4 soap_get_PointerTons1__ClearingSystemMemberIdentification2(struct soap *soap, ns1__ClearingSystemMemberIdentification2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ClearingSystemMemberIdentification2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BICFIDec2014Identifier(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BICFIDec2014Identifier))
		soap_serialize_ns1__BICFIDec2014Identifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BICFIDec2014Identifier(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BICFIDec2014Identifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BICFIDec2014Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__BICFIDec2014Identifier(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BICFIDec2014Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BICFIDec2014Identifier, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BICFIDec2014Identifier(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BICFIDec2014Identifier(soap, tag ? tag : "ns1:BICFIDec2014Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__BICFIDec2014Identifier(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BICFIDec2014Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code))
		soap_serialize_ns1__ExternalFinancialInstitutionIdentification1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalFinancialInstitutionIdentification1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, tag ? tag : "ns1:ExternalFinancialInstitutionIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalFinancialInstitutionIdentification1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalFinancialInstitutionIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExchangeRateType1Code(struct soap *soap, enum ns1__ExchangeRateType1Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ExchangeRateType1Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExchangeRateType1Code(struct soap *soap, const char *tag, int id, enum ns1__ExchangeRateType1Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExchangeRateType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExchangeRateType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ExchangeRateType1Code ** SOAP_FMAC4 soap_in_PointerTons1__ExchangeRateType1Code(struct soap *soap, const char *tag, enum ns1__ExchangeRateType1Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ExchangeRateType1Code **)soap_malloc(soap, sizeof(enum ns1__ExchangeRateType1Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExchangeRateType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ExchangeRateType1Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExchangeRateType1Code, sizeof(enum ns1__ExchangeRateType1Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExchangeRateType1Code(struct soap *soap, enum ns1__ExchangeRateType1Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExchangeRateType1Code(soap, tag ? tag : "ns1:ExchangeRateType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ExchangeRateType1Code ** SOAP_FMAC4 soap_get_PointerTons1__ExchangeRateType1Code(struct soap *soap, enum ns1__ExchangeRateType1Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExchangeRateType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BaseOneRate(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BaseOneRate))
		soap_serialize_ns1__BaseOneRate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BaseOneRate(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BaseOneRate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BaseOneRate(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__BaseOneRate(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BaseOneRate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BaseOneRate, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BaseOneRate(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BaseOneRate(soap, tag ? tag : "ns1:BaseOneRate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__BaseOneRate(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BaseOneRate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalDocumentLineType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalDocumentLineType1Code))
		soap_serialize_ns1__ExternalDocumentLineType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalDocumentLineType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalDocumentLineType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalDocumentLineType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalDocumentLineType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalDocumentLineType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalDocumentLineType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalDocumentLineType1Code(soap, tag ? tag : "ns1:ExternalDocumentLineType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalDocumentLineType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalDocumentLineType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentLineType1Choice(struct soap *soap, ns1__DocumentLineType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentLineType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentLineType1Choice(struct soap *soap, const char *tag, int id, ns1__DocumentLineType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentLineType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DocumentLineType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__DocumentLineType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__DocumentLineType1Choice(struct soap *soap, const char *tag, ns1__DocumentLineType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DocumentLineType1Choice **)soap_malloc(soap, sizeof(ns1__DocumentLineType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DocumentLineType1Choice *)soap_instantiate_ns1__DocumentLineType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentLineType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentLineType1Choice, sizeof(ns1__DocumentLineType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentLineType1Choice(struct soap *soap, ns1__DocumentLineType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DocumentLineType1Choice(soap, tag ? tag : "ns1:DocumentLineType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DocumentLineType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__DocumentLineType1Choice(struct soap *soap, ns1__DocumentLineType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentLineType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemittanceAmount3(struct soap *soap, ns1__RemittanceAmount3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemittanceAmount3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemittanceAmount3(struct soap *soap, const char *tag, int id, ns1__RemittanceAmount3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemittanceAmount3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RemittanceAmount3 ? type : NULL);
}

SOAP_FMAC3 ns1__RemittanceAmount3 ** SOAP_FMAC4 soap_in_PointerTons1__RemittanceAmount3(struct soap *soap, const char *tag, ns1__RemittanceAmount3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemittanceAmount3 **)soap_malloc(soap, sizeof(ns1__RemittanceAmount3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemittanceAmount3 *)soap_instantiate_ns1__RemittanceAmount3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RemittanceAmount3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemittanceAmount3, sizeof(ns1__RemittanceAmount3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemittanceAmount3(struct soap *soap, ns1__RemittanceAmount3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RemittanceAmount3(soap, tag ? tag : "ns1:RemittanceAmount3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RemittanceAmount3 ** SOAP_FMAC4 soap_get_PointerTons1__RemittanceAmount3(struct soap *soap, ns1__RemittanceAmount3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemittanceAmount3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentLineIdentification1(struct soap *soap, ns1__DocumentLineIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentLineIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentLineIdentification1(struct soap *soap, const char *tag, int id, ns1__DocumentLineIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentLineIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DocumentLineIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__DocumentLineIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__DocumentLineIdentification1(struct soap *soap, const char *tag, ns1__DocumentLineIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DocumentLineIdentification1 **)soap_malloc(soap, sizeof(ns1__DocumentLineIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DocumentLineIdentification1 *)soap_instantiate_ns1__DocumentLineIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentLineIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentLineIdentification1, sizeof(ns1__DocumentLineIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentLineIdentification1(struct soap *soap, ns1__DocumentLineIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DocumentLineIdentification1(soap, tag ? tag : "ns1:DocumentLineIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DocumentLineIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__DocumentLineIdentification1(struct soap *soap, ns1__DocumentLineIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentLineIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentLineType1(struct soap *soap, ns1__DocumentLineType1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentLineType1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentLineType1(struct soap *soap, const char *tag, int id, ns1__DocumentLineType1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentLineType1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DocumentLineType1 ? type : NULL);
}

SOAP_FMAC3 ns1__DocumentLineType1 ** SOAP_FMAC4 soap_in_PointerTons1__DocumentLineType1(struct soap *soap, const char *tag, ns1__DocumentLineType1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DocumentLineType1 **)soap_malloc(soap, sizeof(ns1__DocumentLineType1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DocumentLineType1 *)soap_instantiate_ns1__DocumentLineType1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentLineType1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentLineType1, sizeof(ns1__DocumentLineType1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentLineType1(struct soap *soap, ns1__DocumentLineType1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DocumentLineType1(soap, tag ? tag : "ns1:DocumentLineType1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DocumentLineType1 ** SOAP_FMAC4 soap_get_PointerTons1__DocumentLineType1(struct soap *soap, ns1__DocumentLineType1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentLineType1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max4Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max4Text))
		soap_serialize_ns1__Max4Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max4Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max4Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max4Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max4Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max4Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max4Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max4Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max4Text(soap, tag ? tag : "ns1:Max4Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max4Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max4Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditDebitCode(struct soap *soap, enum ns1__CreditDebitCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__CreditDebitCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditDebitCode(struct soap *soap, const char *tag, int id, enum ns1__CreditDebitCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditDebitCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CreditDebitCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__CreditDebitCode ** SOAP_FMAC4 soap_in_PointerTons1__CreditDebitCode(struct soap *soap, const char *tag, enum ns1__CreditDebitCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__CreditDebitCode **)soap_malloc(soap, sizeof(enum ns1__CreditDebitCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CreditDebitCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__CreditDebitCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditDebitCode, sizeof(enum ns1__CreditDebitCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditDebitCode(struct soap *soap, enum ns1__CreditDebitCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditDebitCode(soap, tag ? tag : "ns1:CreditDebitCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CreditDebitCode ** SOAP_FMAC4 soap_get_PointerTons1__CreditDebitCode(struct soap *soap, enum ns1__CreditDebitCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditDebitCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomerCreditTransferInitiationV11(struct soap *soap, ns1__CustomerCreditTransferInitiationV11 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomerCreditTransferInitiationV11(struct soap *soap, const char *tag, int id, ns1__CustomerCreditTransferInitiationV11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11 ? type : NULL);
}

SOAP_FMAC3 ns1__CustomerCreditTransferInitiationV11 ** SOAP_FMAC4 soap_in_PointerTons1__CustomerCreditTransferInitiationV11(struct soap *soap, const char *tag, ns1__CustomerCreditTransferInitiationV11 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CustomerCreditTransferInitiationV11 **)soap_malloc(soap, sizeof(ns1__CustomerCreditTransferInitiationV11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CustomerCreditTransferInitiationV11 *)soap_instantiate_ns1__CustomerCreditTransferInitiationV11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CustomerCreditTransferInitiationV11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11, sizeof(ns1__CustomerCreditTransferInitiationV11), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomerCreditTransferInitiationV11(struct soap *soap, ns1__CustomerCreditTransferInitiationV11 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CustomerCreditTransferInitiationV11(soap, tag ? tag : "ns1:CustomerCreditTransferInitiationV11", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CustomerCreditTransferInitiationV11 ** SOAP_FMAC4 soap_get_PointerTons1__CustomerCreditTransferInitiationV11(struct soap *soap, ns1__CustomerCreditTransferInitiationV11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomerCreditTransferInitiationV11(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalDiscountAmountType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code))
		soap_serialize_ns1__ExternalDiscountAmountType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalDiscountAmountType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalDiscountAmountType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalDiscountAmountType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalDiscountAmountType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalDiscountAmountType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalDiscountAmountType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalDiscountAmountType1Code(soap, tag ? tag : "ns1:ExternalDiscountAmountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalDiscountAmountType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalDiscountAmountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DiscountAmountType1Choice(struct soap *soap, ns1__DiscountAmountType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DiscountAmountType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DiscountAmountType1Choice(struct soap *soap, const char *tag, int id, ns1__DiscountAmountType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DiscountAmountType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DiscountAmountType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__DiscountAmountType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__DiscountAmountType1Choice(struct soap *soap, const char *tag, ns1__DiscountAmountType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DiscountAmountType1Choice **)soap_malloc(soap, sizeof(ns1__DiscountAmountType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DiscountAmountType1Choice *)soap_instantiate_ns1__DiscountAmountType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DiscountAmountType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DiscountAmountType1Choice, sizeof(ns1__DiscountAmountType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DiscountAmountType1Choice(struct soap *soap, ns1__DiscountAmountType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DiscountAmountType1Choice(soap, tag ? tag : "ns1:DiscountAmountType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DiscountAmountType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__DiscountAmountType1Choice(struct soap *soap, ns1__DiscountAmountType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DiscountAmountType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PaymentInstruction40(struct soap *soap, ns1__PaymentInstruction40 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PaymentInstruction40))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PaymentInstruction40(struct soap *soap, const char *tag, int id, ns1__PaymentInstruction40 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PaymentInstruction40, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PaymentInstruction40 ? type : NULL);
}

SOAP_FMAC3 ns1__PaymentInstruction40 ** SOAP_FMAC4 soap_in_PointerTons1__PaymentInstruction40(struct soap *soap, const char *tag, ns1__PaymentInstruction40 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentInstruction40 **)soap_malloc(soap, sizeof(ns1__PaymentInstruction40 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PaymentInstruction40 *)soap_instantiate_ns1__PaymentInstruction40(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PaymentInstruction40 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PaymentInstruction40, sizeof(ns1__PaymentInstruction40), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PaymentInstruction40(struct soap *soap, ns1__PaymentInstruction40 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PaymentInstruction40(soap, tag ? tag : "ns1:PaymentInstruction40", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentInstruction40 ** SOAP_FMAC4 soap_get_PointerTons1__PaymentInstruction40(struct soap *soap, ns1__PaymentInstruction40 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PaymentInstruction40(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GroupHeader95(struct soap *soap, ns1__GroupHeader95 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GroupHeader95))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GroupHeader95(struct soap *soap, const char *tag, int id, ns1__GroupHeader95 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GroupHeader95, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GroupHeader95 ? type : NULL);
}

SOAP_FMAC3 ns1__GroupHeader95 ** SOAP_FMAC4 soap_in_PointerTons1__GroupHeader95(struct soap *soap, const char *tag, ns1__GroupHeader95 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GroupHeader95 **)soap_malloc(soap, sizeof(ns1__GroupHeader95 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GroupHeader95 *)soap_instantiate_ns1__GroupHeader95(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GroupHeader95 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GroupHeader95, sizeof(ns1__GroupHeader95), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GroupHeader95(struct soap *soap, ns1__GroupHeader95 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GroupHeader95(soap, tag ? tag : "ns1:GroupHeader95", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GroupHeader95 ** SOAP_FMAC4 soap_get_PointerTons1__GroupHeader95(struct soap *soap, ns1__GroupHeader95 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GroupHeader95(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditorReferenceType1Choice(struct soap *soap, ns1__CreditorReferenceType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreditorReferenceType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditorReferenceType1Choice(struct soap *soap, const char *tag, int id, ns1__CreditorReferenceType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditorReferenceType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CreditorReferenceType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__CreditorReferenceType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__CreditorReferenceType1Choice(struct soap *soap, const char *tag, ns1__CreditorReferenceType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreditorReferenceType1Choice **)soap_malloc(soap, sizeof(ns1__CreditorReferenceType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreditorReferenceType1Choice *)soap_instantiate_ns1__CreditorReferenceType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CreditorReferenceType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditorReferenceType1Choice, sizeof(ns1__CreditorReferenceType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditorReferenceType1Choice(struct soap *soap, ns1__CreditorReferenceType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditorReferenceType1Choice(soap, tag ? tag : "ns1:CreditorReferenceType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreditorReferenceType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__CreditorReferenceType1Choice(struct soap *soap, ns1__CreditorReferenceType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditorReferenceType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditorReferenceType2(struct soap *soap, ns1__CreditorReferenceType2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreditorReferenceType2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditorReferenceType2(struct soap *soap, const char *tag, int id, ns1__CreditorReferenceType2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditorReferenceType2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CreditorReferenceType2 ? type : NULL);
}

SOAP_FMAC3 ns1__CreditorReferenceType2 ** SOAP_FMAC4 soap_in_PointerTons1__CreditorReferenceType2(struct soap *soap, const char *tag, ns1__CreditorReferenceType2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreditorReferenceType2 **)soap_malloc(soap, sizeof(ns1__CreditorReferenceType2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreditorReferenceType2 *)soap_instantiate_ns1__CreditorReferenceType2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CreditorReferenceType2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditorReferenceType2, sizeof(ns1__CreditorReferenceType2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditorReferenceType2(struct soap *soap, ns1__CreditorReferenceType2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditorReferenceType2(soap, tag ? tag : "ns1:CreditorReferenceType2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreditorReferenceType2 ** SOAP_FMAC4 soap_get_PointerTons1__CreditorReferenceType2(struct soap *soap, ns1__CreditorReferenceType2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditorReferenceType2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SupplementaryData1(struct soap *soap, ns1__SupplementaryData1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SupplementaryData1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SupplementaryData1(struct soap *soap, const char *tag, int id, ns1__SupplementaryData1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SupplementaryData1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SupplementaryData1 ? type : NULL);
}

SOAP_FMAC3 ns1__SupplementaryData1 ** SOAP_FMAC4 soap_in_PointerTons1__SupplementaryData1(struct soap *soap, const char *tag, ns1__SupplementaryData1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SupplementaryData1 **)soap_malloc(soap, sizeof(ns1__SupplementaryData1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SupplementaryData1 *)soap_instantiate_ns1__SupplementaryData1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SupplementaryData1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupplementaryData1, sizeof(ns1__SupplementaryData1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SupplementaryData1(struct soap *soap, ns1__SupplementaryData1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SupplementaryData1(soap, tag ? tag : "ns1:SupplementaryData1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SupplementaryData1 ** SOAP_FMAC4 soap_get_PointerTons1__SupplementaryData1(struct soap *soap, ns1__SupplementaryData1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SupplementaryData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemittanceInformation21(struct soap *soap, ns1__RemittanceInformation21 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemittanceInformation21))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemittanceInformation21(struct soap *soap, const char *tag, int id, ns1__RemittanceInformation21 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemittanceInformation21, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RemittanceInformation21 ? type : NULL);
}

SOAP_FMAC3 ns1__RemittanceInformation21 ** SOAP_FMAC4 soap_in_PointerTons1__RemittanceInformation21(struct soap *soap, const char *tag, ns1__RemittanceInformation21 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemittanceInformation21 **)soap_malloc(soap, sizeof(ns1__RemittanceInformation21 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemittanceInformation21 *)soap_instantiate_ns1__RemittanceInformation21(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RemittanceInformation21 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemittanceInformation21, sizeof(ns1__RemittanceInformation21), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemittanceInformation21(struct soap *soap, ns1__RemittanceInformation21 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RemittanceInformation21(soap, tag ? tag : "ns1:RemittanceInformation21", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RemittanceInformation21 ** SOAP_FMAC4 soap_get_PointerTons1__RemittanceInformation21(struct soap *soap, ns1__RemittanceInformation21 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemittanceInformation21(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemittanceLocation7(struct soap *soap, ns1__RemittanceLocation7 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemittanceLocation7))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemittanceLocation7(struct soap *soap, const char *tag, int id, ns1__RemittanceLocation7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemittanceLocation7, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RemittanceLocation7 ? type : NULL);
}

SOAP_FMAC3 ns1__RemittanceLocation7 ** SOAP_FMAC4 soap_in_PointerTons1__RemittanceLocation7(struct soap *soap, const char *tag, ns1__RemittanceLocation7 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemittanceLocation7 **)soap_malloc(soap, sizeof(ns1__RemittanceLocation7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemittanceLocation7 *)soap_instantiate_ns1__RemittanceLocation7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RemittanceLocation7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemittanceLocation7, sizeof(ns1__RemittanceLocation7), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemittanceLocation7(struct soap *soap, ns1__RemittanceLocation7 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RemittanceLocation7(soap, tag ? tag : "ns1:RemittanceLocation7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RemittanceLocation7 ** SOAP_FMAC4 soap_get_PointerTons1__RemittanceLocation7(struct soap *soap, ns1__RemittanceLocation7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemittanceLocation7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaxInformation10(struct soap *soap, ns1__TaxInformation10 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaxInformation10))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaxInformation10(struct soap *soap, const char *tag, int id, ns1__TaxInformation10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaxInformation10, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TaxInformation10 ? type : NULL);
}

SOAP_FMAC3 ns1__TaxInformation10 ** SOAP_FMAC4 soap_in_PointerTons1__TaxInformation10(struct soap *soap, const char *tag, ns1__TaxInformation10 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaxInformation10 **)soap_malloc(soap, sizeof(ns1__TaxInformation10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaxInformation10 *)soap_instantiate_ns1__TaxInformation10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TaxInformation10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaxInformation10, sizeof(ns1__TaxInformation10), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaxInformation10(struct soap *soap, ns1__TaxInformation10 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TaxInformation10(soap, tag ? tag : "ns1:TaxInformation10", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaxInformation10 ** SOAP_FMAC4 soap_get_PointerTons1__TaxInformation10(struct soap *soap, ns1__TaxInformation10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaxInformation10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegulatoryReporting3(struct soap *soap, ns1__RegulatoryReporting3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RegulatoryReporting3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegulatoryReporting3(struct soap *soap, const char *tag, int id, ns1__RegulatoryReporting3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegulatoryReporting3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RegulatoryReporting3 ? type : NULL);
}

SOAP_FMAC3 ns1__RegulatoryReporting3 ** SOAP_FMAC4 soap_in_PointerTons1__RegulatoryReporting3(struct soap *soap, const char *tag, ns1__RegulatoryReporting3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegulatoryReporting3 **)soap_malloc(soap, sizeof(ns1__RegulatoryReporting3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RegulatoryReporting3 *)soap_instantiate_ns1__RegulatoryReporting3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RegulatoryReporting3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegulatoryReporting3, sizeof(ns1__RegulatoryReporting3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegulatoryReporting3(struct soap *soap, ns1__RegulatoryReporting3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RegulatoryReporting3(soap, tag ? tag : "ns1:RegulatoryReporting3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RegulatoryReporting3 ** SOAP_FMAC4 soap_get_PointerTons1__RegulatoryReporting3(struct soap *soap, ns1__RegulatoryReporting3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegulatoryReporting3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Purpose2Choice(struct soap *soap, ns1__Purpose2Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Purpose2Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Purpose2Choice(struct soap *soap, const char *tag, int id, ns1__Purpose2Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Purpose2Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Purpose2Choice ? type : NULL);
}

SOAP_FMAC3 ns1__Purpose2Choice ** SOAP_FMAC4 soap_in_PointerTons1__Purpose2Choice(struct soap *soap, const char *tag, ns1__Purpose2Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Purpose2Choice **)soap_malloc(soap, sizeof(ns1__Purpose2Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Purpose2Choice *)soap_instantiate_ns1__Purpose2Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Purpose2Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Purpose2Choice, sizeof(ns1__Purpose2Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Purpose2Choice(struct soap *soap, ns1__Purpose2Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Purpose2Choice(soap, tag ? tag : "ns1:Purpose2Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Purpose2Choice ** SOAP_FMAC4 soap_get_PointerTons1__Purpose2Choice(struct soap *soap, ns1__Purpose2Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Purpose2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InstructionForDebtorAgent1(struct soap *soap, ns1__InstructionForDebtorAgent1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InstructionForDebtorAgent1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InstructionForDebtorAgent1(struct soap *soap, const char *tag, int id, ns1__InstructionForDebtorAgent1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InstructionForDebtorAgent1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InstructionForDebtorAgent1 ? type : NULL);
}

SOAP_FMAC3 ns1__InstructionForDebtorAgent1 ** SOAP_FMAC4 soap_in_PointerTons1__InstructionForDebtorAgent1(struct soap *soap, const char *tag, ns1__InstructionForDebtorAgent1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InstructionForDebtorAgent1 **)soap_malloc(soap, sizeof(ns1__InstructionForDebtorAgent1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InstructionForDebtorAgent1 *)soap_instantiate_ns1__InstructionForDebtorAgent1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InstructionForDebtorAgent1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InstructionForDebtorAgent1, sizeof(ns1__InstructionForDebtorAgent1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InstructionForDebtorAgent1(struct soap *soap, ns1__InstructionForDebtorAgent1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InstructionForDebtorAgent1(soap, tag ? tag : "ns1:InstructionForDebtorAgent1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InstructionForDebtorAgent1 ** SOAP_FMAC4 soap_get_PointerTons1__InstructionForDebtorAgent1(struct soap *soap, ns1__InstructionForDebtorAgent1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InstructionForDebtorAgent1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InstructionForCreditorAgent3(struct soap *soap, ns1__InstructionForCreditorAgent3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InstructionForCreditorAgent3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, int id, ns1__InstructionForCreditorAgent3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InstructionForCreditorAgent3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InstructionForCreditorAgent3 ? type : NULL);
}

SOAP_FMAC3 ns1__InstructionForCreditorAgent3 ** SOAP_FMAC4 soap_in_PointerTons1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, ns1__InstructionForCreditorAgent3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InstructionForCreditorAgent3 **)soap_malloc(soap, sizeof(ns1__InstructionForCreditorAgent3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InstructionForCreditorAgent3 *)soap_instantiate_ns1__InstructionForCreditorAgent3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InstructionForCreditorAgent3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InstructionForCreditorAgent3, sizeof(ns1__InstructionForCreditorAgent3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InstructionForCreditorAgent3(struct soap *soap, ns1__InstructionForCreditorAgent3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InstructionForCreditorAgent3(soap, tag ? tag : "ns1:InstructionForCreditorAgent3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InstructionForCreditorAgent3 ** SOAP_FMAC4 soap_get_PointerTons1__InstructionForCreditorAgent3(struct soap *soap, ns1__InstructionForCreditorAgent3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InstructionForCreditorAgent3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CashAccount40(struct soap *soap, ns1__CashAccount40 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CashAccount40))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CashAccount40(struct soap *soap, const char *tag, int id, ns1__CashAccount40 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CashAccount40, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CashAccount40 ? type : NULL);
}

SOAP_FMAC3 ns1__CashAccount40 ** SOAP_FMAC4 soap_in_PointerTons1__CashAccount40(struct soap *soap, const char *tag, ns1__CashAccount40 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CashAccount40 **)soap_malloc(soap, sizeof(ns1__CashAccount40 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CashAccount40 *)soap_instantiate_ns1__CashAccount40(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CashAccount40 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CashAccount40, sizeof(ns1__CashAccount40), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CashAccount40(struct soap *soap, ns1__CashAccount40 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CashAccount40(soap, tag ? tag : "ns1:CashAccount40", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CashAccount40 ** SOAP_FMAC4 soap_get_PointerTons1__CashAccount40(struct soap *soap, ns1__CashAccount40 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CashAccount40(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, ns1__BranchAndFinancialInstitutionIdentification6 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, const char *tag, int id, ns1__BranchAndFinancialInstitutionIdentification6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6 ? type : NULL);
}

SOAP_FMAC3 ns1__BranchAndFinancialInstitutionIdentification6 ** SOAP_FMAC4 soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, const char *tag, ns1__BranchAndFinancialInstitutionIdentification6 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BranchAndFinancialInstitutionIdentification6 **)soap_malloc(soap, sizeof(ns1__BranchAndFinancialInstitutionIdentification6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BranchAndFinancialInstitutionIdentification6 *)soap_instantiate_ns1__BranchAndFinancialInstitutionIdentification6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BranchAndFinancialInstitutionIdentification6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6, sizeof(ns1__BranchAndFinancialInstitutionIdentification6), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, ns1__BranchAndFinancialInstitutionIdentification6 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, tag ? tag : "ns1:BranchAndFinancialInstitutionIdentification6", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BranchAndFinancialInstitutionIdentification6 ** SOAP_FMAC4 soap_get_PointerTons1__BranchAndFinancialInstitutionIdentification6(struct soap *soap, ns1__BranchAndFinancialInstitutionIdentification6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BranchAndFinancialInstitutionIdentification6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PartyIdentification135(struct soap *soap, ns1__PartyIdentification135 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PartyIdentification135))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PartyIdentification135(struct soap *soap, const char *tag, int id, ns1__PartyIdentification135 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PartyIdentification135, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PartyIdentification135 ? type : NULL);
}

SOAP_FMAC3 ns1__PartyIdentification135 ** SOAP_FMAC4 soap_in_PointerTons1__PartyIdentification135(struct soap *soap, const char *tag, ns1__PartyIdentification135 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PartyIdentification135 **)soap_malloc(soap, sizeof(ns1__PartyIdentification135 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PartyIdentification135 *)soap_instantiate_ns1__PartyIdentification135(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PartyIdentification135 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PartyIdentification135, sizeof(ns1__PartyIdentification135), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PartyIdentification135(struct soap *soap, ns1__PartyIdentification135 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PartyIdentification135(soap, tag ? tag : "ns1:PartyIdentification135", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PartyIdentification135 ** SOAP_FMAC4 soap_get_PointerTons1__PartyIdentification135(struct soap *soap, ns1__PartyIdentification135 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PartyIdentification135(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Cheque11(struct soap *soap, ns1__Cheque11 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Cheque11))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Cheque11(struct soap *soap, const char *tag, int id, ns1__Cheque11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Cheque11, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Cheque11 ? type : NULL);
}

SOAP_FMAC3 ns1__Cheque11 ** SOAP_FMAC4 soap_in_PointerTons1__Cheque11(struct soap *soap, const char *tag, ns1__Cheque11 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Cheque11 **)soap_malloc(soap, sizeof(ns1__Cheque11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Cheque11 *)soap_instantiate_ns1__Cheque11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Cheque11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Cheque11, sizeof(ns1__Cheque11), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Cheque11(struct soap *soap, ns1__Cheque11 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Cheque11(soap, tag ? tag : "ns1:Cheque11", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Cheque11 ** SOAP_FMAC4 soap_get_PointerTons1__Cheque11(struct soap *soap, ns1__Cheque11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Cheque11(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreditTransferMandateData1(struct soap *soap, ns1__CreditTransferMandateData1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreditTransferMandateData1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreditTransferMandateData1(struct soap *soap, const char *tag, int id, ns1__CreditTransferMandateData1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreditTransferMandateData1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CreditTransferMandateData1 ? type : NULL);
}

SOAP_FMAC3 ns1__CreditTransferMandateData1 ** SOAP_FMAC4 soap_in_PointerTons1__CreditTransferMandateData1(struct soap *soap, const char *tag, ns1__CreditTransferMandateData1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreditTransferMandateData1 **)soap_malloc(soap, sizeof(ns1__CreditTransferMandateData1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreditTransferMandateData1 *)soap_instantiate_ns1__CreditTransferMandateData1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CreditTransferMandateData1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreditTransferMandateData1, sizeof(ns1__CreditTransferMandateData1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreditTransferMandateData1(struct soap *soap, ns1__CreditTransferMandateData1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CreditTransferMandateData1(soap, tag ? tag : "ns1:CreditTransferMandateData1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreditTransferMandateData1 ** SOAP_FMAC4 soap_get_PointerTons1__CreditTransferMandateData1(struct soap *soap, ns1__CreditTransferMandateData1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreditTransferMandateData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChargeBearerType1Code(struct soap *soap, enum ns1__ChargeBearerType1Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ChargeBearerType1Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChargeBearerType1Code(struct soap *soap, const char *tag, int id, enum ns1__ChargeBearerType1Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChargeBearerType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChargeBearerType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ChargeBearerType1Code ** SOAP_FMAC4 soap_in_PointerTons1__ChargeBearerType1Code(struct soap *soap, const char *tag, enum ns1__ChargeBearerType1Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ChargeBearerType1Code **)soap_malloc(soap, sizeof(enum ns1__ChargeBearerType1Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChargeBearerType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ChargeBearerType1Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChargeBearerType1Code, sizeof(enum ns1__ChargeBearerType1Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChargeBearerType1Code(struct soap *soap, enum ns1__ChargeBearerType1Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ChargeBearerType1Code(soap, tag ? tag : "ns1:ChargeBearerType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ChargeBearerType1Code ** SOAP_FMAC4 soap_get_PointerTons1__ChargeBearerType1Code(struct soap *soap, enum ns1__ChargeBearerType1Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChargeBearerType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExchangeRate1(struct soap *soap, ns1__ExchangeRate1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExchangeRate1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExchangeRate1(struct soap *soap, const char *tag, int id, ns1__ExchangeRate1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExchangeRate1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ExchangeRate1 ? type : NULL);
}

SOAP_FMAC3 ns1__ExchangeRate1 ** SOAP_FMAC4 soap_in_PointerTons1__ExchangeRate1(struct soap *soap, const char *tag, ns1__ExchangeRate1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ExchangeRate1 **)soap_malloc(soap, sizeof(ns1__ExchangeRate1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ExchangeRate1 *)soap_instantiate_ns1__ExchangeRate1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ExchangeRate1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExchangeRate1, sizeof(ns1__ExchangeRate1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExchangeRate1(struct soap *soap, ns1__ExchangeRate1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExchangeRate1(soap, tag ? tag : "ns1:ExchangeRate1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ExchangeRate1 ** SOAP_FMAC4 soap_get_PointerTons1__ExchangeRate1(struct soap *soap, ns1__ExchangeRate1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExchangeRate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AmountType4Choice(struct soap *soap, ns1__AmountType4Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AmountType4Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AmountType4Choice(struct soap *soap, const char *tag, int id, ns1__AmountType4Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AmountType4Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AmountType4Choice ? type : NULL);
}

SOAP_FMAC3 ns1__AmountType4Choice ** SOAP_FMAC4 soap_in_PointerTons1__AmountType4Choice(struct soap *soap, const char *tag, ns1__AmountType4Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AmountType4Choice **)soap_malloc(soap, sizeof(ns1__AmountType4Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AmountType4Choice *)soap_instantiate_ns1__AmountType4Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AmountType4Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AmountType4Choice, sizeof(ns1__AmountType4Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AmountType4Choice(struct soap *soap, ns1__AmountType4Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AmountType4Choice(soap, tag ? tag : "ns1:AmountType4Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AmountType4Choice ** SOAP_FMAC4 soap_get_PointerTons1__AmountType4Choice(struct soap *soap, ns1__AmountType4Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AmountType4Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PaymentTypeInformation26(struct soap *soap, ns1__PaymentTypeInformation26 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PaymentTypeInformation26))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PaymentTypeInformation26(struct soap *soap, const char *tag, int id, ns1__PaymentTypeInformation26 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PaymentTypeInformation26, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PaymentTypeInformation26 ? type : NULL);
}

SOAP_FMAC3 ns1__PaymentTypeInformation26 ** SOAP_FMAC4 soap_in_PointerTons1__PaymentTypeInformation26(struct soap *soap, const char *tag, ns1__PaymentTypeInformation26 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentTypeInformation26 **)soap_malloc(soap, sizeof(ns1__PaymentTypeInformation26 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PaymentTypeInformation26 *)soap_instantiate_ns1__PaymentTypeInformation26(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PaymentTypeInformation26 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PaymentTypeInformation26, sizeof(ns1__PaymentTypeInformation26), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PaymentTypeInformation26(struct soap *soap, ns1__PaymentTypeInformation26 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PaymentTypeInformation26(soap, tag ? tag : "ns1:PaymentTypeInformation26", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentTypeInformation26 ** SOAP_FMAC4 soap_get_PointerTons1__PaymentTypeInformation26(struct soap *soap, ns1__PaymentTypeInformation26 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PaymentTypeInformation26(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PaymentIdentification6(struct soap *soap, ns1__PaymentIdentification6 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PaymentIdentification6))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PaymentIdentification6(struct soap *soap, const char *tag, int id, ns1__PaymentIdentification6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PaymentIdentification6, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PaymentIdentification6 ? type : NULL);
}

SOAP_FMAC3 ns1__PaymentIdentification6 ** SOAP_FMAC4 soap_in_PointerTons1__PaymentIdentification6(struct soap *soap, const char *tag, ns1__PaymentIdentification6 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentIdentification6 **)soap_malloc(soap, sizeof(ns1__PaymentIdentification6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PaymentIdentification6 *)soap_instantiate_ns1__PaymentIdentification6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PaymentIdentification6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PaymentIdentification6, sizeof(ns1__PaymentIdentification6), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PaymentIdentification6(struct soap *soap, ns1__PaymentIdentification6 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PaymentIdentification6(soap, tag ? tag : "ns1:PaymentIdentification6", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentIdentification6 ** SOAP_FMAC4 soap_get_PointerTons1__PaymentIdentification6(struct soap *soap, ns1__PaymentIdentification6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PaymentIdentification6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MandateSetupReason1Choice(struct soap *soap, ns1__MandateSetupReason1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MandateSetupReason1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MandateSetupReason1Choice(struct soap *soap, const char *tag, int id, ns1__MandateSetupReason1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MandateSetupReason1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MandateSetupReason1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__MandateSetupReason1Choice ** SOAP_FMAC4 soap_in_PointerTons1__MandateSetupReason1Choice(struct soap *soap, const char *tag, ns1__MandateSetupReason1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MandateSetupReason1Choice **)soap_malloc(soap, sizeof(ns1__MandateSetupReason1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MandateSetupReason1Choice *)soap_instantiate_ns1__MandateSetupReason1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MandateSetupReason1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MandateSetupReason1Choice, sizeof(ns1__MandateSetupReason1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MandateSetupReason1Choice(struct soap *soap, ns1__MandateSetupReason1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MandateSetupReason1Choice(soap, tag ? tag : "ns1:MandateSetupReason1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MandateSetupReason1Choice ** SOAP_FMAC4 soap_get_PointerTons1__MandateSetupReason1Choice(struct soap *soap, ns1__MandateSetupReason1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MandateSetupReason1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Frequency36Choice(struct soap *soap, ns1__Frequency36Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Frequency36Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Frequency36Choice(struct soap *soap, const char *tag, int id, ns1__Frequency36Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Frequency36Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Frequency36Choice ? type : NULL);
}

SOAP_FMAC3 ns1__Frequency36Choice ** SOAP_FMAC4 soap_in_PointerTons1__Frequency36Choice(struct soap *soap, const char *tag, ns1__Frequency36Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Frequency36Choice **)soap_malloc(soap, sizeof(ns1__Frequency36Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Frequency36Choice *)soap_instantiate_ns1__Frequency36Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Frequency36Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Frequency36Choice, sizeof(ns1__Frequency36Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Frequency36Choice(struct soap *soap, ns1__Frequency36Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Frequency36Choice(soap, tag ? tag : "ns1:Frequency36Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Frequency36Choice ** SOAP_FMAC4 soap_get_PointerTons1__Frequency36Choice(struct soap *soap, ns1__Frequency36Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Frequency36Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max10KBinary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ns1__Max10KBinary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max10KBinary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ns1__Max10KBinary, NULL);
	if (!*a || id < 0)
		return soap->error;
	return soap_out_ns1__Max10KBinary(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerTons1__Max10KBinary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max10KBinary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max10KBinary, sizeof(xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max10KBinary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max10KBinary(soap, tag ? tag : "ns1:Max10KBinary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerTons1__Max10KBinary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max10KBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ISODateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ISODateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ISODateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ISODateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ISODateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTons1__ISODateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ISODateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ISODateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ISODateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ISODateTime(soap, tag ? tag : "ns1:ISODateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTons1__ISODateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ISODateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MandateTypeInformation2(struct soap *soap, ns1__MandateTypeInformation2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MandateTypeInformation2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MandateTypeInformation2(struct soap *soap, const char *tag, int id, ns1__MandateTypeInformation2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MandateTypeInformation2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MandateTypeInformation2 ? type : NULL);
}

SOAP_FMAC3 ns1__MandateTypeInformation2 ** SOAP_FMAC4 soap_in_PointerTons1__MandateTypeInformation2(struct soap *soap, const char *tag, ns1__MandateTypeInformation2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MandateTypeInformation2 **)soap_malloc(soap, sizeof(ns1__MandateTypeInformation2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MandateTypeInformation2 *)soap_instantiate_ns1__MandateTypeInformation2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MandateTypeInformation2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MandateTypeInformation2, sizeof(ns1__MandateTypeInformation2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MandateTypeInformation2(struct soap *soap, ns1__MandateTypeInformation2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MandateTypeInformation2(soap, tag ? tag : "ns1:MandateTypeInformation2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MandateTypeInformation2 ** SOAP_FMAC4 soap_get_PointerTons1__MandateTypeInformation2(struct soap *soap, ns1__MandateTypeInformation2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MandateTypeInformation2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PreferredContactMethod1Code(struct soap *soap, enum ns1__PreferredContactMethod1Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__PreferredContactMethod1Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PreferredContactMethod1Code(struct soap *soap, const char *tag, int id, enum ns1__PreferredContactMethod1Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PreferredContactMethod1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PreferredContactMethod1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__PreferredContactMethod1Code ** SOAP_FMAC4 soap_in_PointerTons1__PreferredContactMethod1Code(struct soap *soap, const char *tag, enum ns1__PreferredContactMethod1Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__PreferredContactMethod1Code **)soap_malloc(soap, sizeof(enum ns1__PreferredContactMethod1Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PreferredContactMethod1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__PreferredContactMethod1Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PreferredContactMethod1Code, sizeof(enum ns1__PreferredContactMethod1Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PreferredContactMethod1Code(struct soap *soap, enum ns1__PreferredContactMethod1Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PreferredContactMethod1Code(soap, tag ? tag : "ns1:PreferredContactMethod1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PreferredContactMethod1Code ** SOAP_FMAC4 soap_get_PointerTons1__PreferredContactMethod1Code(struct soap *soap, enum ns1__PreferredContactMethod1Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PreferredContactMethod1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtherContact1(struct soap *soap, ns1__OtherContact1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OtherContact1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtherContact1(struct soap *soap, const char *tag, int id, ns1__OtherContact1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtherContact1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OtherContact1 ? type : NULL);
}

SOAP_FMAC3 ns1__OtherContact1 ** SOAP_FMAC4 soap_in_PointerTons1__OtherContact1(struct soap *soap, const char *tag, ns1__OtherContact1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtherContact1 **)soap_malloc(soap, sizeof(ns1__OtherContact1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OtherContact1 *)soap_instantiate_ns1__OtherContact1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OtherContact1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtherContact1, sizeof(ns1__OtherContact1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtherContact1(struct soap *soap, ns1__OtherContact1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OtherContact1(soap, tag ? tag : "ns1:OtherContact1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtherContact1 ** SOAP_FMAC4 soap_get_PointerTons1__OtherContact1(struct soap *soap, ns1__OtherContact1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtherContact1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max2048Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max2048Text))
		soap_serialize_ns1__Max2048Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max2048Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max2048Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max2048Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max2048Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max2048Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max2048Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max2048Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max2048Text(soap, tag ? tag : "ns1:Max2048Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max2048Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max2048Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneNumber(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneNumber))
		soap_serialize_ns1__PhoneNumber(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneNumber(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PhoneNumber, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PhoneNumber(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__PhoneNumber(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PhoneNumber(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PhoneNumber, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneNumber(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PhoneNumber(soap, tag ? tag : "ns1:PhoneNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__PhoneNumber(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NamePrefix2Code(struct soap *soap, enum ns1__NamePrefix2Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__NamePrefix2Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NamePrefix2Code(struct soap *soap, const char *tag, int id, enum ns1__NamePrefix2Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NamePrefix2Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__NamePrefix2Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__NamePrefix2Code ** SOAP_FMAC4 soap_in_PointerTons1__NamePrefix2Code(struct soap *soap, const char *tag, enum ns1__NamePrefix2Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__NamePrefix2Code **)soap_malloc(soap, sizeof(enum ns1__NamePrefix2Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__NamePrefix2Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__NamePrefix2Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NamePrefix2Code, sizeof(enum ns1__NamePrefix2Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NamePrefix2Code(struct soap *soap, enum ns1__NamePrefix2Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NamePrefix2Code(soap, tag ? tag : "ns1:NamePrefix2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NamePrefix2Code ** SOAP_FMAC4 soap_get_PointerTons1__NamePrefix2Code(struct soap *soap, enum ns1__NamePrefix2Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NamePrefix2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClearingSystemIdentification2Choice(struct soap *soap, ns1__ClearingSystemIdentification2Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClearingSystemIdentification2Choice(struct soap *soap, const char *tag, int id, ns1__ClearingSystemIdentification2Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ClearingSystemIdentification2Choice ? type : NULL);
}

SOAP_FMAC3 ns1__ClearingSystemIdentification2Choice ** SOAP_FMAC4 soap_in_PointerTons1__ClearingSystemIdentification2Choice(struct soap *soap, const char *tag, ns1__ClearingSystemIdentification2Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ClearingSystemIdentification2Choice **)soap_malloc(soap, sizeof(ns1__ClearingSystemIdentification2Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ClearingSystemIdentification2Choice *)soap_instantiate_ns1__ClearingSystemIdentification2Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ClearingSystemIdentification2Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClearingSystemIdentification2Choice, sizeof(ns1__ClearingSystemIdentification2Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClearingSystemIdentification2Choice(struct soap *soap, ns1__ClearingSystemIdentification2Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ClearingSystemIdentification2Choice(soap, tag ? tag : "ns1:ClearingSystemIdentification2Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ClearingSystemIdentification2Choice ** SOAP_FMAC4 soap_get_PointerTons1__ClearingSystemIdentification2Choice(struct soap *soap, ns1__ClearingSystemIdentification2Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ClearingSystemIdentification2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalClearingSystemIdentification1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code))
		soap_serialize_ns1__ExternalClearingSystemIdentification1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalClearingSystemIdentification1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalClearingSystemIdentification1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalClearingSystemIdentification1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalClearingSystemIdentification1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalClearingSystemIdentification1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalClearingSystemIdentification1Code(soap, tag ? tag : "ns1:ExternalClearingSystemIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalClearingSystemIdentification1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalClearingSystemIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ISODate(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ISODate))
		soap_serialize_ns1__ISODate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ISODate(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ISODate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ISODate(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ISODate(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ISODate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ISODate, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ISODate(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ISODate(soap, tag ? tag : "ns1:ISODate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ISODate(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ISODate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Priority2Code(struct soap *soap, enum ns1__Priority2Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__Priority2Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Priority2Code(struct soap *soap, const char *tag, int id, enum ns1__Priority2Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Priority2Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Priority2Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__Priority2Code ** SOAP_FMAC4 soap_in_PointerTons1__Priority2Code(struct soap *soap, const char *tag, enum ns1__Priority2Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__Priority2Code **)soap_malloc(soap, sizeof(enum ns1__Priority2Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Priority2Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__Priority2Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Priority2Code, sizeof(enum ns1__Priority2Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Priority2Code(struct soap *soap, enum ns1__Priority2Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Priority2Code(soap, tag ? tag : "ns1:Priority2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Priority2Code ** SOAP_FMAC4 soap_get_PointerTons1__Priority2Code(struct soap *soap, enum ns1__Priority2Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Priority2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChequeDeliveryMethod1Choice(struct soap *soap, ns1__ChequeDeliveryMethod1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChequeDeliveryMethod1Choice(struct soap *soap, const char *tag, int id, ns1__ChequeDeliveryMethod1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__ChequeDeliveryMethod1Choice ** SOAP_FMAC4 soap_in_PointerTons1__ChequeDeliveryMethod1Choice(struct soap *soap, const char *tag, ns1__ChequeDeliveryMethod1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChequeDeliveryMethod1Choice **)soap_malloc(soap, sizeof(ns1__ChequeDeliveryMethod1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChequeDeliveryMethod1Choice *)soap_instantiate_ns1__ChequeDeliveryMethod1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ChequeDeliveryMethod1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice, sizeof(ns1__ChequeDeliveryMethod1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChequeDeliveryMethod1Choice(struct soap *soap, ns1__ChequeDeliveryMethod1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ChequeDeliveryMethod1Choice(soap, tag ? tag : "ns1:ChequeDeliveryMethod1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ChequeDeliveryMethod1Choice ** SOAP_FMAC4 soap_get_PointerTons1__ChequeDeliveryMethod1Choice(struct soap *soap, ns1__ChequeDeliveryMethod1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChequeDeliveryMethod1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NameAndAddress16(struct soap *soap, ns1__NameAndAddress16 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NameAndAddress16))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NameAndAddress16(struct soap *soap, const char *tag, int id, ns1__NameAndAddress16 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NameAndAddress16, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NameAndAddress16 ? type : NULL);
}

SOAP_FMAC3 ns1__NameAndAddress16 ** SOAP_FMAC4 soap_in_PointerTons1__NameAndAddress16(struct soap *soap, const char *tag, ns1__NameAndAddress16 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NameAndAddress16 **)soap_malloc(soap, sizeof(ns1__NameAndAddress16 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NameAndAddress16 *)soap_instantiate_ns1__NameAndAddress16(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NameAndAddress16 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NameAndAddress16, sizeof(ns1__NameAndAddress16), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NameAndAddress16(struct soap *soap, ns1__NameAndAddress16 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NameAndAddress16(soap, tag ? tag : "ns1:NameAndAddress16", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NameAndAddress16 ** SOAP_FMAC4 soap_get_PointerTons1__NameAndAddress16(struct soap *soap, ns1__NameAndAddress16 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NameAndAddress16(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChequeType2Code(struct soap *soap, enum ns1__ChequeType2Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ChequeType2Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChequeType2Code(struct soap *soap, const char *tag, int id, enum ns1__ChequeType2Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChequeType2Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChequeType2Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ChequeType2Code ** SOAP_FMAC4 soap_in_PointerTons1__ChequeType2Code(struct soap *soap, const char *tag, enum ns1__ChequeType2Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ChequeType2Code **)soap_malloc(soap, sizeof(enum ns1__ChequeType2Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChequeType2Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ChequeType2Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChequeType2Code, sizeof(enum ns1__ChequeType2Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChequeType2Code(struct soap *soap, enum ns1__ChequeType2Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ChequeType2Code(soap, tag ? tag : "ns1:ChequeType2Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ChequeType2Code ** SOAP_FMAC4 soap_get_PointerTons1__ChequeType2Code(struct soap *soap, enum ns1__ChequeType2Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChequeType2Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalCategoryPurpose1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code))
		soap_serialize_ns1__ExternalCategoryPurpose1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalCategoryPurpose1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalCategoryPurpose1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalCategoryPurpose1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalCategoryPurpose1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalCategoryPurpose1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalCategoryPurpose1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalCategoryPurpose1Code(soap, tag ? tag : "ns1:ExternalCategoryPurpose1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalCategoryPurpose1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalCategoryPurpose1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalCashAccountType1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalCashAccountType1Code))
		soap_serialize_ns1__ExternalCashAccountType1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalCashAccountType1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalCashAccountType1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalCashAccountType1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalCashAccountType1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalCashAccountType1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalCashAccountType1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalCashAccountType1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalCashAccountType1Code(soap, tag ? tag : "ns1:ExternalCashAccountType1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalCashAccountType1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalCashAccountType1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProxyAccountIdentification1(struct soap *soap, ns1__ProxyAccountIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProxyAccountIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProxyAccountIdentification1(struct soap *soap, const char *tag, int id, ns1__ProxyAccountIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProxyAccountIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ProxyAccountIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__ProxyAccountIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__ProxyAccountIdentification1(struct soap *soap, const char *tag, ns1__ProxyAccountIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProxyAccountIdentification1 **)soap_malloc(soap, sizeof(ns1__ProxyAccountIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProxyAccountIdentification1 *)soap_instantiate_ns1__ProxyAccountIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ProxyAccountIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProxyAccountIdentification1, sizeof(ns1__ProxyAccountIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProxyAccountIdentification1(struct soap *soap, ns1__ProxyAccountIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ProxyAccountIdentification1(soap, tag ? tag : "ns1:ProxyAccountIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ProxyAccountIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__ProxyAccountIdentification1(struct soap *soap, ns1__ProxyAccountIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProxyAccountIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max70Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max70Text))
		soap_serialize_ns1__Max70Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max70Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max70Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max70Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max70Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max70Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max70Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max70Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max70Text(soap, tag ? tag : "ns1:Max70Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max70Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max70Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActiveOrHistoricCurrencyCode(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode))
		soap_serialize_ns1__ActiveOrHistoricCurrencyCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActiveOrHistoricCurrencyCode(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActiveOrHistoricCurrencyCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ActiveOrHistoricCurrencyCode(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActiveOrHistoricCurrencyCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActiveOrHistoricCurrencyCode(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyCode(soap, tag ? tag : "ns1:ActiveOrHistoricCurrencyCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ActiveOrHistoricCurrencyCode(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActiveOrHistoricCurrencyCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CashAccountType2Choice(struct soap *soap, ns1__CashAccountType2Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CashAccountType2Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CashAccountType2Choice(struct soap *soap, const char *tag, int id, ns1__CashAccountType2Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CashAccountType2Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CashAccountType2Choice ? type : NULL);
}

SOAP_FMAC3 ns1__CashAccountType2Choice ** SOAP_FMAC4 soap_in_PointerTons1__CashAccountType2Choice(struct soap *soap, const char *tag, ns1__CashAccountType2Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CashAccountType2Choice **)soap_malloc(soap, sizeof(ns1__CashAccountType2Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CashAccountType2Choice *)soap_instantiate_ns1__CashAccountType2Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CashAccountType2Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CashAccountType2Choice, sizeof(ns1__CashAccountType2Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CashAccountType2Choice(struct soap *soap, ns1__CashAccountType2Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CashAccountType2Choice(soap, tag ? tag : "ns1:CashAccountType2Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CashAccountType2Choice ** SOAP_FMAC4 soap_get_PointerTons1__CashAccountType2Choice(struct soap *soap, ns1__CashAccountType2Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CashAccountType2Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccountIdentification4Choice(struct soap *soap, ns1__AccountIdentification4Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccountIdentification4Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccountIdentification4Choice(struct soap *soap, const char *tag, int id, ns1__AccountIdentification4Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccountIdentification4Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AccountIdentification4Choice ? type : NULL);
}

SOAP_FMAC3 ns1__AccountIdentification4Choice ** SOAP_FMAC4 soap_in_PointerTons1__AccountIdentification4Choice(struct soap *soap, const char *tag, ns1__AccountIdentification4Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AccountIdentification4Choice **)soap_malloc(soap, sizeof(ns1__AccountIdentification4Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AccountIdentification4Choice *)soap_instantiate_ns1__AccountIdentification4Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AccountIdentification4Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccountIdentification4Choice, sizeof(ns1__AccountIdentification4Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccountIdentification4Choice(struct soap *soap, ns1__AccountIdentification4Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AccountIdentification4Choice(soap, tag ? tag : "ns1:AccountIdentification4Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AccountIdentification4Choice ** SOAP_FMAC4 soap_get_PointerTons1__AccountIdentification4Choice(struct soap *soap, ns1__AccountIdentification4Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccountIdentification4Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PostalAddress24(struct soap *soap, ns1__PostalAddress24 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PostalAddress24))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PostalAddress24(struct soap *soap, const char *tag, int id, ns1__PostalAddress24 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PostalAddress24, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PostalAddress24 ? type : NULL);
}

SOAP_FMAC3 ns1__PostalAddress24 ** SOAP_FMAC4 soap_in_PointerTons1__PostalAddress24(struct soap *soap, const char *tag, ns1__PostalAddress24 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PostalAddress24 **)soap_malloc(soap, sizeof(ns1__PostalAddress24 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PostalAddress24 *)soap_instantiate_ns1__PostalAddress24(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PostalAddress24 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PostalAddress24, sizeof(ns1__PostalAddress24), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PostalAddress24(struct soap *soap, ns1__PostalAddress24 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PostalAddress24(soap, tag ? tag : "ns1:PostalAddress24", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PostalAddress24 ** SOAP_FMAC4 soap_get_PointerTons1__PostalAddress24(struct soap *soap, ns1__PostalAddress24 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PostalAddress24(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max140Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max140Text))
		soap_serialize_ns1__Max140Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max140Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max140Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max140Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max140Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max140Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max140Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max140Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max140Text(soap, tag ? tag : "ns1:Max140Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max140Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max140Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LEIIdentifier(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LEIIdentifier))
		soap_serialize_ns1__LEIIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LEIIdentifier(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LEIIdentifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__LEIIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__LEIIdentifier(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__LEIIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LEIIdentifier, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LEIIdentifier(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LEIIdentifier(soap, tag ? tag : "ns1:LEIIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__LEIIdentifier(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LEIIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BranchData3(struct soap *soap, ns1__BranchData3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BranchData3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BranchData3(struct soap *soap, const char *tag, int id, ns1__BranchData3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BranchData3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BranchData3 ? type : NULL);
}

SOAP_FMAC3 ns1__BranchData3 ** SOAP_FMAC4 soap_in_PointerTons1__BranchData3(struct soap *soap, const char *tag, ns1__BranchData3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BranchData3 **)soap_malloc(soap, sizeof(ns1__BranchData3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BranchData3 *)soap_instantiate_ns1__BranchData3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BranchData3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BranchData3, sizeof(ns1__BranchData3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BranchData3(struct soap *soap, ns1__BranchData3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BranchData3(soap, tag ? tag : "ns1:BranchData3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BranchData3 ** SOAP_FMAC4 soap_get_PointerTons1__BranchData3(struct soap *soap, ns1__BranchData3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BranchData3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FinancialInstitutionIdentification18(struct soap *soap, ns1__FinancialInstitutionIdentification18 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FinancialInstitutionIdentification18))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FinancialInstitutionIdentification18(struct soap *soap, const char *tag, int id, ns1__FinancialInstitutionIdentification18 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FinancialInstitutionIdentification18 ? type : NULL);
}

SOAP_FMAC3 ns1__FinancialInstitutionIdentification18 ** SOAP_FMAC4 soap_in_PointerTons1__FinancialInstitutionIdentification18(struct soap *soap, const char *tag, ns1__FinancialInstitutionIdentification18 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FinancialInstitutionIdentification18 **)soap_malloc(soap, sizeof(ns1__FinancialInstitutionIdentification18 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FinancialInstitutionIdentification18 *)soap_instantiate_ns1__FinancialInstitutionIdentification18(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FinancialInstitutionIdentification18 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FinancialInstitutionIdentification18, sizeof(ns1__FinancialInstitutionIdentification18), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FinancialInstitutionIdentification18(struct soap *soap, ns1__FinancialInstitutionIdentification18 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FinancialInstitutionIdentification18(soap, tag ? tag : "ns1:FinancialInstitutionIdentification18", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FinancialInstitutionIdentification18 ** SOAP_FMAC4 soap_get_PointerTons1__FinancialInstitutionIdentification18(struct soap *soap, ns1__FinancialInstitutionIdentification18 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FinancialInstitutionIdentification18(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max128Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max128Text))
		soap_serialize_ns1__Max128Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max128Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max128Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max128Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max128Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max128Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max128Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max128Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max128Text(soap, tag ? tag : "ns1:Max128Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max128Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max128Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EquivalentAmount2(struct soap *soap, ns1__EquivalentAmount2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EquivalentAmount2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EquivalentAmount2(struct soap *soap, const char *tag, int id, ns1__EquivalentAmount2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EquivalentAmount2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__EquivalentAmount2 ? type : NULL);
}

SOAP_FMAC3 ns1__EquivalentAmount2 ** SOAP_FMAC4 soap_in_PointerTons1__EquivalentAmount2(struct soap *soap, const char *tag, ns1__EquivalentAmount2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EquivalentAmount2 **)soap_malloc(soap, sizeof(ns1__EquivalentAmount2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EquivalentAmount2 *)soap_instantiate_ns1__EquivalentAmount2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__EquivalentAmount2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EquivalentAmount2, sizeof(ns1__EquivalentAmount2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EquivalentAmount2(struct soap *soap, ns1__EquivalentAmount2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EquivalentAmount2(soap, tag ? tag : "ns1:EquivalentAmount2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EquivalentAmount2 ** SOAP_FMAC4 soap_get_PointerTons1__EquivalentAmount2(struct soap *soap, ns1__EquivalentAmount2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EquivalentAmount2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, ns1__ActiveOrHistoricCurrencyAndAmount *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, const char *tag, int id, ns1__ActiveOrHistoricCurrencyAndAmount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount ? type : NULL);
}

SOAP_FMAC3 ns1__ActiveOrHistoricCurrencyAndAmount ** SOAP_FMAC4 soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, const char *tag, ns1__ActiveOrHistoricCurrencyAndAmount **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ActiveOrHistoricCurrencyAndAmount **)soap_malloc(soap, sizeof(ns1__ActiveOrHistoricCurrencyAndAmount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ActiveOrHistoricCurrencyAndAmount *)soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ActiveOrHistoricCurrencyAndAmount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount, sizeof(ns1__ActiveOrHistoricCurrencyAndAmount), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, ns1__ActiveOrHistoricCurrencyAndAmount *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, tag ? tag : "ns1:ActiveOrHistoricCurrencyAndAmount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ActiveOrHistoricCurrencyAndAmount ** SOAP_FMAC4 soap_get_PointerTons1__ActiveOrHistoricCurrencyAndAmount(struct soap *soap, ns1__ActiveOrHistoricCurrencyAndAmount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActiveOrHistoricCurrencyAndAmount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AdviceType1Choice(struct soap *soap, ns1__AdviceType1Choice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AdviceType1Choice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AdviceType1Choice(struct soap *soap, const char *tag, int id, ns1__AdviceType1Choice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AdviceType1Choice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AdviceType1Choice ? type : NULL);
}

SOAP_FMAC3 ns1__AdviceType1Choice ** SOAP_FMAC4 soap_in_PointerTons1__AdviceType1Choice(struct soap *soap, const char *tag, ns1__AdviceType1Choice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AdviceType1Choice **)soap_malloc(soap, sizeof(ns1__AdviceType1Choice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AdviceType1Choice *)soap_instantiate_ns1__AdviceType1Choice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AdviceType1Choice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AdviceType1Choice, sizeof(ns1__AdviceType1Choice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AdviceType1Choice(struct soap *soap, ns1__AdviceType1Choice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AdviceType1Choice(soap, tag ? tag : "ns1:AdviceType1Choice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AdviceType1Choice ** SOAP_FMAC4 soap_get_PointerTons1__AdviceType1Choice(struct soap *soap, ns1__AdviceType1Choice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AdviceType1Choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericIdentification30(struct soap *soap, ns1__GenericIdentification30 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericIdentification30))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericIdentification30(struct soap *soap, const char *tag, int id, ns1__GenericIdentification30 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericIdentification30, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericIdentification30 ? type : NULL);
}

SOAP_FMAC3 ns1__GenericIdentification30 ** SOAP_FMAC4 soap_in_PointerTons1__GenericIdentification30(struct soap *soap, const char *tag, ns1__GenericIdentification30 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericIdentification30 **)soap_malloc(soap, sizeof(ns1__GenericIdentification30 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericIdentification30 *)soap_instantiate_ns1__GenericIdentification30(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericIdentification30 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericIdentification30, sizeof(ns1__GenericIdentification30), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericIdentification30(struct soap *soap, ns1__GenericIdentification30 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericIdentification30(soap, tag ? tag : "ns1:GenericIdentification30", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericIdentification30 ** SOAP_FMAC4 soap_get_PointerTons1__GenericIdentification30(struct soap *soap, ns1__GenericIdentification30 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericIdentification30(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Max35Text(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Max35Text))
		soap_serialize_ns1__Max35Text(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Max35Text(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Max35Text, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Max35Text(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__Max35Text(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Max35Text(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Max35Text, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Max35Text(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Max35Text(soap, tag ? tag : "ns1:Max35Text", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__Max35Text(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Max35Text(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExternalAccountIdentification1Code(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExternalAccountIdentification1Code))
		soap_serialize_ns1__ExternalAccountIdentification1Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExternalAccountIdentification1Code(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExternalAccountIdentification1Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__ExternalAccountIdentification1Code(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExternalAccountIdentification1Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExternalAccountIdentification1Code, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExternalAccountIdentification1Code(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExternalAccountIdentification1Code(soap, tag ? tag : "ns1:ExternalAccountIdentification1Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__ExternalAccountIdentification1Code(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExternalAccountIdentification1Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericAccountIdentification1(struct soap *soap, ns1__GenericAccountIdentification1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericAccountIdentification1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericAccountIdentification1(struct soap *soap, const char *tag, int id, ns1__GenericAccountIdentification1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericAccountIdentification1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericAccountIdentification1 ? type : NULL);
}

SOAP_FMAC3 ns1__GenericAccountIdentification1 ** SOAP_FMAC4 soap_in_PointerTons1__GenericAccountIdentification1(struct soap *soap, const char *tag, ns1__GenericAccountIdentification1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericAccountIdentification1 **)soap_malloc(soap, sizeof(ns1__GenericAccountIdentification1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericAccountIdentification1 *)soap_instantiate_ns1__GenericAccountIdentification1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericAccountIdentification1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericAccountIdentification1, sizeof(ns1__GenericAccountIdentification1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericAccountIdentification1(struct soap *soap, ns1__GenericAccountIdentification1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericAccountIdentification1(soap, tag ? tag : "ns1:GenericAccountIdentification1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericAccountIdentification1 ** SOAP_FMAC4 soap_get_PointerTons1__GenericAccountIdentification1(struct soap *soap, ns1__GenericAccountIdentification1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericAccountIdentification1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IBAN2007Identifier(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IBAN2007Identifier))
		soap_serialize_ns1__IBAN2007Identifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IBAN2007Identifier(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IBAN2007Identifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__IBAN2007Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__IBAN2007Identifier(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__IBAN2007Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IBAN2007Identifier, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IBAN2007Identifier(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__IBAN2007Identifier(soap, tag ? tag : "ns1:IBAN2007Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__IBAN2007Identifier(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IBAN2007Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TaxRecord3(struct soap *soap, std::vector<ns1__TaxRecord3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TaxRecord3(struct soap *soap, const std::vector<ns1__TaxRecord3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TaxRecord3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TaxRecord3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TaxRecord3(struct soap *soap, const char *tag, int id, const std::vector<ns1__TaxRecord3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__TaxRecord3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TaxRecord3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TaxRecord3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TaxRecord3(struct soap *soap, const char *tag, std::vector<ns1__TaxRecord3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TaxRecord3(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__TaxRecord3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__TaxRecord3, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3, sizeof(ns1__TaxRecord3), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__TaxRecord3(soap, tag, NULL, "ns1:TaxRecord3"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__TaxRecord3(soap, tag, &n, "ns1:TaxRecord3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TaxRecord3 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecord3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecord3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__TaxRecord3 *> *p;
	size_t k = sizeof(std::vector<ns1__TaxRecord3 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__TaxRecord3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__TaxRecord3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__TaxRecord3 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(struct soap *soap, std::vector<ns1__TaxRecordDetails3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(struct soap *soap, const std::vector<ns1__TaxRecordDetails3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TaxRecordDetails3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TaxRecordDetails3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(struct soap *soap, const char *tag, int id, const std::vector<ns1__TaxRecordDetails3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__TaxRecordDetails3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TaxRecordDetails3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TaxRecordDetails3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(struct soap *soap, const char *tag, std::vector<ns1__TaxRecordDetails3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__TaxRecordDetails3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__TaxRecordDetails3, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3, sizeof(ns1__TaxRecordDetails3), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__TaxRecordDetails3(soap, tag, NULL, "ns1:TaxRecordDetails3"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__TaxRecordDetails3(soap, tag, &n, "ns1:TaxRecordDetails3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TaxRecordDetails3 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TaxRecordDetails3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__TaxRecordDetails3 *> *p;
	size_t k = sizeof(std::vector<ns1__TaxRecordDetails3 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__TaxRecordDetails3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__TaxRecordDetails3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__TaxRecordDetails3 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(struct soap *soap, std::vector<ns1__ReferredDocumentInformation7 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(struct soap *soap, const std::vector<ns1__ReferredDocumentInformation7 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ReferredDocumentInformation7 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ReferredDocumentInformation7(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(struct soap *soap, const char *tag, int id, const std::vector<ns1__ReferredDocumentInformation7 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ReferredDocumentInformation7 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ReferredDocumentInformation7(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ReferredDocumentInformation7 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(struct soap *soap, const char *tag, std::vector<ns1__ReferredDocumentInformation7 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ReferredDocumentInformation7 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ReferredDocumentInformation7, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7, sizeof(ns1__ReferredDocumentInformation7), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ReferredDocumentInformation7(soap, tag, NULL, "ns1:ReferredDocumentInformation7"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ReferredDocumentInformation7(soap, tag, &n, "ns1:ReferredDocumentInformation7"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ReferredDocumentInformation7 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ReferredDocumentInformation7 *> *p;
	size_t k = sizeof(std::vector<ns1__ReferredDocumentInformation7 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ReferredDocumentInformation7 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ReferredDocumentInformation7 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ReferredDocumentInformation7 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(struct soap *soap, std::vector<ns1__RemittanceLocationData1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(struct soap *soap, const std::vector<ns1__RemittanceLocationData1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RemittanceLocationData1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RemittanceLocationData1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(struct soap *soap, const char *tag, int id, const std::vector<ns1__RemittanceLocationData1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RemittanceLocationData1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RemittanceLocationData1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RemittanceLocationData1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(struct soap *soap, const char *tag, std::vector<ns1__RemittanceLocationData1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RemittanceLocationData1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RemittanceLocationData1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1, sizeof(ns1__RemittanceLocationData1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RemittanceLocationData1(soap, tag, NULL, "ns1:RemittanceLocationData1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RemittanceLocationData1(soap, tag, &n, "ns1:RemittanceLocationData1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RemittanceLocationData1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocationData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RemittanceLocationData1 *> *p;
	size_t k = sizeof(std::vector<ns1__RemittanceLocationData1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RemittanceLocationData1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RemittanceLocationData1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RemittanceLocationData1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(struct soap *soap, std::vector<ns1__StructuredRemittanceInformation17 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(struct soap *soap, const std::vector<ns1__StructuredRemittanceInformation17 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__StructuredRemittanceInformation17 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StructuredRemittanceInformation17(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, int id, const std::vector<ns1__StructuredRemittanceInformation17 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__StructuredRemittanceInformation17 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StructuredRemittanceInformation17(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StructuredRemittanceInformation17 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(struct soap *soap, const char *tag, std::vector<ns1__StructuredRemittanceInformation17 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__StructuredRemittanceInformation17 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__StructuredRemittanceInformation17, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17, sizeof(ns1__StructuredRemittanceInformation17), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__StructuredRemittanceInformation17(soap, tag, NULL, "ns1:StructuredRemittanceInformation17"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__StructuredRemittanceInformation17(soap, tag, &n, "ns1:StructuredRemittanceInformation17"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StructuredRemittanceInformation17 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__StructuredRemittanceInformation17 *> *p;
	size_t k = sizeof(std::vector<ns1__StructuredRemittanceInformation17 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__StructuredRemittanceInformation17 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__StructuredRemittanceInformation17 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__StructuredRemittanceInformation17 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__Max140Text(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__Max140Text(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns1__Max140Text(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__Max140Text(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__Max140Text(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__Max140Text(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__Max140Text(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_ns1__Max140Text(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Max140Text, SOAP_TYPE_std__vectorTemplateOfns1__Max140Text, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__Max140Text(soap, tag, NULL, "ns1:Max140Text"))
				break;
		}
		else
		{	if (!soap_in_ns1__Max140Text(soap, tag, &n, "ns1:Max140Text"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__Max140Text(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__Max140Text(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__Max140Text, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(struct soap *soap, std::vector<ns1__DocumentAdjustment1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(struct soap *soap, const std::vector<ns1__DocumentAdjustment1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DocumentAdjustment1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DocumentAdjustment1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(struct soap *soap, const char *tag, int id, const std::vector<ns1__DocumentAdjustment1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DocumentAdjustment1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DocumentAdjustment1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DocumentAdjustment1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(struct soap *soap, const char *tag, std::vector<ns1__DocumentAdjustment1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DocumentAdjustment1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DocumentAdjustment1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1, sizeof(ns1__DocumentAdjustment1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DocumentAdjustment1(soap, tag, NULL, "ns1:DocumentAdjustment1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DocumentAdjustment1(soap, tag, &n, "ns1:DocumentAdjustment1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DocumentAdjustment1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentAdjustment1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DocumentAdjustment1 *> *p;
	size_t k = sizeof(std::vector<ns1__DocumentAdjustment1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DocumentAdjustment1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DocumentAdjustment1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DocumentAdjustment1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(struct soap *soap, std::vector<ns1__TaxAmountAndType1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(struct soap *soap, const std::vector<ns1__TaxAmountAndType1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TaxAmountAndType1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TaxAmountAndType1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(struct soap *soap, const char *tag, int id, const std::vector<ns1__TaxAmountAndType1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__TaxAmountAndType1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TaxAmountAndType1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TaxAmountAndType1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(struct soap *soap, const char *tag, std::vector<ns1__TaxAmountAndType1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__TaxAmountAndType1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__TaxAmountAndType1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1, sizeof(ns1__TaxAmountAndType1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__TaxAmountAndType1(soap, tag, NULL, "ns1:TaxAmountAndType1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__TaxAmountAndType1(soap, tag, &n, "ns1:TaxAmountAndType1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TaxAmountAndType1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TaxAmountAndType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__TaxAmountAndType1 *> *p;
	size_t k = sizeof(std::vector<ns1__TaxAmountAndType1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__TaxAmountAndType1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__TaxAmountAndType1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__TaxAmountAndType1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(struct soap *soap, std::vector<ns1__DiscountAmountAndType1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(struct soap *soap, const std::vector<ns1__DiscountAmountAndType1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DiscountAmountAndType1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DiscountAmountAndType1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(struct soap *soap, const char *tag, int id, const std::vector<ns1__DiscountAmountAndType1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DiscountAmountAndType1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DiscountAmountAndType1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DiscountAmountAndType1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(struct soap *soap, const char *tag, std::vector<ns1__DiscountAmountAndType1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DiscountAmountAndType1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DiscountAmountAndType1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1, sizeof(ns1__DiscountAmountAndType1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DiscountAmountAndType1(soap, tag, NULL, "ns1:DiscountAmountAndType1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DiscountAmountAndType1(soap, tag, &n, "ns1:DiscountAmountAndType1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DiscountAmountAndType1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DiscountAmountAndType1 *> *p;
	size_t k = sizeof(std::vector<ns1__DiscountAmountAndType1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DiscountAmountAndType1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DiscountAmountAndType1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DiscountAmountAndType1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(struct soap *soap, std::vector<ns1__StructuredRegulatoryReporting3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(struct soap *soap, const std::vector<ns1__StructuredRegulatoryReporting3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__StructuredRegulatoryReporting3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StructuredRegulatoryReporting3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, int id, const std::vector<ns1__StructuredRegulatoryReporting3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__StructuredRegulatoryReporting3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StructuredRegulatoryReporting3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StructuredRegulatoryReporting3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(struct soap *soap, const char *tag, std::vector<ns1__StructuredRegulatoryReporting3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__StructuredRegulatoryReporting3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__StructuredRegulatoryReporting3, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3, sizeof(ns1__StructuredRegulatoryReporting3), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__StructuredRegulatoryReporting3(soap, tag, NULL, "ns1:StructuredRegulatoryReporting3"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__StructuredRegulatoryReporting3(soap, tag, &n, "ns1:StructuredRegulatoryReporting3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StructuredRegulatoryReporting3 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__StructuredRegulatoryReporting3 *> *p;
	size_t k = sizeof(std::vector<ns1__StructuredRegulatoryReporting3 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__StructuredRegulatoryReporting3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__StructuredRegulatoryReporting3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__StructuredRegulatoryReporting3 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(struct soap *soap, std::vector<ns1__DocumentLineInformation1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(struct soap *soap, const std::vector<ns1__DocumentLineInformation1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DocumentLineInformation1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DocumentLineInformation1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(struct soap *soap, const char *tag, int id, const std::vector<ns1__DocumentLineInformation1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DocumentLineInformation1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DocumentLineInformation1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DocumentLineInformation1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(struct soap *soap, const char *tag, std::vector<ns1__DocumentLineInformation1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DocumentLineInformation1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DocumentLineInformation1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1, sizeof(ns1__DocumentLineInformation1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DocumentLineInformation1(soap, tag, NULL, "ns1:DocumentLineInformation1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DocumentLineInformation1(soap, tag, &n, "ns1:DocumentLineInformation1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DocumentLineInformation1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineInformation1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DocumentLineInformation1 *> *p;
	size_t k = sizeof(std::vector<ns1__DocumentLineInformation1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DocumentLineInformation1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DocumentLineInformation1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DocumentLineInformation1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(struct soap *soap, std::vector<ns1__GenericPersonIdentification1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(struct soap *soap, const std::vector<ns1__GenericPersonIdentification1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__GenericPersonIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__GenericPersonIdentification1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(struct soap *soap, const char *tag, int id, const std::vector<ns1__GenericPersonIdentification1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__GenericPersonIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__GenericPersonIdentification1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GenericPersonIdentification1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(struct soap *soap, const char *tag, std::vector<ns1__GenericPersonIdentification1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__GenericPersonIdentification1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__GenericPersonIdentification1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1, sizeof(ns1__GenericPersonIdentification1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__GenericPersonIdentification1(soap, tag, NULL, "ns1:GenericPersonIdentification1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__GenericPersonIdentification1(soap, tag, &n, "ns1:GenericPersonIdentification1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__GenericPersonIdentification1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__GenericPersonIdentification1 *> *p;
	size_t k = sizeof(std::vector<ns1__GenericPersonIdentification1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__GenericPersonIdentification1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__GenericPersonIdentification1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__GenericPersonIdentification1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(struct soap *soap, std::vector<ns1__ServiceLevel8Choice *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(struct soap *soap, const std::vector<ns1__ServiceLevel8Choice *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ServiceLevel8Choice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ServiceLevel8Choice(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(struct soap *soap, const char *tag, int id, const std::vector<ns1__ServiceLevel8Choice *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ServiceLevel8Choice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ServiceLevel8Choice(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ServiceLevel8Choice *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(struct soap *soap, const char *tag, std::vector<ns1__ServiceLevel8Choice *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ServiceLevel8Choice *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ServiceLevel8Choice, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice, sizeof(ns1__ServiceLevel8Choice), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ServiceLevel8Choice(soap, tag, NULL, "ns1:ServiceLevel8Choice"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ServiceLevel8Choice(soap, tag, &n, "ns1:ServiceLevel8Choice"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ServiceLevel8Choice *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ServiceLevel8Choice *> *p;
	size_t k = sizeof(std::vector<ns1__ServiceLevel8Choice *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ServiceLevel8Choice *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ServiceLevel8Choice *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ServiceLevel8Choice *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(struct soap *soap, std::vector<ns1__CreditTransferTransaction54 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(struct soap *soap, const std::vector<ns1__CreditTransferTransaction54 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__CreditTransferTransaction54 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__CreditTransferTransaction54(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(struct soap *soap, const char *tag, int id, const std::vector<ns1__CreditTransferTransaction54 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__CreditTransferTransaction54 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__CreditTransferTransaction54(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__CreditTransferTransaction54 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(struct soap *soap, const char *tag, std::vector<ns1__CreditTransferTransaction54 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__CreditTransferTransaction54 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__CreditTransferTransaction54, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54, sizeof(ns1__CreditTransferTransaction54), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__CreditTransferTransaction54(soap, tag, NULL, "ns1:CreditTransferTransaction54"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__CreditTransferTransaction54(soap, tag, &n, "ns1:CreditTransferTransaction54"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__CreditTransferTransaction54 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__CreditTransferTransaction54 *> *p;
	size_t k = sizeof(std::vector<ns1__CreditTransferTransaction54 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__CreditTransferTransaction54 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__CreditTransferTransaction54 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__CreditTransferTransaction54 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(struct soap *soap, std::vector<ns1__GenericOrganisationIdentification1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(struct soap *soap, const std::vector<ns1__GenericOrganisationIdentification1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__GenericOrganisationIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__GenericOrganisationIdentification1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, int id, const std::vector<ns1__GenericOrganisationIdentification1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__GenericOrganisationIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__GenericOrganisationIdentification1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GenericOrganisationIdentification1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(struct soap *soap, const char *tag, std::vector<ns1__GenericOrganisationIdentification1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__GenericOrganisationIdentification1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__GenericOrganisationIdentification1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1, sizeof(ns1__GenericOrganisationIdentification1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__GenericOrganisationIdentification1(soap, tag, NULL, "ns1:GenericOrganisationIdentification1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__GenericOrganisationIdentification1(soap, tag, &n, "ns1:GenericOrganisationIdentification1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__GenericOrganisationIdentification1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__GenericOrganisationIdentification1 *> *p;
	size_t k = sizeof(std::vector<ns1__GenericOrganisationIdentification1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__GenericOrganisationIdentification1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__GenericOrganisationIdentification1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__GenericOrganisationIdentification1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Authorisation1Choice(struct soap *soap, std::vector<ns1__Authorisation1Choice *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Authorisation1Choice(struct soap *soap, const std::vector<ns1__Authorisation1Choice *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Authorisation1Choice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Authorisation1Choice(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Authorisation1Choice(struct soap *soap, const char *tag, int id, const std::vector<ns1__Authorisation1Choice *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Authorisation1Choice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Authorisation1Choice(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Authorisation1Choice *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Authorisation1Choice(struct soap *soap, const char *tag, std::vector<ns1__Authorisation1Choice *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Authorisation1Choice(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Authorisation1Choice *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Authorisation1Choice, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice, sizeof(ns1__Authorisation1Choice), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Authorisation1Choice(soap, tag, NULL, "ns1:Authorisation1Choice"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Authorisation1Choice(soap, tag, &n, "ns1:Authorisation1Choice"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Authorisation1Choice *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Authorisation1Choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Authorisation1Choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Authorisation1Choice *> *p;
	size_t k = sizeof(std::vector<ns1__Authorisation1Choice *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Authorisation1Choice *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Authorisation1Choice *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Authorisation1Choice *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(struct soap *soap, std::vector<ns1__DocumentLineIdentification1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(struct soap *soap, const std::vector<ns1__DocumentLineIdentification1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DocumentLineIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DocumentLineIdentification1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(struct soap *soap, const char *tag, int id, const std::vector<ns1__DocumentLineIdentification1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DocumentLineIdentification1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DocumentLineIdentification1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DocumentLineIdentification1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(struct soap *soap, const char *tag, std::vector<ns1__DocumentLineIdentification1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DocumentLineIdentification1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DocumentLineIdentification1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1, sizeof(ns1__DocumentLineIdentification1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DocumentLineIdentification1(soap, tag, NULL, "ns1:DocumentLineIdentification1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DocumentLineIdentification1(soap, tag, &n, "ns1:DocumentLineIdentification1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DocumentLineIdentification1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DocumentLineIdentification1 *> *p;
	size_t k = sizeof(std::vector<ns1__DocumentLineIdentification1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DocumentLineIdentification1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DocumentLineIdentification1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DocumentLineIdentification1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PaymentInstruction40(struct soap *soap, std::vector<ns1__PaymentInstruction40 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PaymentInstruction40(struct soap *soap, const std::vector<ns1__PaymentInstruction40 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__PaymentInstruction40 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__PaymentInstruction40(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PaymentInstruction40(struct soap *soap, const char *tag, int id, const std::vector<ns1__PaymentInstruction40 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__PaymentInstruction40 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__PaymentInstruction40(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PaymentInstruction40 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PaymentInstruction40(struct soap *soap, const char *tag, std::vector<ns1__PaymentInstruction40 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__PaymentInstruction40(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__PaymentInstruction40 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__PaymentInstruction40, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40, sizeof(ns1__PaymentInstruction40), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__PaymentInstruction40(soap, tag, NULL, "ns1:PaymentInstruction40"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__PaymentInstruction40(soap, tag, &n, "ns1:PaymentInstruction40"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__PaymentInstruction40 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__PaymentInstruction40(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PaymentInstruction40(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__PaymentInstruction40 *> *p;
	size_t k = sizeof(std::vector<ns1__PaymentInstruction40 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__PaymentInstruction40 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__PaymentInstruction40 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__PaymentInstruction40 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SupplementaryData1(struct soap *soap, std::vector<ns1__SupplementaryData1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SupplementaryData1(struct soap *soap, const std::vector<ns1__SupplementaryData1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SupplementaryData1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SupplementaryData1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SupplementaryData1(struct soap *soap, const char *tag, int id, const std::vector<ns1__SupplementaryData1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SupplementaryData1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SupplementaryData1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SupplementaryData1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SupplementaryData1(struct soap *soap, const char *tag, std::vector<ns1__SupplementaryData1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SupplementaryData1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__SupplementaryData1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__SupplementaryData1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1, sizeof(ns1__SupplementaryData1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__SupplementaryData1(soap, tag, NULL, "ns1:SupplementaryData1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SupplementaryData1(soap, tag, &n, "ns1:SupplementaryData1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SupplementaryData1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SupplementaryData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SupplementaryData1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SupplementaryData1 *> *p;
	size_t k = sizeof(std::vector<ns1__SupplementaryData1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__SupplementaryData1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__SupplementaryData1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SupplementaryData1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RemittanceLocation7(struct soap *soap, std::vector<ns1__RemittanceLocation7 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RemittanceLocation7(struct soap *soap, const std::vector<ns1__RemittanceLocation7 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RemittanceLocation7 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RemittanceLocation7(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RemittanceLocation7(struct soap *soap, const char *tag, int id, const std::vector<ns1__RemittanceLocation7 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RemittanceLocation7 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RemittanceLocation7(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RemittanceLocation7 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RemittanceLocation7(struct soap *soap, const char *tag, std::vector<ns1__RemittanceLocation7 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RemittanceLocation7(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RemittanceLocation7 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RemittanceLocation7, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7, sizeof(ns1__RemittanceLocation7), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RemittanceLocation7(soap, tag, NULL, "ns1:RemittanceLocation7"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RemittanceLocation7(soap, tag, &n, "ns1:RemittanceLocation7"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RemittanceLocation7 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocation7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RemittanceLocation7(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RemittanceLocation7 *> *p;
	size_t k = sizeof(std::vector<ns1__RemittanceLocation7 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RemittanceLocation7 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RemittanceLocation7 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RemittanceLocation7 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(struct soap *soap, std::vector<ns1__RegulatoryReporting3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(struct soap *soap, const std::vector<ns1__RegulatoryReporting3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RegulatoryReporting3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RegulatoryReporting3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(struct soap *soap, const char *tag, int id, const std::vector<ns1__RegulatoryReporting3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RegulatoryReporting3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RegulatoryReporting3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RegulatoryReporting3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(struct soap *soap, const char *tag, std::vector<ns1__RegulatoryReporting3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RegulatoryReporting3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RegulatoryReporting3, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3, sizeof(ns1__RegulatoryReporting3), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RegulatoryReporting3(soap, tag, NULL, "ns1:RegulatoryReporting3"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RegulatoryReporting3(soap, tag, &n, "ns1:RegulatoryReporting3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RegulatoryReporting3 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RegulatoryReporting3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RegulatoryReporting3 *> *p;
	size_t k = sizeof(std::vector<ns1__RegulatoryReporting3 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RegulatoryReporting3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RegulatoryReporting3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RegulatoryReporting3 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(struct soap *soap, std::vector<ns1__InstructionForCreditorAgent3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(struct soap *soap, const std::vector<ns1__InstructionForCreditorAgent3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__InstructionForCreditorAgent3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__InstructionForCreditorAgent3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, int id, const std::vector<ns1__InstructionForCreditorAgent3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__InstructionForCreditorAgent3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__InstructionForCreditorAgent3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__InstructionForCreditorAgent3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(struct soap *soap, const char *tag, std::vector<ns1__InstructionForCreditorAgent3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__InstructionForCreditorAgent3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__InstructionForCreditorAgent3, SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3, sizeof(ns1__InstructionForCreditorAgent3), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__InstructionForCreditorAgent3(soap, tag, NULL, "ns1:InstructionForCreditorAgent3"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__InstructionForCreditorAgent3(soap, tag, &n, "ns1:InstructionForCreditorAgent3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__InstructionForCreditorAgent3 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__InstructionForCreditorAgent3 *> *p;
	size_t k = sizeof(std::vector<ns1__InstructionForCreditorAgent3 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__InstructionForCreditorAgent3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__InstructionForCreditorAgent3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__InstructionForCreditorAgent3 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__OtherContact1(struct soap *soap, std::vector<ns1__OtherContact1 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__OtherContact1(struct soap *soap, const std::vector<ns1__OtherContact1 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__OtherContact1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__OtherContact1(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__OtherContact1(struct soap *soap, const char *tag, int id, const std::vector<ns1__OtherContact1 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__OtherContact1 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__OtherContact1(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__OtherContact1 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__OtherContact1(struct soap *soap, const char *tag, std::vector<ns1__OtherContact1 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__OtherContact1(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__OtherContact1 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__OtherContact1, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1, sizeof(ns1__OtherContact1), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__OtherContact1(soap, tag, NULL, "ns1:OtherContact1"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__OtherContact1(soap, tag, &n, "ns1:OtherContact1"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__OtherContact1 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__OtherContact1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__OtherContact1(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__OtherContact1 *> *p;
	size_t k = sizeof(std::vector<ns1__OtherContact1 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__OtherContact1 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__OtherContact1 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__OtherContact1 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__Max70Text(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__Max70Text(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns1__Max70Text(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__Max70Text(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__Max70Text(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__Max70Text(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__Max70Text(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_ns1__Max70Text(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Max70Text, SOAP_TYPE_std__vectorTemplateOfns1__Max70Text, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__Max70Text(soap, tag, NULL, "ns1:Max70Text"))
				break;
		}
		else
		{	if (!soap_in_ns1__Max70Text(soap, tag, &n, "ns1:Max70Text"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__Max70Text(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__Max70Text(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__Max70Text, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__Max35Text(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__Max35Text(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns1__Max35Text(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__Max35Text(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__Max35Text(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__Max35Text(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__Max35Text(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_ns1__Max35Text(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Max35Text, SOAP_TYPE_std__vectorTemplateOfns1__Max35Text, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__Max35Text(soap, tag, NULL, "ns1:Max35Text"))
				break;
		}
		else
		{	if (!soap_in_ns1__Max35Text(soap, tag, &n, "ns1:Max35Text"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__Max35Text(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__Max35Text(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__Max35Text, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
