/* soapStub.h
   Generated by gSOAP 2.8.117 for pain.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"urn:iso:std:iso:20022:tech:xsd:pain.001.001.11"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* pain.h:398 */
#ifndef SOAP_TYPE_ns1__AddressType2Code
#define SOAP_TYPE_ns1__AddressType2Code (117)
/* ns1:AddressType2Code */
enum ns1__AddressType2Code {
	ns1__AddressType2Code__ADDR = 0,
	ns1__AddressType2Code__PBOX = 1,
	ns1__AddressType2Code__HOME = 2,
	ns1__AddressType2Code__BIZZ = 3,
	ns1__AddressType2Code__MLTO = 4,
	ns1__AddressType2Code__DLVY = 5
};
#endif

/* pain.h:411 */
#ifndef SOAP_TYPE_ns1__AdviceType1Code
#define SOAP_TYPE_ns1__AdviceType1Code (118)
/* ns1:AdviceType1Code */
enum ns1__AdviceType1Code {
	ns1__AdviceType1Code__ADWD = 0,
	ns1__AdviceType1Code__ADND = 1
};
#endif

/* pain.h:425 */
#ifndef SOAP_TYPE_ns1__Authorisation1Code
#define SOAP_TYPE_ns1__Authorisation1Code (120)
/* ns1:Authorisation1Code */
enum ns1__Authorisation1Code {
	ns1__Authorisation1Code__AUTH = 0,
	ns1__Authorisation1Code__FDET = 1,
	ns1__Authorisation1Code__FSUM = 2,
	ns1__Authorisation1Code__ILEV = 3
};
#endif

/* pain.h:451 */
#ifndef SOAP_TYPE_ns1__ChargeBearerType1Code
#define SOAP_TYPE_ns1__ChargeBearerType1Code (125)
/* ns1:ChargeBearerType1Code */
enum ns1__ChargeBearerType1Code {
	ns1__ChargeBearerType1Code__DEBT = 0,
	ns1__ChargeBearerType1Code__CRED = 1,
	ns1__ChargeBearerType1Code__SHAR = 2,
	ns1__ChargeBearerType1Code__SLEV = 3
};
#endif

/* pain.h:462 */
#ifndef SOAP_TYPE_ns1__ChequeDelivery1Code
#define SOAP_TYPE_ns1__ChequeDelivery1Code (126)
/* ns1:ChequeDelivery1Code */
enum ns1__ChequeDelivery1Code {
	ns1__ChequeDelivery1Code__MLDB = 0,
	ns1__ChequeDelivery1Code__MLCD = 1,
	ns1__ChequeDelivery1Code__MLFA = 2,
	ns1__ChequeDelivery1Code__CRDB = 3,
	ns1__ChequeDelivery1Code__CRCD = 4,
	ns1__ChequeDelivery1Code__CRFA = 5,
	ns1__ChequeDelivery1Code__PUDB = 6,
	ns1__ChequeDelivery1Code__PUCD = 7,
	ns1__ChequeDelivery1Code__PUFA = 8,
	ns1__ChequeDelivery1Code__RGDB = 9,
	ns1__ChequeDelivery1Code__RGCD = 10,
	ns1__ChequeDelivery1Code__RGFA = 11
};
#endif

/* pain.h:481 */
#ifndef SOAP_TYPE_ns1__ChequeType2Code
#define SOAP_TYPE_ns1__ChequeType2Code (127)
/* ns1:ChequeType2Code */
enum ns1__ChequeType2Code {
	ns1__ChequeType2Code__CCHQ = 0,
	ns1__ChequeType2Code__CCCH = 1,
	ns1__ChequeType2Code__BCHQ = 2,
	ns1__ChequeType2Code__DRFT = 3,
	ns1__ChequeType2Code__ELDR = 4
};
#endif

/* pain.h:498 */
#ifndef SOAP_TYPE_ns1__CreditDebitCode
#define SOAP_TYPE_ns1__CreditDebitCode (129)
/* ns1:CreditDebitCode */
enum ns1__CreditDebitCode {
	ns1__CreditDebitCode__CRDT = 0,
	ns1__CreditDebitCode__DBIT = 1
};
#endif

/* pain.h:513 */
#ifndef SOAP_TYPE_ns1__DocumentType3Code
#define SOAP_TYPE_ns1__DocumentType3Code (131)
/* ns1:DocumentType3Code */
enum ns1__DocumentType3Code {
	ns1__DocumentType3Code__RADM = 0,
	ns1__DocumentType3Code__RPIN = 1,
	ns1__DocumentType3Code__FXDR = 2,
	ns1__DocumentType3Code__DISP = 3,
	ns1__DocumentType3Code__PUOR = 4,
	ns1__DocumentType3Code__SCOR = 5
};
#endif

/* pain.h:526 */
#ifndef SOAP_TYPE_ns1__DocumentType6Code
#define SOAP_TYPE_ns1__DocumentType6Code (132)
/* ns1:DocumentType6Code */
enum ns1__DocumentType6Code {
	ns1__DocumentType6Code__MSIN = 0,
	ns1__DocumentType6Code__CNFA = 1,
	ns1__DocumentType6Code__DNFA = 2,
	ns1__DocumentType6Code__CINV = 3,
	ns1__DocumentType6Code__CREN = 4,
	ns1__DocumentType6Code__DEBN = 5,
	ns1__DocumentType6Code__HIRI = 6,
	ns1__DocumentType6Code__SBIN = 7,
	ns1__DocumentType6Code__CMCN = 8,
	ns1__DocumentType6Code__SOAC = 9,
	ns1__DocumentType6Code__DISP = 10,
	ns1__DocumentType6Code__BOLD = 11,
	ns1__DocumentType6Code__VCHR = 12,
	ns1__DocumentType6Code__AROI = 13,
	ns1__DocumentType6Code__TSUT = 14,
	ns1__DocumentType6Code__PUOR = 15
};
#endif

/* pain.h:559 */
#ifndef SOAP_TYPE_ns1__ExchangeRateType1Code
#define SOAP_TYPE_ns1__ExchangeRateType1Code (135)
/* ns1:ExchangeRateType1Code */
enum ns1__ExchangeRateType1Code {
	ns1__ExchangeRateType1Code__SPOT = 0,
	ns1__ExchangeRateType1Code__SALE = 1,
	ns1__ExchangeRateType1Code__AGRD = 2
};
#endif

/* pain.h:659 */
#ifndef SOAP_TYPE_ns1__Frequency6Code
#define SOAP_TYPE_ns1__Frequency6Code (154)
/* ns1:Frequency6Code */
enum ns1__Frequency6Code {
	ns1__Frequency6Code__YEAR = 0,
	ns1__Frequency6Code__MNTH = 1,
	ns1__Frequency6Code__QURT = 2,
	ns1__Frequency6Code__MIAN = 3,
	ns1__Frequency6Code__WEEK = 4,
	ns1__Frequency6Code__DAIL = 5,
	ns1__Frequency6Code__ADHO = 6,
	ns1__Frequency6Code__INDA = 7,
	ns1__Frequency6Code__FRTN = 8
};
#endif

/* pain.h:697 */
#ifndef SOAP_TYPE_ns1__MandateClassification1Code
#define SOAP_TYPE_ns1__MandateClassification1Code (161)
/* ns1:MandateClassification1Code */
enum ns1__MandateClassification1Code {
	ns1__MandateClassification1Code__FIXE = 0,
	ns1__MandateClassification1Code__USGB = 1,
	ns1__MandateClassification1Code__VARI = 2
};
#endif

/* pain.h:767 */
#ifndef SOAP_TYPE_ns1__NamePrefix2Code
#define SOAP_TYPE_ns1__NamePrefix2Code (174)
/* ns1:NamePrefix2Code */
enum ns1__NamePrefix2Code {
	ns1__NamePrefix2Code__DOCT = 0,
	ns1__NamePrefix2Code__MADM = 1,
	ns1__NamePrefix2Code__MISS = 2,
	ns1__NamePrefix2Code__MIST = 3,
	ns1__NamePrefix2Code__MIKS = 4
};
#endif

/* pain.h:785 */
#ifndef SOAP_TYPE_ns1__PaymentMethod3Code
#define SOAP_TYPE_ns1__PaymentMethod3Code (176)
/* ns1:PaymentMethod3Code */
enum ns1__PaymentMethod3Code {
	ns1__PaymentMethod3Code__CHK = 0,
	ns1__PaymentMethod3Code__TRF = 1,
	ns1__PaymentMethod3Code__TRA = 2
};
#endif

/* pain.h:806 */
#ifndef SOAP_TYPE_ns1__PreferredContactMethod1Code
#define SOAP_TYPE_ns1__PreferredContactMethod1Code (179)
/* ns1:PreferredContactMethod1Code */
enum ns1__PreferredContactMethod1Code {
	ns1__PreferredContactMethod1Code__LETT = 0,
	ns1__PreferredContactMethod1Code__MAIL = 1,
	ns1__PreferredContactMethod1Code__PHON = 2,
	ns1__PreferredContactMethod1Code__FAXX = 3,
	ns1__PreferredContactMethod1Code__CELL = 4
};
#endif

/* pain.h:818 */
#ifndef SOAP_TYPE_ns1__Priority2Code
#define SOAP_TYPE_ns1__Priority2Code (180)
/* ns1:Priority2Code */
enum ns1__Priority2Code {
	ns1__Priority2Code__HIGH = 0,
	ns1__Priority2Code__NORM = 1
};
#endif

/* pain.h:827 */
#ifndef SOAP_TYPE_ns1__RegulatoryReportingType1Code
#define SOAP_TYPE_ns1__RegulatoryReportingType1Code (181)
/* ns1:RegulatoryReportingType1Code */
enum ns1__RegulatoryReportingType1Code {
	ns1__RegulatoryReportingType1Code__CRED = 0,
	ns1__RegulatoryReportingType1Code__DEBT = 1,
	ns1__RegulatoryReportingType1Code__BOTH = 2
};
#endif

/* pain.h:837 */
#ifndef SOAP_TYPE_ns1__RemittanceLocationMethod2Code
#define SOAP_TYPE_ns1__RemittanceLocationMethod2Code (182)
/* ns1:RemittanceLocationMethod2Code */
enum ns1__RemittanceLocationMethod2Code {
	ns1__RemittanceLocationMethod2Code__FAXI = 0,
	ns1__RemittanceLocationMethod2Code__EDIC = 1,
	ns1__RemittanceLocationMethod2Code__URID = 2,
	ns1__RemittanceLocationMethod2Code__EMAL = 3,
	ns1__RemittanceLocationMethod2Code__POST = 4,
	ns1__RemittanceLocationMethod2Code__SMSM = 5
};
#endif

/* pain.h:850 */
#ifndef SOAP_TYPE_ns1__TaxRecordPeriod1Code
#define SOAP_TYPE_ns1__TaxRecordPeriod1Code (183)
/* ns1:TaxRecordPeriod1Code */
enum ns1__TaxRecordPeriod1Code {
	ns1__TaxRecordPeriod1Code__MM01 = 0,
	ns1__TaxRecordPeriod1Code__MM02 = 1,
	ns1__TaxRecordPeriod1Code__MM03 = 2,
	ns1__TaxRecordPeriod1Code__MM04 = 3,
	ns1__TaxRecordPeriod1Code__MM05 = 4,
	ns1__TaxRecordPeriod1Code__MM06 = 5,
	ns1__TaxRecordPeriod1Code__MM07 = 6,
	ns1__TaxRecordPeriod1Code__MM08 = 7,
	ns1__TaxRecordPeriod1Code__MM09 = 8,
	ns1__TaxRecordPeriod1Code__MM10 = 9,
	ns1__TaxRecordPeriod1Code__MM11 = 10,
	ns1__TaxRecordPeriod1Code__MM12 = 11,
	ns1__TaxRecordPeriod1Code__QTR1 = 12,
	ns1__TaxRecordPeriod1Code__QTR2 = 13,
	ns1__TaxRecordPeriod1Code__QTR3 = 14,
	ns1__TaxRecordPeriod1Code__QTR4 = 15,
	ns1__TaxRecordPeriod1Code__HLF1 = 16,
	ns1__TaxRecordPeriod1Code__HLF2 = 17
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* pain.h:152 */
union _ns1__union_AccountIdentification4Choice;	/* pain.h:907 */
class ns1__AccountIdentification4Choice;	/* pain.h:176 */
union _ns1__union_AccountSchemeName1Choice;	/* pain.h:937 */
class ns1__AccountSchemeName1Choice;	/* pain.h:178 */
union _ns1__union_AddressType3Choice;	/* pain.h:967 */
class ns1__AddressType3Choice;	/* pain.h:182 */
class ns1__AdviceType1;	/* pain.h:184 */
union _ns1__union_AdviceType1Choice;	/* pain.h:1020 */
class ns1__AdviceType1Choice;	/* pain.h:186 */
union _ns1__union_AmountType4Choice;	/* pain.h:1050 */
class ns1__AmountType4Choice;	/* pain.h:188 */
union _ns1__union_Authorisation1Choice;	/* pain.h:1080 */
class ns1__Authorisation1Choice;	/* pain.h:190 */
class ns1__BranchAndFinancialInstitutionIdentification6;	/* pain.h:192 */
class ns1__BranchData3;	/* pain.h:194 */
class ns1__CashAccount40;	/* pain.h:196 */
union _ns1__union_CashAccountType2Choice;	/* pain.h:1189 */
class ns1__CashAccountType2Choice;	/* pain.h:198 */
union _ns1__union_CategoryPurpose1Choice;	/* pain.h:1219 */
class ns1__CategoryPurpose1Choice;	/* pain.h:200 */
class ns1__Cheque11;	/* pain.h:202 */
union _ns1__union_ChequeDeliveryMethod1Choice;	/* pain.h:1292 */
class ns1__ChequeDeliveryMethod1Choice;	/* pain.h:204 */
union _ns1__union_ClearingSystemIdentification2Choice;	/* pain.h:1322 */
class ns1__ClearingSystemIdentification2Choice;	/* pain.h:206 */
class ns1__ClearingSystemMemberIdentification2;	/* pain.h:208 */
class ns1__Contact4;	/* pain.h:210 */
class ns1__CreditTransferMandateData1;	/* pain.h:212 */
class ns1__CreditTransferTransaction54;	/* pain.h:214 */
class ns1__CreditorReferenceInformation2;	/* pain.h:216 */
union _ns1__union_CreditorReferenceType1Choice;	/* pain.h:1551 */
class ns1__CreditorReferenceType1Choice;	/* pain.h:218 */
class ns1__CreditorReferenceType2;	/* pain.h:220 */
class ns1__CustomerCreditTransferInitiationV11;	/* pain.h:222 */
union _ns1__union_DateAndDateTime2Choice;	/* pain.h:1629 */
class ns1__DateAndDateTime2Choice;	/* pain.h:224 */
class ns1__DateAndPlaceOfBirth1;	/* pain.h:226 */
class ns1__DatePeriod2;	/* pain.h:228 */
class ns1__DiscountAmountAndType1;	/* pain.h:230 */
union _ns1__union_DiscountAmountType1Choice;	/* pain.h:1732 */
class ns1__DiscountAmountType1Choice;	/* pain.h:232 */
class ns1__Document;	/* pain.h:234 */
class ns1__DocumentAdjustment1;	/* pain.h:236 */
class ns1__DocumentLineIdentification1;	/* pain.h:238 */
class ns1__DocumentLineInformation1;	/* pain.h:240 */
class ns1__DocumentLineType1;	/* pain.h:242 */
union _ns1__union_DocumentLineType1Choice;	/* pain.h:1883 */
class ns1__DocumentLineType1Choice;	/* pain.h:244 */
class ns1__EquivalentAmount2;	/* pain.h:246 */
class ns1__ExchangeRate1;	/* pain.h:248 */
union _ns1__union_FinancialIdentificationSchemeName1Choice;	/* pain.h:1963 */
class ns1__FinancialIdentificationSchemeName1Choice;	/* pain.h:250 */
class ns1__FinancialInstitutionIdentification18;	/* pain.h:252 */
union _ns1__union_Frequency36Choice;	/* pain.h:2024 */
class ns1__Frequency36Choice;	/* pain.h:254 */
class ns1__FrequencyAndMoment1;	/* pain.h:256 */
class ns1__FrequencyPeriod1;	/* pain.h:258 */
class ns1__Garnishment3;	/* pain.h:260 */
class ns1__GarnishmentType1;	/* pain.h:262 */
union _ns1__union_GarnishmentType1Choice;	/* pain.h:2160 */
class ns1__GarnishmentType1Choice;	/* pain.h:264 */
class ns1__GenericAccountIdentification1;	/* pain.h:266 */
class ns1__GenericFinancialIdentification1;	/* pain.h:268 */
class ns1__GenericIdentification30;	/* pain.h:270 */
class ns1__GenericOrganisationIdentification1;	/* pain.h:272 */
class ns1__GenericPersonIdentification1;	/* pain.h:274 */
class ns1__GroupHeader95;	/* pain.h:276 */
class ns1__InstructionForCreditorAgent3;	/* pain.h:278 */
class ns1__InstructionForDebtorAgent1;	/* pain.h:280 */
union _ns1__union_LocalInstrument2Choice;	/* pain.h:2396 */
class ns1__LocalInstrument2Choice;	/* pain.h:282 */
union _ns1__union_MandateClassification1Choice;	/* pain.h:2426 */
class ns1__MandateClassification1Choice;	/* pain.h:284 */
union _ns1__union_MandateSetupReason1Choice;	/* pain.h:2456 */
class ns1__MandateSetupReason1Choice;	/* pain.h:286 */
class ns1__MandateTypeInformation2;	/* pain.h:288 */
class ns1__NameAndAddress16;	/* pain.h:290 */
class ns1__OrganisationIdentification29;	/* pain.h:292 */
union _ns1__union_OrganisationIdentificationSchemeName1Choice;	/* pain.h:2561 */
class ns1__OrganisationIdentificationSchemeName1Choice;	/* pain.h:294 */
class ns1__OtherContact1;	/* pain.h:296 */
union _ns1__union_Party38Choice;	/* pain.h:2614 */
class ns1__Party38Choice;	/* pain.h:298 */
class ns1__PartyIdentification135;	/* pain.h:300 */
class ns1__PaymentIdentification6;	/* pain.h:302 */
class ns1__PaymentInitiationSource1;	/* pain.h:304 */
class ns1__PaymentInstruction40;	/* pain.h:306 */
class ns1__PaymentTypeInformation26;	/* pain.h:308 */
class ns1__PersonIdentification13;	/* pain.h:310 */
union _ns1__union_PersonIdentificationSchemeName1Choice;	/* pain.h:2830 */
class ns1__PersonIdentificationSchemeName1Choice;	/* pain.h:312 */
class ns1__PostalAddress24;	/* pain.h:314 */
class ns1__ProxyAccountIdentification1;	/* pain.h:316 */
union _ns1__union_ProxyAccountType1Choice;	/* pain.h:2934 */
class ns1__ProxyAccountType1Choice;	/* pain.h:318 */
union _ns1__union_Purpose2Choice;	/* pain.h:2964 */
class ns1__Purpose2Choice;	/* pain.h:320 */
class ns1__ReferredDocumentInformation7;	/* pain.h:322 */
union _ns1__union_ReferredDocumentType3Choice;	/* pain.h:3021 */
class ns1__ReferredDocumentType3Choice;	/* pain.h:324 */
class ns1__ReferredDocumentType4;	/* pain.h:326 */
class ns1__RegulatoryAuthority2;	/* pain.h:328 */
class ns1__RegulatoryReporting3;	/* pain.h:330 */
class ns1__RemittanceAmount2;	/* pain.h:332 */
class ns1__RemittanceAmount3;	/* pain.h:334 */
class ns1__RemittanceInformation21;	/* pain.h:336 */
class ns1__RemittanceLocation7;	/* pain.h:338 */
class ns1__RemittanceLocationData1;	/* pain.h:340 */
union _ns1__union_ServiceLevel8Choice;	/* pain.h:3255 */
class ns1__ServiceLevel8Choice;	/* pain.h:342 */
class ns1__StructuredRegulatoryReporting3;	/* pain.h:344 */
class ns1__StructuredRemittanceInformation17;	/* pain.h:346 */
class ns1__SupplementaryData1;	/* pain.h:348 */
class ns1__SupplementaryDataEnvelope1;	/* pain.h:350 */
class ns1__TaxAmount3;	/* pain.h:352 */
class ns1__TaxAmountAndType1;	/* pain.h:354 */
union _ns1__union_TaxAmountType1Choice;	/* pain.h:3450 */
class ns1__TaxAmountType1Choice;	/* pain.h:356 */
class ns1__TaxAuthorisation1;	/* pain.h:358 */
class ns1__TaxData1;	/* pain.h:360 */
class ns1__TaxInformation10;	/* pain.h:362 */
class ns1__TaxParty1;	/* pain.h:364 */
class ns1__TaxParty2;	/* pain.h:366 */
class ns1__TaxPeriod3;	/* pain.h:368 */
class ns1__TaxRecord3;	/* pain.h:370 */
class ns1__TaxRecordDetails3;	/* pain.h:372 */
class ns1__ActiveOrHistoricCurrencyAndAmount;	/* pain.h:180 */

/* pain.h:152 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:907 */
#ifndef SOAP_TYPE__ns1__union_AccountIdentification4Choice
#define SOAP_TYPE__ns1__union_AccountIdentification4Choice (186)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_AccountIdentification4Choice
{
        #define SOAP_UNION__ns1__union_AccountIdentification4Choice_IBAN	(1)	/**< union variant selector value for member IBAN */
        std::string *IBAN;
        #define SOAP_UNION__ns1__union_AccountIdentification4Choice_Othr	(2)	/**< union variant selector value for member Othr */
        ns1__GenericAccountIdentification1 *Othr;
};
#endif

/* pain.h:176 */
#ifndef SOAP_TYPE_ns1__AccountIdentification4Choice
#define SOAP_TYPE_ns1__AccountIdentification4Choice (16)
/* Choice: */
class SOAP_CMAC ns1__AccountIdentification4Choice {
      public:
        /// Union with union _ns1__union_AccountIdentification4Choice variant selector __union_AccountIdentification4Choice set to one of: SOAP_UNION__ns1__union_AccountIdentification4Choice_IBAN SOAP_UNION__ns1__union_AccountIdentification4Choice_Othr
        int __union_AccountIdentification4Choice;
        union _ns1__union_AccountIdentification4Choice union_AccountIdentification4Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountIdentification4Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AccountIdentification4Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountIdentification4Choice, default initialized and not managed by a soap context
        virtual ns1__AccountIdentification4Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AccountIdentification4Choice); }
      public:
        /// Constructor with default initializations
        ns1__AccountIdentification4Choice() : __union_AccountIdentification4Choice(), soap() { }
        virtual ~ns1__AccountIdentification4Choice() { }
        /// Friend allocator used by soap_new_ns1__AccountIdentification4Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountIdentification4Choice * SOAP_FMAC2 soap_instantiate_ns1__AccountIdentification4Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:937 */
#ifndef SOAP_TYPE__ns1__union_AccountSchemeName1Choice
#define SOAP_TYPE__ns1__union_AccountSchemeName1Choice (190)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_AccountSchemeName1Choice
{
        #define SOAP_UNION__ns1__union_AccountSchemeName1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_AccountSchemeName1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:178 */
#ifndef SOAP_TYPE_ns1__AccountSchemeName1Choice
#define SOAP_TYPE_ns1__AccountSchemeName1Choice (17)
/* Choice: */
class SOAP_CMAC ns1__AccountSchemeName1Choice {
      public:
        /// Union with union _ns1__union_AccountSchemeName1Choice variant selector __union_AccountSchemeName1Choice set to one of: SOAP_UNION__ns1__union_AccountSchemeName1Choice_Cd SOAP_UNION__ns1__union_AccountSchemeName1Choice_Prtry
        int __union_AccountSchemeName1Choice;
        union _ns1__union_AccountSchemeName1Choice union_AccountSchemeName1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountSchemeName1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AccountSchemeName1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountSchemeName1Choice, default initialized and not managed by a soap context
        virtual ns1__AccountSchemeName1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AccountSchemeName1Choice); }
      public:
        /// Constructor with default initializations
        ns1__AccountSchemeName1Choice() : __union_AccountSchemeName1Choice(), soap() { }
        virtual ~ns1__AccountSchemeName1Choice() { }
        /// Friend allocator used by soap_new_ns1__AccountSchemeName1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__AccountSchemeName1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:967 */
#ifndef SOAP_TYPE__ns1__union_AddressType3Choice
#define SOAP_TYPE__ns1__union_AddressType3Choice (193)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_AddressType3Choice
{
        #define SOAP_UNION__ns1__union_AddressType3Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__AddressType2Code Cd;
        #define SOAP_UNION__ns1__union_AddressType3Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        ns1__GenericIdentification30 *Prtry;
};
#endif

/* pain.h:182 */
#ifndef SOAP_TYPE_ns1__AddressType3Choice
#define SOAP_TYPE_ns1__AddressType3Choice (19)
/* Choice: */
class SOAP_CMAC ns1__AddressType3Choice {
      public:
        /// Union with union _ns1__union_AddressType3Choice variant selector __union_AddressType3Choice set to one of: SOAP_UNION__ns1__union_AddressType3Choice_Cd SOAP_UNION__ns1__union_AddressType3Choice_Prtry
        int __union_AddressType3Choice;
        union _ns1__union_AddressType3Choice union_AddressType3Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AddressType3Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AddressType3Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AddressType3Choice, default initialized and not managed by a soap context
        virtual ns1__AddressType3Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AddressType3Choice); }
      public:
        /// Constructor with default initializations
        ns1__AddressType3Choice() : __union_AddressType3Choice(), soap() { }
        virtual ~ns1__AddressType3Choice() { }
        /// Friend allocator used by soap_new_ns1__AddressType3Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__AddressType3Choice * SOAP_FMAC2 soap_instantiate_ns1__AddressType3Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:184 */
#ifndef SOAP_TYPE_ns1__AdviceType1
#define SOAP_TYPE_ns1__AdviceType1 (20)
/* complex XML schema type 'ns1:AdviceType1': */
class SOAP_CMAC ns1__AdviceType1 {
      public:
        /// Optional element 'CdtAdvc' of XML schema type 'ns1:AdviceType1Choice'
        ns1__AdviceType1Choice *CdtAdvc;
        /// Optional element 'DbtAdvc' of XML schema type 'ns1:AdviceType1Choice'
        ns1__AdviceType1Choice *DbtAdvc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AdviceType1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AdviceType1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AdviceType1, default initialized and not managed by a soap context
        virtual ns1__AdviceType1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AdviceType1); }
      public:
        /// Constructor with default initializations
        ns1__AdviceType1() : CdtAdvc(), DbtAdvc(), soap() { }
        virtual ~ns1__AdviceType1() { }
        /// Friend allocator used by soap_new_ns1__AdviceType1(struct soap*, int)
        friend SOAP_FMAC1 ns1__AdviceType1 * SOAP_FMAC2 soap_instantiate_ns1__AdviceType1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1020 */
#ifndef SOAP_TYPE__ns1__union_AdviceType1Choice
#define SOAP_TYPE__ns1__union_AdviceType1Choice (196)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_AdviceType1Choice
{
        #define SOAP_UNION__ns1__union_AdviceType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__AdviceType1Code Cd;
        #define SOAP_UNION__ns1__union_AdviceType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:186 */
#ifndef SOAP_TYPE_ns1__AdviceType1Choice
#define SOAP_TYPE_ns1__AdviceType1Choice (21)
/* Choice: */
class SOAP_CMAC ns1__AdviceType1Choice {
      public:
        /// Union with union _ns1__union_AdviceType1Choice variant selector __union_AdviceType1Choice set to one of: SOAP_UNION__ns1__union_AdviceType1Choice_Cd SOAP_UNION__ns1__union_AdviceType1Choice_Prtry
        int __union_AdviceType1Choice;
        union _ns1__union_AdviceType1Choice union_AdviceType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AdviceType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AdviceType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AdviceType1Choice, default initialized and not managed by a soap context
        virtual ns1__AdviceType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AdviceType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__AdviceType1Choice() : __union_AdviceType1Choice(), soap() { }
        virtual ~ns1__AdviceType1Choice() { }
        /// Friend allocator used by soap_new_ns1__AdviceType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__AdviceType1Choice * SOAP_FMAC2 soap_instantiate_ns1__AdviceType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1050 */
#ifndef SOAP_TYPE__ns1__union_AmountType4Choice
#define SOAP_TYPE__ns1__union_AmountType4Choice (197)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_AmountType4Choice
{
        #define SOAP_UNION__ns1__union_AmountType4Choice_InstdAmt	(1)	/**< union variant selector value for member InstdAmt */
        ns1__ActiveOrHistoricCurrencyAndAmount *InstdAmt;
        #define SOAP_UNION__ns1__union_AmountType4Choice_EqvtAmt	(2)	/**< union variant selector value for member EqvtAmt */
        ns1__EquivalentAmount2 *EqvtAmt;
};
#endif

/* pain.h:188 */
#ifndef SOAP_TYPE_ns1__AmountType4Choice
#define SOAP_TYPE_ns1__AmountType4Choice (22)
/* Choice: */
class SOAP_CMAC ns1__AmountType4Choice {
      public:
        /// Union with union _ns1__union_AmountType4Choice variant selector __union_AmountType4Choice set to one of: SOAP_UNION__ns1__union_AmountType4Choice_InstdAmt SOAP_UNION__ns1__union_AmountType4Choice_EqvtAmt
        int __union_AmountType4Choice;
        union _ns1__union_AmountType4Choice union_AmountType4Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AmountType4Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AmountType4Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AmountType4Choice, default initialized and not managed by a soap context
        virtual ns1__AmountType4Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AmountType4Choice); }
      public:
        /// Constructor with default initializations
        ns1__AmountType4Choice() : __union_AmountType4Choice(), soap() { }
        virtual ~ns1__AmountType4Choice() { }
        /// Friend allocator used by soap_new_ns1__AmountType4Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__AmountType4Choice * SOAP_FMAC2 soap_instantiate_ns1__AmountType4Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1080 */
#ifndef SOAP_TYPE__ns1__union_Authorisation1Choice
#define SOAP_TYPE__ns1__union_Authorisation1Choice (200)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_Authorisation1Choice
{
        #define SOAP_UNION__ns1__union_Authorisation1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__Authorisation1Code Cd;
        #define SOAP_UNION__ns1__union_Authorisation1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:190 */
#ifndef SOAP_TYPE_ns1__Authorisation1Choice
#define SOAP_TYPE_ns1__Authorisation1Choice (23)
/* Choice: */
class SOAP_CMAC ns1__Authorisation1Choice {
      public:
        /// Union with union _ns1__union_Authorisation1Choice variant selector __union_Authorisation1Choice set to one of: SOAP_UNION__ns1__union_Authorisation1Choice_Cd SOAP_UNION__ns1__union_Authorisation1Choice_Prtry
        int __union_Authorisation1Choice;
        union _ns1__union_Authorisation1Choice union_Authorisation1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Authorisation1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Authorisation1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Authorisation1Choice, default initialized and not managed by a soap context
        virtual ns1__Authorisation1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Authorisation1Choice); }
      public:
        /// Constructor with default initializations
        ns1__Authorisation1Choice() : __union_Authorisation1Choice(), soap() { }
        virtual ~ns1__Authorisation1Choice() { }
        /// Friend allocator used by soap_new_ns1__Authorisation1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__Authorisation1Choice * SOAP_FMAC2 soap_instantiate_ns1__Authorisation1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:192 */
#ifndef SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6
#define SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6 (24)
/* complex XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6': */
class SOAP_CMAC ns1__BranchAndFinancialInstitutionIdentification6 {
      public:
        /// Required element 'FinInstnId' of XML schema type 'ns1:FinancialInstitutionIdentification18'
        ns1__FinancialInstitutionIdentification18 *FinInstnId;
        /// Optional element 'BrnchId' of XML schema type 'ns1:BranchData3'
        ns1__BranchData3 *BrnchId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BranchAndFinancialInstitutionIdentification6, default initialized and not managed by a soap context
        virtual ns1__BranchAndFinancialInstitutionIdentification6 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BranchAndFinancialInstitutionIdentification6); }
      public:
        /// Constructor with default initializations
        ns1__BranchAndFinancialInstitutionIdentification6() : FinInstnId(), BrnchId(), soap() { }
        virtual ~ns1__BranchAndFinancialInstitutionIdentification6() { }
        /// Friend allocator used by soap_new_ns1__BranchAndFinancialInstitutionIdentification6(struct soap*, int)
        friend SOAP_FMAC1 ns1__BranchAndFinancialInstitutionIdentification6 * SOAP_FMAC2 soap_instantiate_ns1__BranchAndFinancialInstitutionIdentification6(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:194 */
#ifndef SOAP_TYPE_ns1__BranchData3
#define SOAP_TYPE_ns1__BranchData3 (25)
/* complex XML schema type 'ns1:BranchData3': */
class SOAP_CMAC ns1__BranchData3 {
      public:
        /// Optional element 'Id' of XML schema type 'ns1:Max35Text'
        std::string *Id;
        /// Optional element 'LEI' of XML schema type 'ns1:LEIIdentifier'
        std::string *LEI;
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Optional element 'PstlAdr' of XML schema type 'ns1:PostalAddress24'
        ns1__PostalAddress24 *PstlAdr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BranchData3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BranchData3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BranchData3, default initialized and not managed by a soap context
        virtual ns1__BranchData3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BranchData3); }
      public:
        /// Constructor with default initializations
        ns1__BranchData3() : Id(), LEI(), Nm(), PstlAdr(), soap() { }
        virtual ~ns1__BranchData3() { }
        /// Friend allocator used by soap_new_ns1__BranchData3(struct soap*, int)
        friend SOAP_FMAC1 ns1__BranchData3 * SOAP_FMAC2 soap_instantiate_ns1__BranchData3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:196 */
#ifndef SOAP_TYPE_ns1__CashAccount40
#define SOAP_TYPE_ns1__CashAccount40 (26)
/* complex XML schema type 'ns1:CashAccount40': */
class SOAP_CMAC ns1__CashAccount40 {
      public:
        /// Optional element 'Id' of XML schema type 'ns1:AccountIdentification4Choice'
        ns1__AccountIdentification4Choice *Id;
        /// Optional element 'Tp' of XML schema type 'ns1:CashAccountType2Choice'
        ns1__CashAccountType2Choice *Tp;
        /// Optional element 'Ccy' of XML schema type 'ns1:ActiveOrHistoricCurrencyCode'
        std::string *Ccy;
        /// Optional element 'Nm' of XML schema type 'ns1:Max70Text'
        std::string *Nm;
        /// Optional element 'Prxy' of XML schema type 'ns1:ProxyAccountIdentification1'
        ns1__ProxyAccountIdentification1 *Prxy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashAccount40
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CashAccount40; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashAccount40, default initialized and not managed by a soap context
        virtual ns1__CashAccount40 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CashAccount40); }
      public:
        /// Constructor with default initializations
        ns1__CashAccount40() : Id(), Tp(), Ccy(), Nm(), Prxy(), soap() { }
        virtual ~ns1__CashAccount40() { }
        /// Friend allocator used by soap_new_ns1__CashAccount40(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashAccount40 * SOAP_FMAC2 soap_instantiate_ns1__CashAccount40(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1189 */
#ifndef SOAP_TYPE__ns1__union_CashAccountType2Choice
#define SOAP_TYPE__ns1__union_CashAccountType2Choice (212)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_CashAccountType2Choice
{
        #define SOAP_UNION__ns1__union_CashAccountType2Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_CashAccountType2Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:198 */
#ifndef SOAP_TYPE_ns1__CashAccountType2Choice
#define SOAP_TYPE_ns1__CashAccountType2Choice (27)
/* Choice: */
class SOAP_CMAC ns1__CashAccountType2Choice {
      public:
        /// Union with union _ns1__union_CashAccountType2Choice variant selector __union_CashAccountType2Choice set to one of: SOAP_UNION__ns1__union_CashAccountType2Choice_Cd SOAP_UNION__ns1__union_CashAccountType2Choice_Prtry
        int __union_CashAccountType2Choice;
        union _ns1__union_CashAccountType2Choice union_CashAccountType2Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashAccountType2Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CashAccountType2Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashAccountType2Choice, default initialized and not managed by a soap context
        virtual ns1__CashAccountType2Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CashAccountType2Choice); }
      public:
        /// Constructor with default initializations
        ns1__CashAccountType2Choice() : __union_CashAccountType2Choice(), soap() { }
        virtual ~ns1__CashAccountType2Choice() { }
        /// Friend allocator used by soap_new_ns1__CashAccountType2Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashAccountType2Choice * SOAP_FMAC2 soap_instantiate_ns1__CashAccountType2Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1219 */
#ifndef SOAP_TYPE__ns1__union_CategoryPurpose1Choice
#define SOAP_TYPE__ns1__union_CategoryPurpose1Choice (214)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_CategoryPurpose1Choice
{
        #define SOAP_UNION__ns1__union_CategoryPurpose1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_CategoryPurpose1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:200 */
#ifndef SOAP_TYPE_ns1__CategoryPurpose1Choice
#define SOAP_TYPE_ns1__CategoryPurpose1Choice (28)
/* Choice: */
class SOAP_CMAC ns1__CategoryPurpose1Choice {
      public:
        /// Union with union _ns1__union_CategoryPurpose1Choice variant selector __union_CategoryPurpose1Choice set to one of: SOAP_UNION__ns1__union_CategoryPurpose1Choice_Cd SOAP_UNION__ns1__union_CategoryPurpose1Choice_Prtry
        int __union_CategoryPurpose1Choice;
        union _ns1__union_CategoryPurpose1Choice union_CategoryPurpose1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CategoryPurpose1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CategoryPurpose1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CategoryPurpose1Choice, default initialized and not managed by a soap context
        virtual ns1__CategoryPurpose1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CategoryPurpose1Choice); }
      public:
        /// Constructor with default initializations
        ns1__CategoryPurpose1Choice() : __union_CategoryPurpose1Choice(), soap() { }
        virtual ~ns1__CategoryPurpose1Choice() { }
        /// Friend allocator used by soap_new_ns1__CategoryPurpose1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__CategoryPurpose1Choice * SOAP_FMAC2 soap_instantiate_ns1__CategoryPurpose1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:202 */
#ifndef SOAP_TYPE_ns1__Cheque11
#define SOAP_TYPE_ns1__Cheque11 (29)
/* complex XML schema type 'ns1:Cheque11': */
class SOAP_CMAC ns1__Cheque11 {
      public:
        /// Optional element 'ChqTp' of XML schema type 'ns1:ChequeType2Code'
        enum ns1__ChequeType2Code *ChqTp;
        /// Optional element 'ChqNb' of XML schema type 'ns1:Max35Text'
        std::string *ChqNb;
        /// Optional element 'ChqFr' of XML schema type 'ns1:NameAndAddress16'
        ns1__NameAndAddress16 *ChqFr;
        /// Optional element 'DlvryMtd' of XML schema type 'ns1:ChequeDeliveryMethod1Choice'
        ns1__ChequeDeliveryMethod1Choice *DlvryMtd;
        /// Optional element 'DlvrTo' of XML schema type 'ns1:NameAndAddress16'
        ns1__NameAndAddress16 *DlvrTo;
        /// Optional element 'InstrPrty' of XML schema type 'ns1:Priority2Code'
        enum ns1__Priority2Code *InstrPrty;
        /// Optional element 'ChqMtrtyDt' of XML schema type 'ns1:ISODate'
        std::string *ChqMtrtyDt;
        /// Optional element 'FrmsCd' of XML schema type 'ns1:Max35Text'
        std::string *FrmsCd;
        /// Sequence of 0 to 2 elements 'MemoFld' of XML schema type 'ns1:Max35Text'
        std::vector<std::string> MemoFld;
        /// Optional element 'RgnlClrZone' of XML schema type 'ns1:Max35Text'
        std::string *RgnlClrZone;
        /// Optional element 'PrtLctn' of XML schema type 'ns1:Max35Text'
        std::string *PrtLctn;
        /// Sequence of 0 to 5 elements 'Sgntr' of XML schema type 'ns1:Max70Text'
        std::vector<std::string> Sgntr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Cheque11
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Cheque11; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Cheque11, default initialized and not managed by a soap context
        virtual ns1__Cheque11 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Cheque11); }
      public:
        /// Constructor with default initializations
        ns1__Cheque11() : ChqTp(), ChqNb(), ChqFr(), DlvryMtd(), DlvrTo(), InstrPrty(), ChqMtrtyDt(), FrmsCd(), MemoFld(), RgnlClrZone(), PrtLctn(), Sgntr(), soap() { }
        virtual ~ns1__Cheque11() { }
        /// Friend allocator used by soap_new_ns1__Cheque11(struct soap*, int)
        friend SOAP_FMAC1 ns1__Cheque11 * SOAP_FMAC2 soap_instantiate_ns1__Cheque11(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1292 */
#ifndef SOAP_TYPE__ns1__union_ChequeDeliveryMethod1Choice
#define SOAP_TYPE__ns1__union_ChequeDeliveryMethod1Choice (223)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_ChequeDeliveryMethod1Choice
{
        #define SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__ChequeDelivery1Code Cd;
        #define SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:204 */
#ifndef SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice
#define SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice (30)
/* Choice: */
class SOAP_CMAC ns1__ChequeDeliveryMethod1Choice {
      public:
        /// Union with union _ns1__union_ChequeDeliveryMethod1Choice variant selector __union_ChequeDeliveryMethod1Choice set to one of: SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Cd SOAP_UNION__ns1__union_ChequeDeliveryMethod1Choice_Prtry
        int __union_ChequeDeliveryMethod1Choice;
        union _ns1__union_ChequeDeliveryMethod1Choice union_ChequeDeliveryMethod1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ChequeDeliveryMethod1Choice, default initialized and not managed by a soap context
        virtual ns1__ChequeDeliveryMethod1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ChequeDeliveryMethod1Choice); }
      public:
        /// Constructor with default initializations
        ns1__ChequeDeliveryMethod1Choice() : __union_ChequeDeliveryMethod1Choice(), soap() { }
        virtual ~ns1__ChequeDeliveryMethod1Choice() { }
        /// Friend allocator used by soap_new_ns1__ChequeDeliveryMethod1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__ChequeDeliveryMethod1Choice * SOAP_FMAC2 soap_instantiate_ns1__ChequeDeliveryMethod1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1322 */
#ifndef SOAP_TYPE__ns1__union_ClearingSystemIdentification2Choice
#define SOAP_TYPE__ns1__union_ClearingSystemIdentification2Choice (224)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_ClearingSystemIdentification2Choice
{
        #define SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:206 */
#ifndef SOAP_TYPE_ns1__ClearingSystemIdentification2Choice
#define SOAP_TYPE_ns1__ClearingSystemIdentification2Choice (31)
/* Choice: */
class SOAP_CMAC ns1__ClearingSystemIdentification2Choice {
      public:
        /// Union with union _ns1__union_ClearingSystemIdentification2Choice variant selector __union_ClearingSystemIdentification2Choice set to one of: SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Cd SOAP_UNION__ns1__union_ClearingSystemIdentification2Choice_Prtry
        int __union_ClearingSystemIdentification2Choice;
        union _ns1__union_ClearingSystemIdentification2Choice union_ClearingSystemIdentification2Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ClearingSystemIdentification2Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ClearingSystemIdentification2Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ClearingSystemIdentification2Choice, default initialized and not managed by a soap context
        virtual ns1__ClearingSystemIdentification2Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ClearingSystemIdentification2Choice); }
      public:
        /// Constructor with default initializations
        ns1__ClearingSystemIdentification2Choice() : __union_ClearingSystemIdentification2Choice(), soap() { }
        virtual ~ns1__ClearingSystemIdentification2Choice() { }
        /// Friend allocator used by soap_new_ns1__ClearingSystemIdentification2Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__ClearingSystemIdentification2Choice * SOAP_FMAC2 soap_instantiate_ns1__ClearingSystemIdentification2Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:208 */
#ifndef SOAP_TYPE_ns1__ClearingSystemMemberIdentification2
#define SOAP_TYPE_ns1__ClearingSystemMemberIdentification2 (32)
/* complex XML schema type 'ns1:ClearingSystemMemberIdentification2': */
class SOAP_CMAC ns1__ClearingSystemMemberIdentification2 {
      public:
        /// Optional element 'ClrSysId' of XML schema type 'ns1:ClearingSystemIdentification2Choice'
        ns1__ClearingSystemIdentification2Choice *ClrSysId;
        /// Required element 'MmbId' of XML schema type 'ns1:Max35Text'
        std::string MmbId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ClearingSystemMemberIdentification2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ClearingSystemMemberIdentification2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ClearingSystemMemberIdentification2, default initialized and not managed by a soap context
        virtual ns1__ClearingSystemMemberIdentification2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ClearingSystemMemberIdentification2); }
      public:
        /// Constructor with default initializations
        ns1__ClearingSystemMemberIdentification2() : ClrSysId(), MmbId(), soap() { }
        virtual ~ns1__ClearingSystemMemberIdentification2() { }
        /// Friend allocator used by soap_new_ns1__ClearingSystemMemberIdentification2(struct soap*, int)
        friend SOAP_FMAC1 ns1__ClearingSystemMemberIdentification2 * SOAP_FMAC2 soap_instantiate_ns1__ClearingSystemMemberIdentification2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:210 */
#ifndef SOAP_TYPE_ns1__Contact4
#define SOAP_TYPE_ns1__Contact4 (33)
/* complex XML schema type 'ns1:Contact4': */
class SOAP_CMAC ns1__Contact4 {
      public:
        /// Optional element 'NmPrfx' of XML schema type 'ns1:NamePrefix2Code'
        enum ns1__NamePrefix2Code *NmPrfx;
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Optional element 'PhneNb' of XML schema type 'ns1:PhoneNumber'
        std::string *PhneNb;
        /// Optional element 'MobNb' of XML schema type 'ns1:PhoneNumber'
        std::string *MobNb;
        /// Optional element 'FaxNb' of XML schema type 'ns1:PhoneNumber'
        std::string *FaxNb;
        /// Optional element 'EmailAdr' of XML schema type 'ns1:Max2048Text'
        std::string *EmailAdr;
        /// Optional element 'EmailPurp' of XML schema type 'ns1:Max35Text'
        std::string *EmailPurp;
        /// Optional element 'JobTitl' of XML schema type 'ns1:Max35Text'
        std::string *JobTitl;
        /// Optional element 'Rspnsblty' of XML schema type 'ns1:Max35Text'
        std::string *Rspnsblty;
        /// Optional element 'Dept' of XML schema type 'ns1:Max70Text'
        std::string *Dept;
        /// Optional element 'Othr' of XML schema type 'ns1:OtherContact1'
        std::vector<ns1__OtherContact1 *> Othr;
        /// Optional element 'PrefrdMtd' of XML schema type 'ns1:PreferredContactMethod1Code'
        enum ns1__PreferredContactMethod1Code *PrefrdMtd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Contact4
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Contact4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Contact4, default initialized and not managed by a soap context
        virtual ns1__Contact4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Contact4); }
      public:
        /// Constructor with default initializations
        ns1__Contact4() : NmPrfx(), Nm(), PhneNb(), MobNb(), FaxNb(), EmailAdr(), EmailPurp(), JobTitl(), Rspnsblty(), Dept(), Othr(), PrefrdMtd(), soap() { }
        virtual ~ns1__Contact4() { }
        /// Friend allocator used by soap_new_ns1__Contact4(struct soap*, int)
        friend SOAP_FMAC1 ns1__Contact4 * SOAP_FMAC2 soap_instantiate_ns1__Contact4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:212 */
#ifndef SOAP_TYPE_ns1__CreditTransferMandateData1
#define SOAP_TYPE_ns1__CreditTransferMandateData1 (34)
/* complex XML schema type 'ns1:CreditTransferMandateData1': */
class SOAP_CMAC ns1__CreditTransferMandateData1 {
      public:
        /// Optional element 'MndtId' of XML schema type 'ns1:Max35Text'
        std::string *MndtId;
        /// Optional element 'Tp' of XML schema type 'ns1:MandateTypeInformation2'
        ns1__MandateTypeInformation2 *Tp;
        /// Optional element 'DtOfSgntr' of XML schema type 'ns1:ISODate'
        std::string *DtOfSgntr;
        /// Optional element 'DtOfVrfctn' of XML schema type 'ns1:ISODateTime'
        time_t *DtOfVrfctn;
        /// Optional element 'ElctrncSgntr' of XML schema type 'ns1:Max10KBinary'
        xsd__base64Binary *ElctrncSgntr;
        /// Optional element 'FrstPmtDt' of XML schema type 'ns1:ISODate'
        std::string *FrstPmtDt;
        /// Optional element 'FnlPmtDt' of XML schema type 'ns1:ISODate'
        std::string *FnlPmtDt;
        /// Optional element 'Frqcy' of XML schema type 'ns1:Frequency36Choice'
        ns1__Frequency36Choice *Frqcy;
        /// Optional element 'Rsn' of XML schema type 'ns1:MandateSetupReason1Choice'
        ns1__MandateSetupReason1Choice *Rsn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreditTransferMandateData1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CreditTransferMandateData1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreditTransferMandateData1, default initialized and not managed by a soap context
        virtual ns1__CreditTransferMandateData1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CreditTransferMandateData1); }
      public:
        /// Constructor with default initializations
        ns1__CreditTransferMandateData1() : MndtId(), Tp(), DtOfSgntr(), DtOfVrfctn(), ElctrncSgntr(), FrstPmtDt(), FnlPmtDt(), Frqcy(), Rsn(), soap() { }
        virtual ~ns1__CreditTransferMandateData1() { }
        /// Friend allocator used by soap_new_ns1__CreditTransferMandateData1(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreditTransferMandateData1 * SOAP_FMAC2 soap_instantiate_ns1__CreditTransferMandateData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:214 */
#ifndef SOAP_TYPE_ns1__CreditTransferTransaction54
#define SOAP_TYPE_ns1__CreditTransferTransaction54 (35)
/* complex XML schema type 'ns1:CreditTransferTransaction54': */
class SOAP_CMAC ns1__CreditTransferTransaction54 {
      public:
        /// Required element 'PmtId' of XML schema type 'ns1:PaymentIdentification6'
        ns1__PaymentIdentification6 *PmtId;
        /// Optional element 'PmtTpInf' of XML schema type 'ns1:PaymentTypeInformation26'
        ns1__PaymentTypeInformation26 *PmtTpInf;
        /// Required element 'Amt' of XML schema type 'ns1:AmountType4Choice'
        ns1__AmountType4Choice *Amt;
        /// Optional element 'XchgRateInf' of XML schema type 'ns1:ExchangeRate1'
        ns1__ExchangeRate1 *XchgRateInf;
        /// Optional element 'ChrgBr' of XML schema type 'ns1:ChargeBearerType1Code'
        enum ns1__ChargeBearerType1Code *ChrgBr;
        /// Optional element 'MndtRltdInf' of XML schema type 'ns1:CreditTransferMandateData1'
        ns1__CreditTransferMandateData1 *MndtRltdInf;
        /// Optional element 'ChqInstr' of XML schema type 'ns1:Cheque11'
        ns1__Cheque11 *ChqInstr;
        /// Optional element 'UltmtDbtr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *UltmtDbtr;
        /// Optional element 'IntrmyAgt1' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *IntrmyAgt1;
        /// Optional element 'IntrmyAgt1Acct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *IntrmyAgt1Acct;
        /// Optional element 'IntrmyAgt2' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *IntrmyAgt2;
        /// Optional element 'IntrmyAgt2Acct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *IntrmyAgt2Acct;
        /// Optional element 'IntrmyAgt3' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *IntrmyAgt3;
        /// Optional element 'IntrmyAgt3Acct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *IntrmyAgt3Acct;
        /// Optional element 'CdtrAgt' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *CdtrAgt;
        /// Optional element 'CdtrAgtAcct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *CdtrAgtAcct;
        /// Optional element 'Cdtr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *Cdtr;
        /// Optional element 'CdtrAcct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *CdtrAcct;
        /// Optional element 'UltmtCdtr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *UltmtCdtr;
        /// Optional element 'InstrForCdtrAgt' of XML schema type 'ns1:InstructionForCreditorAgent3'
        std::vector<ns1__InstructionForCreditorAgent3 *> InstrForCdtrAgt;
        /// Optional element 'InstrForDbtrAgt' of XML schema type 'ns1:InstructionForDebtorAgent1'
        ns1__InstructionForDebtorAgent1 *InstrForDbtrAgt;
        /// Optional element 'Purp' of XML schema type 'ns1:Purpose2Choice'
        ns1__Purpose2Choice *Purp;
        /// Sequence of 0 to 10 elements 'RgltryRptg' of XML schema type 'ns1:RegulatoryReporting3'
        std::vector<ns1__RegulatoryReporting3 *> RgltryRptg;
        /// Optional element 'Tax' of XML schema type 'ns1:TaxInformation10'
        ns1__TaxInformation10 *Tax;
        /// Sequence of 0 to 10 elements 'RltdRmtInf' of XML schema type 'ns1:RemittanceLocation7'
        std::vector<ns1__RemittanceLocation7 *> RltdRmtInf;
        /// Optional element 'RmtInf' of XML schema type 'ns1:RemittanceInformation21'
        ns1__RemittanceInformation21 *RmtInf;
        /// Optional element 'SplmtryData' of XML schema type 'ns1:SupplementaryData1'
        std::vector<ns1__SupplementaryData1 *> SplmtryData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreditTransferTransaction54
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CreditTransferTransaction54; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreditTransferTransaction54, default initialized and not managed by a soap context
        virtual ns1__CreditTransferTransaction54 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CreditTransferTransaction54); }
      public:
        /// Constructor with default initializations
        ns1__CreditTransferTransaction54() : PmtId(), PmtTpInf(), Amt(), XchgRateInf(), ChrgBr(), MndtRltdInf(), ChqInstr(), UltmtDbtr(), IntrmyAgt1(), IntrmyAgt1Acct(), IntrmyAgt2(), IntrmyAgt2Acct(), IntrmyAgt3(), IntrmyAgt3Acct(), CdtrAgt(), CdtrAgtAcct(), Cdtr(), CdtrAcct(), UltmtCdtr(), InstrForCdtrAgt(), InstrForDbtrAgt(), Purp(), RgltryRptg(), Tax(), RltdRmtInf(), RmtInf(), SplmtryData(), soap() { }
        virtual ~ns1__CreditTransferTransaction54() { }
        /// Friend allocator used by soap_new_ns1__CreditTransferTransaction54(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreditTransferTransaction54 * SOAP_FMAC2 soap_instantiate_ns1__CreditTransferTransaction54(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:216 */
#ifndef SOAP_TYPE_ns1__CreditorReferenceInformation2
#define SOAP_TYPE_ns1__CreditorReferenceInformation2 (36)
/* complex XML schema type 'ns1:CreditorReferenceInformation2': */
class SOAP_CMAC ns1__CreditorReferenceInformation2 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:CreditorReferenceType2'
        ns1__CreditorReferenceType2 *Tp;
        /// Optional element 'Ref' of XML schema type 'ns1:Max35Text'
        std::string *Ref;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreditorReferenceInformation2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CreditorReferenceInformation2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreditorReferenceInformation2, default initialized and not managed by a soap context
        virtual ns1__CreditorReferenceInformation2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CreditorReferenceInformation2); }
      public:
        /// Constructor with default initializations
        ns1__CreditorReferenceInformation2() : Tp(), Ref(), soap() { }
        virtual ~ns1__CreditorReferenceInformation2() { }
        /// Friend allocator used by soap_new_ns1__CreditorReferenceInformation2(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreditorReferenceInformation2 * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceInformation2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1551 */
#ifndef SOAP_TYPE__ns1__union_CreditorReferenceType1Choice
#define SOAP_TYPE__ns1__union_CreditorReferenceType1Choice (261)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_CreditorReferenceType1Choice
{
        #define SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__DocumentType3Code Cd;
        #define SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:218 */
#ifndef SOAP_TYPE_ns1__CreditorReferenceType1Choice
#define SOAP_TYPE_ns1__CreditorReferenceType1Choice (37)
/* Choice: */
class SOAP_CMAC ns1__CreditorReferenceType1Choice {
      public:
        /// Union with union _ns1__union_CreditorReferenceType1Choice variant selector __union_CreditorReferenceType1Choice set to one of: SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Cd SOAP_UNION__ns1__union_CreditorReferenceType1Choice_Prtry
        int __union_CreditorReferenceType1Choice;
        union _ns1__union_CreditorReferenceType1Choice union_CreditorReferenceType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreditorReferenceType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CreditorReferenceType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreditorReferenceType1Choice, default initialized and not managed by a soap context
        virtual ns1__CreditorReferenceType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CreditorReferenceType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__CreditorReferenceType1Choice() : __union_CreditorReferenceType1Choice(), soap() { }
        virtual ~ns1__CreditorReferenceType1Choice() { }
        /// Friend allocator used by soap_new_ns1__CreditorReferenceType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreditorReferenceType1Choice * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:220 */
#ifndef SOAP_TYPE_ns1__CreditorReferenceType2
#define SOAP_TYPE_ns1__CreditorReferenceType2 (38)
/* complex XML schema type 'ns1:CreditorReferenceType2': */
class SOAP_CMAC ns1__CreditorReferenceType2 {
      public:
        /// Required element 'CdOrPrtry' of XML schema type 'ns1:CreditorReferenceType1Choice'
        ns1__CreditorReferenceType1Choice *CdOrPrtry;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreditorReferenceType2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CreditorReferenceType2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreditorReferenceType2, default initialized and not managed by a soap context
        virtual ns1__CreditorReferenceType2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CreditorReferenceType2); }
      public:
        /// Constructor with default initializations
        ns1__CreditorReferenceType2() : CdOrPrtry(), Issr(), soap() { }
        virtual ~ns1__CreditorReferenceType2() { }
        /// Friend allocator used by soap_new_ns1__CreditorReferenceType2(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreditorReferenceType2 * SOAP_FMAC2 soap_instantiate_ns1__CreditorReferenceType2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:222 */
#ifndef SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11
#define SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11 (39)
/* complex XML schema type 'ns1:CustomerCreditTransferInitiationV11': */
class SOAP_CMAC ns1__CustomerCreditTransferInitiationV11 {
      public:
        /// Required element 'GrpHdr' of XML schema type 'ns1:GroupHeader95'
        ns1__GroupHeader95 *GrpHdr;
        /// Required element 'PmtInf' of XML schema type 'ns1:PaymentInstruction40'
        std::vector<ns1__PaymentInstruction40 *> PmtInf;
        /// Optional element 'SplmtryData' of XML schema type 'ns1:SupplementaryData1'
        std::vector<ns1__SupplementaryData1 *> SplmtryData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CustomerCreditTransferInitiationV11, default initialized and not managed by a soap context
        virtual ns1__CustomerCreditTransferInitiationV11 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CustomerCreditTransferInitiationV11); }
      public:
        /// Constructor with default initializations
        ns1__CustomerCreditTransferInitiationV11() : GrpHdr(), PmtInf(), SplmtryData(), soap() { }
        virtual ~ns1__CustomerCreditTransferInitiationV11() { }
        /// Friend allocator used by soap_new_ns1__CustomerCreditTransferInitiationV11(struct soap*, int)
        friend SOAP_FMAC1 ns1__CustomerCreditTransferInitiationV11 * SOAP_FMAC2 soap_instantiate_ns1__CustomerCreditTransferInitiationV11(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1629 */
#ifndef SOAP_TYPE__ns1__union_DateAndDateTime2Choice
#define SOAP_TYPE__ns1__union_DateAndDateTime2Choice (266)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_DateAndDateTime2Choice
{
        #define SOAP_UNION__ns1__union_DateAndDateTime2Choice_Dt	(1)	/**< union variant selector value for member Dt */
        std::string *Dt;
        #define SOAP_UNION__ns1__union_DateAndDateTime2Choice_DtTm	(2)	/**< union variant selector value for member DtTm */
        time_t *DtTm;
};
#endif

/* pain.h:224 */
#ifndef SOAP_TYPE_ns1__DateAndDateTime2Choice
#define SOAP_TYPE_ns1__DateAndDateTime2Choice (40)
/* Choice: */
class SOAP_CMAC ns1__DateAndDateTime2Choice {
      public:
        /// Union with union _ns1__union_DateAndDateTime2Choice variant selector __union_DateAndDateTime2Choice set to one of: SOAP_UNION__ns1__union_DateAndDateTime2Choice_Dt SOAP_UNION__ns1__union_DateAndDateTime2Choice_DtTm
        int __union_DateAndDateTime2Choice;
        union _ns1__union_DateAndDateTime2Choice union_DateAndDateTime2Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DateAndDateTime2Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DateAndDateTime2Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DateAndDateTime2Choice, default initialized and not managed by a soap context
        virtual ns1__DateAndDateTime2Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DateAndDateTime2Choice); }
      public:
        /// Constructor with default initializations
        ns1__DateAndDateTime2Choice() : __union_DateAndDateTime2Choice(), soap() { }
        virtual ~ns1__DateAndDateTime2Choice() { }
        /// Friend allocator used by soap_new_ns1__DateAndDateTime2Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__DateAndDateTime2Choice * SOAP_FMAC2 soap_instantiate_ns1__DateAndDateTime2Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:226 */
#ifndef SOAP_TYPE_ns1__DateAndPlaceOfBirth1
#define SOAP_TYPE_ns1__DateAndPlaceOfBirth1 (41)
/* complex XML schema type 'ns1:DateAndPlaceOfBirth1': */
class SOAP_CMAC ns1__DateAndPlaceOfBirth1 {
      public:
        /// Required element 'BirthDt' of XML schema type 'ns1:ISODate'
        std::string BirthDt;
        /// Optional element 'PrvcOfBirth' of XML schema type 'ns1:Max35Text'
        std::string *PrvcOfBirth;
        /// Required element 'CityOfBirth' of XML schema type 'ns1:Max35Text'
        std::string CityOfBirth;
        /// Required element 'CtryOfBirth' of XML schema type 'ns1:CountryCode'
        std::string CtryOfBirth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DateAndPlaceOfBirth1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DateAndPlaceOfBirth1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DateAndPlaceOfBirth1, default initialized and not managed by a soap context
        virtual ns1__DateAndPlaceOfBirth1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DateAndPlaceOfBirth1); }
      public:
        /// Constructor with default initializations
        ns1__DateAndPlaceOfBirth1() : BirthDt(), PrvcOfBirth(), CityOfBirth(), CtryOfBirth(), soap() { }
        virtual ~ns1__DateAndPlaceOfBirth1() { }
        /// Friend allocator used by soap_new_ns1__DateAndPlaceOfBirth1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DateAndPlaceOfBirth1 * SOAP_FMAC2 soap_instantiate_ns1__DateAndPlaceOfBirth1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:228 */
#ifndef SOAP_TYPE_ns1__DatePeriod2
#define SOAP_TYPE_ns1__DatePeriod2 (42)
/* complex XML schema type 'ns1:DatePeriod2': */
class SOAP_CMAC ns1__DatePeriod2 {
      public:
        /// Required element 'FrDt' of XML schema type 'ns1:ISODate'
        std::string FrDt;
        /// Required element 'ToDt' of XML schema type 'ns1:ISODate'
        std::string ToDt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DatePeriod2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DatePeriod2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DatePeriod2, default initialized and not managed by a soap context
        virtual ns1__DatePeriod2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DatePeriod2); }
      public:
        /// Constructor with default initializations
        ns1__DatePeriod2() : FrDt(), ToDt(), soap() { }
        virtual ~ns1__DatePeriod2() { }
        /// Friend allocator used by soap_new_ns1__DatePeriod2(struct soap*, int)
        friend SOAP_FMAC1 ns1__DatePeriod2 * SOAP_FMAC2 soap_instantiate_ns1__DatePeriod2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:230 */
#ifndef SOAP_TYPE_ns1__DiscountAmountAndType1
#define SOAP_TYPE_ns1__DiscountAmountAndType1 (43)
/* complex XML schema type 'ns1:DiscountAmountAndType1': */
class SOAP_CMAC ns1__DiscountAmountAndType1 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:DiscountAmountType1Choice'
        ns1__DiscountAmountType1Choice *Tp;
        /// Required element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DiscountAmountAndType1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DiscountAmountAndType1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DiscountAmountAndType1, default initialized and not managed by a soap context
        virtual ns1__DiscountAmountAndType1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DiscountAmountAndType1); }
      public:
        /// Constructor with default initializations
        ns1__DiscountAmountAndType1() : Tp(), Amt(), soap() { }
        virtual ~ns1__DiscountAmountAndType1() { }
        /// Friend allocator used by soap_new_ns1__DiscountAmountAndType1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DiscountAmountAndType1 * SOAP_FMAC2 soap_instantiate_ns1__DiscountAmountAndType1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1732 */
#ifndef SOAP_TYPE__ns1__union_DiscountAmountType1Choice
#define SOAP_TYPE__ns1__union_DiscountAmountType1Choice (268)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_DiscountAmountType1Choice
{
        #define SOAP_UNION__ns1__union_DiscountAmountType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_DiscountAmountType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:232 */
#ifndef SOAP_TYPE_ns1__DiscountAmountType1Choice
#define SOAP_TYPE_ns1__DiscountAmountType1Choice (44)
/* Choice: */
class SOAP_CMAC ns1__DiscountAmountType1Choice {
      public:
        /// Union with union _ns1__union_DiscountAmountType1Choice variant selector __union_DiscountAmountType1Choice set to one of: SOAP_UNION__ns1__union_DiscountAmountType1Choice_Cd SOAP_UNION__ns1__union_DiscountAmountType1Choice_Prtry
        int __union_DiscountAmountType1Choice;
        union _ns1__union_DiscountAmountType1Choice union_DiscountAmountType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DiscountAmountType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DiscountAmountType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DiscountAmountType1Choice, default initialized and not managed by a soap context
        virtual ns1__DiscountAmountType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DiscountAmountType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__DiscountAmountType1Choice() : __union_DiscountAmountType1Choice(), soap() { }
        virtual ~ns1__DiscountAmountType1Choice() { }
        /// Friend allocator used by soap_new_ns1__DiscountAmountType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__DiscountAmountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__DiscountAmountType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:234 */
#ifndef SOAP_TYPE_ns1__Document
#define SOAP_TYPE_ns1__Document (45)
/* complex XML schema type 'ns1:Document': */
class SOAP_CMAC ns1__Document {
      public:
        /// Required element 'CstmrCdtTrfInitn' of XML schema type 'ns1:CustomerCreditTransferInitiationV11'
        ns1__CustomerCreditTransferInitiationV11 *CstmrCdtTrfInitn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Document
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Document; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Document, default initialized and not managed by a soap context
        virtual ns1__Document *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Document); }
      public:
        /// Constructor with default initializations
        ns1__Document() : CstmrCdtTrfInitn(), soap() { }
        virtual ~ns1__Document() { }
        /// Friend allocator used by soap_new_ns1__Document(struct soap*, int)
        friend SOAP_FMAC1 ns1__Document * SOAP_FMAC2 soap_instantiate_ns1__Document(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:236 */
#ifndef SOAP_TYPE_ns1__DocumentAdjustment1
#define SOAP_TYPE_ns1__DocumentAdjustment1 (46)
/* complex XML schema type 'ns1:DocumentAdjustment1': */
class SOAP_CMAC ns1__DocumentAdjustment1 {
      public:
        /// Required element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Optional element 'CdtDbtInd' of XML schema type 'ns1:CreditDebitCode'
        enum ns1__CreditDebitCode *CdtDbtInd;
        /// Optional element 'Rsn' of XML schema type 'ns1:Max4Text'
        std::string *Rsn;
        /// Optional element 'AddtlInf' of XML schema type 'ns1:Max140Text'
        std::string *AddtlInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DocumentAdjustment1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DocumentAdjustment1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DocumentAdjustment1, default initialized and not managed by a soap context
        virtual ns1__DocumentAdjustment1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DocumentAdjustment1); }
      public:
        /// Constructor with default initializations
        ns1__DocumentAdjustment1() : Amt(), CdtDbtInd(), Rsn(), AddtlInf(), soap() { }
        virtual ~ns1__DocumentAdjustment1() { }
        /// Friend allocator used by soap_new_ns1__DocumentAdjustment1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DocumentAdjustment1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentAdjustment1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:238 */
#ifndef SOAP_TYPE_ns1__DocumentLineIdentification1
#define SOAP_TYPE_ns1__DocumentLineIdentification1 (47)
/* complex XML schema type 'ns1:DocumentLineIdentification1': */
class SOAP_CMAC ns1__DocumentLineIdentification1 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:DocumentLineType1'
        ns1__DocumentLineType1 *Tp;
        /// Optional element 'Nb' of XML schema type 'ns1:Max35Text'
        std::string *Nb;
        /// Optional element 'RltdDt' of XML schema type 'ns1:ISODate'
        std::string *RltdDt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DocumentLineIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DocumentLineIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DocumentLineIdentification1, default initialized and not managed by a soap context
        virtual ns1__DocumentLineIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DocumentLineIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__DocumentLineIdentification1() : Tp(), Nb(), RltdDt(), soap() { }
        virtual ~ns1__DocumentLineIdentification1() { }
        /// Friend allocator used by soap_new_ns1__DocumentLineIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DocumentLineIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:240 */
#ifndef SOAP_TYPE_ns1__DocumentLineInformation1
#define SOAP_TYPE_ns1__DocumentLineInformation1 (48)
/* complex XML schema type 'ns1:DocumentLineInformation1': */
class SOAP_CMAC ns1__DocumentLineInformation1 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:DocumentLineIdentification1'
        std::vector<ns1__DocumentLineIdentification1 *> Id;
        /// Optional element 'Desc' of XML schema type 'ns1:Max2048Text'
        std::string *Desc;
        /// Optional element 'Amt' of XML schema type 'ns1:RemittanceAmount3'
        ns1__RemittanceAmount3 *Amt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DocumentLineInformation1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DocumentLineInformation1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DocumentLineInformation1, default initialized and not managed by a soap context
        virtual ns1__DocumentLineInformation1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DocumentLineInformation1); }
      public:
        /// Constructor with default initializations
        ns1__DocumentLineInformation1() : Id(), Desc(), Amt(), soap() { }
        virtual ~ns1__DocumentLineInformation1() { }
        /// Friend allocator used by soap_new_ns1__DocumentLineInformation1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DocumentLineInformation1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineInformation1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:242 */
#ifndef SOAP_TYPE_ns1__DocumentLineType1
#define SOAP_TYPE_ns1__DocumentLineType1 (49)
/* complex XML schema type 'ns1:DocumentLineType1': */
class SOAP_CMAC ns1__DocumentLineType1 {
      public:
        /// Required element 'CdOrPrtry' of XML schema type 'ns1:DocumentLineType1Choice'
        ns1__DocumentLineType1Choice *CdOrPrtry;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DocumentLineType1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DocumentLineType1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DocumentLineType1, default initialized and not managed by a soap context
        virtual ns1__DocumentLineType1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DocumentLineType1); }
      public:
        /// Constructor with default initializations
        ns1__DocumentLineType1() : CdOrPrtry(), Issr(), soap() { }
        virtual ~ns1__DocumentLineType1() { }
        /// Friend allocator used by soap_new_ns1__DocumentLineType1(struct soap*, int)
        friend SOAP_FMAC1 ns1__DocumentLineType1 * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineType1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1883 */
#ifndef SOAP_TYPE__ns1__union_DocumentLineType1Choice
#define SOAP_TYPE__ns1__union_DocumentLineType1Choice (278)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_DocumentLineType1Choice
{
        #define SOAP_UNION__ns1__union_DocumentLineType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_DocumentLineType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:244 */
#ifndef SOAP_TYPE_ns1__DocumentLineType1Choice
#define SOAP_TYPE_ns1__DocumentLineType1Choice (50)
/* Choice: */
class SOAP_CMAC ns1__DocumentLineType1Choice {
      public:
        /// Union with union _ns1__union_DocumentLineType1Choice variant selector __union_DocumentLineType1Choice set to one of: SOAP_UNION__ns1__union_DocumentLineType1Choice_Cd SOAP_UNION__ns1__union_DocumentLineType1Choice_Prtry
        int __union_DocumentLineType1Choice;
        union _ns1__union_DocumentLineType1Choice union_DocumentLineType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DocumentLineType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DocumentLineType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DocumentLineType1Choice, default initialized and not managed by a soap context
        virtual ns1__DocumentLineType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DocumentLineType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__DocumentLineType1Choice() : __union_DocumentLineType1Choice(), soap() { }
        virtual ~ns1__DocumentLineType1Choice() { }
        /// Friend allocator used by soap_new_ns1__DocumentLineType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__DocumentLineType1Choice * SOAP_FMAC2 soap_instantiate_ns1__DocumentLineType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:246 */
#ifndef SOAP_TYPE_ns1__EquivalentAmount2
#define SOAP_TYPE_ns1__EquivalentAmount2 (51)
/* complex XML schema type 'ns1:EquivalentAmount2': */
class SOAP_CMAC ns1__EquivalentAmount2 {
      public:
        /// Required element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Required element 'CcyOfTrf' of XML schema type 'ns1:ActiveOrHistoricCurrencyCode'
        std::string CcyOfTrf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquivalentAmount2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EquivalentAmount2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquivalentAmount2, default initialized and not managed by a soap context
        virtual ns1__EquivalentAmount2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EquivalentAmount2); }
      public:
        /// Constructor with default initializations
        ns1__EquivalentAmount2() : Amt(), CcyOfTrf(), soap() { }
        virtual ~ns1__EquivalentAmount2() { }
        /// Friend allocator used by soap_new_ns1__EquivalentAmount2(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquivalentAmount2 * SOAP_FMAC2 soap_instantiate_ns1__EquivalentAmount2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:248 */
#ifndef SOAP_TYPE_ns1__ExchangeRate1
#define SOAP_TYPE_ns1__ExchangeRate1 (52)
/* complex XML schema type 'ns1:ExchangeRate1': */
class SOAP_CMAC ns1__ExchangeRate1 {
      public:
        /// Optional element 'UnitCcy' of XML schema type 'ns1:ActiveOrHistoricCurrencyCode'
        std::string *UnitCcy;
        /// Optional element 'XchgRate' of XML schema type 'ns1:BaseOneRate'
        std::string *XchgRate;
        /// Optional element 'RateTp' of XML schema type 'ns1:ExchangeRateType1Code'
        enum ns1__ExchangeRateType1Code *RateTp;
        /// Optional element 'CtrctId' of XML schema type 'ns1:Max35Text'
        std::string *CtrctId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExchangeRate1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ExchangeRate1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExchangeRate1, default initialized and not managed by a soap context
        virtual ns1__ExchangeRate1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ExchangeRate1); }
      public:
        /// Constructor with default initializations
        ns1__ExchangeRate1() : UnitCcy(), XchgRate(), RateTp(), CtrctId(), soap() { }
        virtual ~ns1__ExchangeRate1() { }
        /// Friend allocator used by soap_new_ns1__ExchangeRate1(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExchangeRate1 * SOAP_FMAC2 soap_instantiate_ns1__ExchangeRate1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:1963 */
#ifndef SOAP_TYPE__ns1__union_FinancialIdentificationSchemeName1Choice
#define SOAP_TYPE__ns1__union_FinancialIdentificationSchemeName1Choice (282)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_FinancialIdentificationSchemeName1Choice
{
        #define SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:250 */
#ifndef SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice (53)
/* Choice: */
class SOAP_CMAC ns1__FinancialIdentificationSchemeName1Choice {
      public:
        /// Union with union _ns1__union_FinancialIdentificationSchemeName1Choice variant selector __union_FinancialIdentificationSchemeName1Choice set to one of: SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Cd SOAP_UNION__ns1__union_FinancialIdentificationSchemeName1Choice_Prtry
        int __union_FinancialIdentificationSchemeName1Choice;
        union _ns1__union_FinancialIdentificationSchemeName1Choice union_FinancialIdentificationSchemeName1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FinancialIdentificationSchemeName1Choice, default initialized and not managed by a soap context
        virtual ns1__FinancialIdentificationSchemeName1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FinancialIdentificationSchemeName1Choice); }
      public:
        /// Constructor with default initializations
        ns1__FinancialIdentificationSchemeName1Choice() : __union_FinancialIdentificationSchemeName1Choice(), soap() { }
        virtual ~ns1__FinancialIdentificationSchemeName1Choice() { }
        /// Friend allocator used by soap_new_ns1__FinancialIdentificationSchemeName1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__FinancialIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__FinancialIdentificationSchemeName1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:252 */
#ifndef SOAP_TYPE_ns1__FinancialInstitutionIdentification18
#define SOAP_TYPE_ns1__FinancialInstitutionIdentification18 (54)
/* complex XML schema type 'ns1:FinancialInstitutionIdentification18': */
class SOAP_CMAC ns1__FinancialInstitutionIdentification18 {
      public:
        /// Optional element 'BICFI' of XML schema type 'ns1:BICFIDec2014Identifier'
        std::string *BICFI;
        /// Optional element 'ClrSysMmbId' of XML schema type 'ns1:ClearingSystemMemberIdentification2'
        ns1__ClearingSystemMemberIdentification2 *ClrSysMmbId;
        /// Optional element 'LEI' of XML schema type 'ns1:LEIIdentifier'
        std::string *LEI;
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Optional element 'PstlAdr' of XML schema type 'ns1:PostalAddress24'
        ns1__PostalAddress24 *PstlAdr;
        /// Optional element 'Othr' of XML schema type 'ns1:GenericFinancialIdentification1'
        ns1__GenericFinancialIdentification1 *Othr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FinancialInstitutionIdentification18
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FinancialInstitutionIdentification18; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FinancialInstitutionIdentification18, default initialized and not managed by a soap context
        virtual ns1__FinancialInstitutionIdentification18 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FinancialInstitutionIdentification18); }
      public:
        /// Constructor with default initializations
        ns1__FinancialInstitutionIdentification18() : BICFI(), ClrSysMmbId(), LEI(), Nm(), PstlAdr(), Othr(), soap() { }
        virtual ~ns1__FinancialInstitutionIdentification18() { }
        /// Friend allocator used by soap_new_ns1__FinancialInstitutionIdentification18(struct soap*, int)
        friend SOAP_FMAC1 ns1__FinancialInstitutionIdentification18 * SOAP_FMAC2 soap_instantiate_ns1__FinancialInstitutionIdentification18(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2024 */
#ifndef SOAP_TYPE__ns1__union_Frequency36Choice
#define SOAP_TYPE__ns1__union_Frequency36Choice (287)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_Frequency36Choice
{
        #define SOAP_UNION__ns1__union_Frequency36Choice_Tp	(1)	/**< union variant selector value for member Tp */
        enum ns1__Frequency6Code Tp;
        #define SOAP_UNION__ns1__union_Frequency36Choice_Prd	(2)	/**< union variant selector value for member Prd */
        ns1__FrequencyPeriod1 *Prd;
        #define SOAP_UNION__ns1__union_Frequency36Choice_PtInTm	(3)	/**< union variant selector value for member PtInTm */
        ns1__FrequencyAndMoment1 *PtInTm;
};
#endif

/* pain.h:254 */
#ifndef SOAP_TYPE_ns1__Frequency36Choice
#define SOAP_TYPE_ns1__Frequency36Choice (55)
/* Choice: */
class SOAP_CMAC ns1__Frequency36Choice {
      public:
        /// Union with union _ns1__union_Frequency36Choice variant selector __union_Frequency36Choice set to one of: SOAP_UNION__ns1__union_Frequency36Choice_Tp SOAP_UNION__ns1__union_Frequency36Choice_Prd SOAP_UNION__ns1__union_Frequency36Choice_PtInTm
        int __union_Frequency36Choice;
        union _ns1__union_Frequency36Choice union_Frequency36Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Frequency36Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Frequency36Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Frequency36Choice, default initialized and not managed by a soap context
        virtual ns1__Frequency36Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Frequency36Choice); }
      public:
        /// Constructor with default initializations
        ns1__Frequency36Choice() : __union_Frequency36Choice(), soap() { }
        virtual ~ns1__Frequency36Choice() { }
        /// Friend allocator used by soap_new_ns1__Frequency36Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__Frequency36Choice * SOAP_FMAC2 soap_instantiate_ns1__Frequency36Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:256 */
#ifndef SOAP_TYPE_ns1__FrequencyAndMoment1
#define SOAP_TYPE_ns1__FrequencyAndMoment1 (56)
/* complex XML schema type 'ns1:FrequencyAndMoment1': */
class SOAP_CMAC ns1__FrequencyAndMoment1 {
      public:
        /// Required element 'Tp' of XML schema type 'ns1:Frequency6Code'
        enum ns1__Frequency6Code Tp;
        /// Required element 'PtInTm' of XML schema type 'ns1:Exact2NumericText'
        std::string PtInTm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FrequencyAndMoment1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FrequencyAndMoment1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FrequencyAndMoment1, default initialized and not managed by a soap context
        virtual ns1__FrequencyAndMoment1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FrequencyAndMoment1); }
      public:
        /// Constructor with default initializations
        ns1__FrequencyAndMoment1() : Tp(), PtInTm(), soap() { }
        virtual ~ns1__FrequencyAndMoment1() { }
        /// Friend allocator used by soap_new_ns1__FrequencyAndMoment1(struct soap*, int)
        friend SOAP_FMAC1 ns1__FrequencyAndMoment1 * SOAP_FMAC2 soap_instantiate_ns1__FrequencyAndMoment1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:258 */
#ifndef SOAP_TYPE_ns1__FrequencyPeriod1
#define SOAP_TYPE_ns1__FrequencyPeriod1 (57)
/* complex XML schema type 'ns1:FrequencyPeriod1': */
class SOAP_CMAC ns1__FrequencyPeriod1 {
      public:
        /// Required element 'Tp' of XML schema type 'ns1:Frequency6Code'
        enum ns1__Frequency6Code Tp;
        /// Required element 'CntPerPrd' of XML schema type 'ns1:DecimalNumber'
        std::string CntPerPrd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FrequencyPeriod1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FrequencyPeriod1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FrequencyPeriod1, default initialized and not managed by a soap context
        virtual ns1__FrequencyPeriod1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FrequencyPeriod1); }
      public:
        /// Constructor with default initializations
        ns1__FrequencyPeriod1() : Tp(), CntPerPrd(), soap() { }
        virtual ~ns1__FrequencyPeriod1() { }
        /// Friend allocator used by soap_new_ns1__FrequencyPeriod1(struct soap*, int)
        friend SOAP_FMAC1 ns1__FrequencyPeriod1 * SOAP_FMAC2 soap_instantiate_ns1__FrequencyPeriod1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:260 */
#ifndef SOAP_TYPE_ns1__Garnishment3
#define SOAP_TYPE_ns1__Garnishment3 (58)
/* complex XML schema type 'ns1:Garnishment3': */
class SOAP_CMAC ns1__Garnishment3 {
      public:
        /// Required element 'Tp' of XML schema type 'ns1:GarnishmentType1'
        ns1__GarnishmentType1 *Tp;
        /// Optional element 'Grnshee' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *Grnshee;
        /// Optional element 'GrnshmtAdmstr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *GrnshmtAdmstr;
        /// Optional element 'RefNb' of XML schema type 'ns1:Max140Text'
        std::string *RefNb;
        /// Optional element 'Dt' of XML schema type 'ns1:ISODate'
        std::string *Dt;
        /// Optional element 'RmtdAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *RmtdAmt;
        /// Optional element 'FmlyMdclInsrncInd' of XML schema type 'ns1:TrueFalseIndicator'
        bool *FmlyMdclInsrncInd;
        /// Optional element 'MplyeeTermntnInd' of XML schema type 'ns1:TrueFalseIndicator'
        bool *MplyeeTermntnInd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Garnishment3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Garnishment3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Garnishment3, default initialized and not managed by a soap context
        virtual ns1__Garnishment3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Garnishment3); }
      public:
        /// Constructor with default initializations
        ns1__Garnishment3() : Tp(), Grnshee(), GrnshmtAdmstr(), RefNb(), Dt(), RmtdAmt(), FmlyMdclInsrncInd(), MplyeeTermntnInd(), soap() { }
        virtual ~ns1__Garnishment3() { }
        /// Friend allocator used by soap_new_ns1__Garnishment3(struct soap*, int)
        friend SOAP_FMAC1 ns1__Garnishment3 * SOAP_FMAC2 soap_instantiate_ns1__Garnishment3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:262 */
#ifndef SOAP_TYPE_ns1__GarnishmentType1
#define SOAP_TYPE_ns1__GarnishmentType1 (59)
/* complex XML schema type 'ns1:GarnishmentType1': */
class SOAP_CMAC ns1__GarnishmentType1 {
      public:
        /// Required element 'CdOrPrtry' of XML schema type 'ns1:GarnishmentType1Choice'
        ns1__GarnishmentType1Choice *CdOrPrtry;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GarnishmentType1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GarnishmentType1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GarnishmentType1, default initialized and not managed by a soap context
        virtual ns1__GarnishmentType1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GarnishmentType1); }
      public:
        /// Constructor with default initializations
        ns1__GarnishmentType1() : CdOrPrtry(), Issr(), soap() { }
        virtual ~ns1__GarnishmentType1() { }
        /// Friend allocator used by soap_new_ns1__GarnishmentType1(struct soap*, int)
        friend SOAP_FMAC1 ns1__GarnishmentType1 * SOAP_FMAC2 soap_instantiate_ns1__GarnishmentType1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2160 */
#ifndef SOAP_TYPE__ns1__union_GarnishmentType1Choice
#define SOAP_TYPE__ns1__union_GarnishmentType1Choice (293)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_GarnishmentType1Choice
{
        #define SOAP_UNION__ns1__union_GarnishmentType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_GarnishmentType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:264 */
#ifndef SOAP_TYPE_ns1__GarnishmentType1Choice
#define SOAP_TYPE_ns1__GarnishmentType1Choice (60)
/* Choice: */
class SOAP_CMAC ns1__GarnishmentType1Choice {
      public:
        /// Union with union _ns1__union_GarnishmentType1Choice variant selector __union_GarnishmentType1Choice set to one of: SOAP_UNION__ns1__union_GarnishmentType1Choice_Cd SOAP_UNION__ns1__union_GarnishmentType1Choice_Prtry
        int __union_GarnishmentType1Choice;
        union _ns1__union_GarnishmentType1Choice union_GarnishmentType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GarnishmentType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GarnishmentType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GarnishmentType1Choice, default initialized and not managed by a soap context
        virtual ns1__GarnishmentType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GarnishmentType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__GarnishmentType1Choice() : __union_GarnishmentType1Choice(), soap() { }
        virtual ~ns1__GarnishmentType1Choice() { }
        /// Friend allocator used by soap_new_ns1__GarnishmentType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__GarnishmentType1Choice * SOAP_FMAC2 soap_instantiate_ns1__GarnishmentType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:266 */
#ifndef SOAP_TYPE_ns1__GenericAccountIdentification1
#define SOAP_TYPE_ns1__GenericAccountIdentification1 (61)
/* complex XML schema type 'ns1:GenericAccountIdentification1': */
class SOAP_CMAC ns1__GenericAccountIdentification1 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:Max34Text'
        std::string Id;
        /// Optional element 'SchmeNm' of XML schema type 'ns1:AccountSchemeName1Choice'
        ns1__AccountSchemeName1Choice *SchmeNm;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenericAccountIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenericAccountIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenericAccountIdentification1, default initialized and not managed by a soap context
        virtual ns1__GenericAccountIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenericAccountIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__GenericAccountIdentification1() : Id(), SchmeNm(), Issr(), soap() { }
        virtual ~ns1__GenericAccountIdentification1() { }
        /// Friend allocator used by soap_new_ns1__GenericAccountIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenericAccountIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericAccountIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:268 */
#ifndef SOAP_TYPE_ns1__GenericFinancialIdentification1
#define SOAP_TYPE_ns1__GenericFinancialIdentification1 (62)
/* complex XML schema type 'ns1:GenericFinancialIdentification1': */
class SOAP_CMAC ns1__GenericFinancialIdentification1 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:Max35Text'
        std::string Id;
        /// Optional element 'SchmeNm' of XML schema type 'ns1:FinancialIdentificationSchemeName1Choice'
        ns1__FinancialIdentificationSchemeName1Choice *SchmeNm;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenericFinancialIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenericFinancialIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenericFinancialIdentification1, default initialized and not managed by a soap context
        virtual ns1__GenericFinancialIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenericFinancialIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__GenericFinancialIdentification1() : Id(), SchmeNm(), Issr(), soap() { }
        virtual ~ns1__GenericFinancialIdentification1() { }
        /// Friend allocator used by soap_new_ns1__GenericFinancialIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenericFinancialIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericFinancialIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:270 */
#ifndef SOAP_TYPE_ns1__GenericIdentification30
#define SOAP_TYPE_ns1__GenericIdentification30 (63)
/* complex XML schema type 'ns1:GenericIdentification30': */
class SOAP_CMAC ns1__GenericIdentification30 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:Exact4AlphaNumericText'
        std::string Id;
        /// Required element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string Issr;
        /// Optional element 'SchmeNm' of XML schema type 'ns1:Max35Text'
        std::string *SchmeNm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenericIdentification30
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenericIdentification30; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenericIdentification30, default initialized and not managed by a soap context
        virtual ns1__GenericIdentification30 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenericIdentification30); }
      public:
        /// Constructor with default initializations
        ns1__GenericIdentification30() : Id(), Issr(), SchmeNm(), soap() { }
        virtual ~ns1__GenericIdentification30() { }
        /// Friend allocator used by soap_new_ns1__GenericIdentification30(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenericIdentification30 * SOAP_FMAC2 soap_instantiate_ns1__GenericIdentification30(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:272 */
#ifndef SOAP_TYPE_ns1__GenericOrganisationIdentification1
#define SOAP_TYPE_ns1__GenericOrganisationIdentification1 (64)
/* complex XML schema type 'ns1:GenericOrganisationIdentification1': */
class SOAP_CMAC ns1__GenericOrganisationIdentification1 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:Max35Text'
        std::string Id;
        /// Optional element 'SchmeNm' of XML schema type 'ns1:OrganisationIdentificationSchemeName1Choice'
        ns1__OrganisationIdentificationSchemeName1Choice *SchmeNm;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenericOrganisationIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenericOrganisationIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenericOrganisationIdentification1, default initialized and not managed by a soap context
        virtual ns1__GenericOrganisationIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenericOrganisationIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__GenericOrganisationIdentification1() : Id(), SchmeNm(), Issr(), soap() { }
        virtual ~ns1__GenericOrganisationIdentification1() { }
        /// Friend allocator used by soap_new_ns1__GenericOrganisationIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenericOrganisationIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericOrganisationIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:274 */
#ifndef SOAP_TYPE_ns1__GenericPersonIdentification1
#define SOAP_TYPE_ns1__GenericPersonIdentification1 (65)
/* complex XML schema type 'ns1:GenericPersonIdentification1': */
class SOAP_CMAC ns1__GenericPersonIdentification1 {
      public:
        /// Required element 'Id' of XML schema type 'ns1:Max35Text'
        std::string Id;
        /// Optional element 'SchmeNm' of XML schema type 'ns1:PersonIdentificationSchemeName1Choice'
        ns1__PersonIdentificationSchemeName1Choice *SchmeNm;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenericPersonIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenericPersonIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenericPersonIdentification1, default initialized and not managed by a soap context
        virtual ns1__GenericPersonIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenericPersonIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__GenericPersonIdentification1() : Id(), SchmeNm(), Issr(), soap() { }
        virtual ~ns1__GenericPersonIdentification1() { }
        /// Friend allocator used by soap_new_ns1__GenericPersonIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenericPersonIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__GenericPersonIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:276 */
#ifndef SOAP_TYPE_ns1__GroupHeader95
#define SOAP_TYPE_ns1__GroupHeader95 (66)
/* complex XML schema type 'ns1:GroupHeader95': */
class SOAP_CMAC ns1__GroupHeader95 {
      public:
        /// Required element 'MsgId' of XML schema type 'ns1:Max35Text'
        std::string MsgId;
        /// Required element 'CreDtTm' of XML schema type 'ns1:ISODateTime'
        time_t CreDtTm;
        /// Sequence of 0 to 2 elements 'Authstn' of XML schema type 'ns1:Authorisation1Choice'
        std::vector<ns1__Authorisation1Choice *> Authstn;
        /// Required element 'NbOfTxs' of XML schema type 'ns1:Max15NumericText'
        std::string NbOfTxs;
        /// Optional element 'CtrlSum' of XML schema type 'ns1:DecimalNumber'
        std::string *CtrlSum;
        /// Required element 'InitgPty' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *InitgPty;
        /// Optional element 'FwdgAgt' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *FwdgAgt;
        /// Optional element 'InitnSrc' of XML schema type 'ns1:PaymentInitiationSource1'
        ns1__PaymentInitiationSource1 *InitnSrc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GroupHeader95
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GroupHeader95; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GroupHeader95, default initialized and not managed by a soap context
        virtual ns1__GroupHeader95 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GroupHeader95); }
      public:
        /// Constructor with default initializations
        ns1__GroupHeader95() : MsgId(), CreDtTm(), Authstn(), NbOfTxs(), CtrlSum(), InitgPty(), FwdgAgt(), InitnSrc(), soap() { }
        virtual ~ns1__GroupHeader95() { }
        /// Friend allocator used by soap_new_ns1__GroupHeader95(struct soap*, int)
        friend SOAP_FMAC1 ns1__GroupHeader95 * SOAP_FMAC2 soap_instantiate_ns1__GroupHeader95(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:278 */
#ifndef SOAP_TYPE_ns1__InstructionForCreditorAgent3
#define SOAP_TYPE_ns1__InstructionForCreditorAgent3 (67)
/* complex XML schema type 'ns1:InstructionForCreditorAgent3': */
class SOAP_CMAC ns1__InstructionForCreditorAgent3 {
      public:
        /// Optional element 'Cd' of XML schema type 'ns1:ExternalCreditorAgentInstruction1Code'
        std::string *Cd;
        /// Optional element 'InstrInf' of XML schema type 'ns1:Max140Text'
        std::string *InstrInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InstructionForCreditorAgent3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InstructionForCreditorAgent3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InstructionForCreditorAgent3, default initialized and not managed by a soap context
        virtual ns1__InstructionForCreditorAgent3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InstructionForCreditorAgent3); }
      public:
        /// Constructor with default initializations
        ns1__InstructionForCreditorAgent3() : Cd(), InstrInf(), soap() { }
        virtual ~ns1__InstructionForCreditorAgent3() { }
        /// Friend allocator used by soap_new_ns1__InstructionForCreditorAgent3(struct soap*, int)
        friend SOAP_FMAC1 ns1__InstructionForCreditorAgent3 * SOAP_FMAC2 soap_instantiate_ns1__InstructionForCreditorAgent3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:280 */
#ifndef SOAP_TYPE_ns1__InstructionForDebtorAgent1
#define SOAP_TYPE_ns1__InstructionForDebtorAgent1 (68)
/* complex XML schema type 'ns1:InstructionForDebtorAgent1': */
class SOAP_CMAC ns1__InstructionForDebtorAgent1 {
      public:
        /// Optional element 'Cd' of XML schema type 'ns1:ExternalDebtorAgentInstruction1Code'
        std::string *Cd;
        /// Optional element 'InstrInf' of XML schema type 'ns1:Max140Text'
        std::string *InstrInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InstructionForDebtorAgent1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InstructionForDebtorAgent1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InstructionForDebtorAgent1, default initialized and not managed by a soap context
        virtual ns1__InstructionForDebtorAgent1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InstructionForDebtorAgent1); }
      public:
        /// Constructor with default initializations
        ns1__InstructionForDebtorAgent1() : Cd(), InstrInf(), soap() { }
        virtual ~ns1__InstructionForDebtorAgent1() { }
        /// Friend allocator used by soap_new_ns1__InstructionForDebtorAgent1(struct soap*, int)
        friend SOAP_FMAC1 ns1__InstructionForDebtorAgent1 * SOAP_FMAC2 soap_instantiate_ns1__InstructionForDebtorAgent1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2396 */
#ifndef SOAP_TYPE__ns1__union_LocalInstrument2Choice
#define SOAP_TYPE__ns1__union_LocalInstrument2Choice (305)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_LocalInstrument2Choice
{
        #define SOAP_UNION__ns1__union_LocalInstrument2Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_LocalInstrument2Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:282 */
#ifndef SOAP_TYPE_ns1__LocalInstrument2Choice
#define SOAP_TYPE_ns1__LocalInstrument2Choice (69)
/* Choice: */
class SOAP_CMAC ns1__LocalInstrument2Choice {
      public:
        /// Union with union _ns1__union_LocalInstrument2Choice variant selector __union_LocalInstrument2Choice set to one of: SOAP_UNION__ns1__union_LocalInstrument2Choice_Cd SOAP_UNION__ns1__union_LocalInstrument2Choice_Prtry
        int __union_LocalInstrument2Choice;
        union _ns1__union_LocalInstrument2Choice union_LocalInstrument2Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LocalInstrument2Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__LocalInstrument2Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LocalInstrument2Choice, default initialized and not managed by a soap context
        virtual ns1__LocalInstrument2Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__LocalInstrument2Choice); }
      public:
        /// Constructor with default initializations
        ns1__LocalInstrument2Choice() : __union_LocalInstrument2Choice(), soap() { }
        virtual ~ns1__LocalInstrument2Choice() { }
        /// Friend allocator used by soap_new_ns1__LocalInstrument2Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__LocalInstrument2Choice * SOAP_FMAC2 soap_instantiate_ns1__LocalInstrument2Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2426 */
#ifndef SOAP_TYPE__ns1__union_MandateClassification1Choice
#define SOAP_TYPE__ns1__union_MandateClassification1Choice (307)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_MandateClassification1Choice
{
        #define SOAP_UNION__ns1__union_MandateClassification1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__MandateClassification1Code Cd;
        #define SOAP_UNION__ns1__union_MandateClassification1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:284 */
#ifndef SOAP_TYPE_ns1__MandateClassification1Choice
#define SOAP_TYPE_ns1__MandateClassification1Choice (70)
/* Choice: */
class SOAP_CMAC ns1__MandateClassification1Choice {
      public:
        /// Union with union _ns1__union_MandateClassification1Choice variant selector __union_MandateClassification1Choice set to one of: SOAP_UNION__ns1__union_MandateClassification1Choice_Cd SOAP_UNION__ns1__union_MandateClassification1Choice_Prtry
        int __union_MandateClassification1Choice;
        union _ns1__union_MandateClassification1Choice union_MandateClassification1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MandateClassification1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MandateClassification1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MandateClassification1Choice, default initialized and not managed by a soap context
        virtual ns1__MandateClassification1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MandateClassification1Choice); }
      public:
        /// Constructor with default initializations
        ns1__MandateClassification1Choice() : __union_MandateClassification1Choice(), soap() { }
        virtual ~ns1__MandateClassification1Choice() { }
        /// Friend allocator used by soap_new_ns1__MandateClassification1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__MandateClassification1Choice * SOAP_FMAC2 soap_instantiate_ns1__MandateClassification1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2456 */
#ifndef SOAP_TYPE__ns1__union_MandateSetupReason1Choice
#define SOAP_TYPE__ns1__union_MandateSetupReason1Choice (308)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_MandateSetupReason1Choice
{
        #define SOAP_UNION__ns1__union_MandateSetupReason1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_MandateSetupReason1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:286 */
#ifndef SOAP_TYPE_ns1__MandateSetupReason1Choice
#define SOAP_TYPE_ns1__MandateSetupReason1Choice (71)
/* Choice: */
class SOAP_CMAC ns1__MandateSetupReason1Choice {
      public:
        /// Union with union _ns1__union_MandateSetupReason1Choice variant selector __union_MandateSetupReason1Choice set to one of: SOAP_UNION__ns1__union_MandateSetupReason1Choice_Cd SOAP_UNION__ns1__union_MandateSetupReason1Choice_Prtry
        int __union_MandateSetupReason1Choice;
        union _ns1__union_MandateSetupReason1Choice union_MandateSetupReason1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MandateSetupReason1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MandateSetupReason1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MandateSetupReason1Choice, default initialized and not managed by a soap context
        virtual ns1__MandateSetupReason1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MandateSetupReason1Choice); }
      public:
        /// Constructor with default initializations
        ns1__MandateSetupReason1Choice() : __union_MandateSetupReason1Choice(), soap() { }
        virtual ~ns1__MandateSetupReason1Choice() { }
        /// Friend allocator used by soap_new_ns1__MandateSetupReason1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__MandateSetupReason1Choice * SOAP_FMAC2 soap_instantiate_ns1__MandateSetupReason1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:288 */
#ifndef SOAP_TYPE_ns1__MandateTypeInformation2
#define SOAP_TYPE_ns1__MandateTypeInformation2 (72)
/* complex XML schema type 'ns1:MandateTypeInformation2': */
class SOAP_CMAC ns1__MandateTypeInformation2 {
      public:
        /// Optional element 'SvcLvl' of XML schema type 'ns1:ServiceLevel8Choice'
        ns1__ServiceLevel8Choice *SvcLvl;
        /// Optional element 'LclInstrm' of XML schema type 'ns1:LocalInstrument2Choice'
        ns1__LocalInstrument2Choice *LclInstrm;
        /// Optional element 'CtgyPurp' of XML schema type 'ns1:CategoryPurpose1Choice'
        ns1__CategoryPurpose1Choice *CtgyPurp;
        /// Optional element 'Clssfctn' of XML schema type 'ns1:MandateClassification1Choice'
        ns1__MandateClassification1Choice *Clssfctn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MandateTypeInformation2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MandateTypeInformation2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MandateTypeInformation2, default initialized and not managed by a soap context
        virtual ns1__MandateTypeInformation2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MandateTypeInformation2); }
      public:
        /// Constructor with default initializations
        ns1__MandateTypeInformation2() : SvcLvl(), LclInstrm(), CtgyPurp(), Clssfctn(), soap() { }
        virtual ~ns1__MandateTypeInformation2() { }
        /// Friend allocator used by soap_new_ns1__MandateTypeInformation2(struct soap*, int)
        friend SOAP_FMAC1 ns1__MandateTypeInformation2 * SOAP_FMAC2 soap_instantiate_ns1__MandateTypeInformation2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:290 */
#ifndef SOAP_TYPE_ns1__NameAndAddress16
#define SOAP_TYPE_ns1__NameAndAddress16 (73)
/* complex XML schema type 'ns1:NameAndAddress16': */
class SOAP_CMAC ns1__NameAndAddress16 {
      public:
        /// Required element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string Nm;
        /// Required element 'Adr' of XML schema type 'ns1:PostalAddress24'
        ns1__PostalAddress24 *Adr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NameAndAddress16
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NameAndAddress16; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NameAndAddress16, default initialized and not managed by a soap context
        virtual ns1__NameAndAddress16 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NameAndAddress16); }
      public:
        /// Constructor with default initializations
        ns1__NameAndAddress16() : Nm(), Adr(), soap() { }
        virtual ~ns1__NameAndAddress16() { }
        /// Friend allocator used by soap_new_ns1__NameAndAddress16(struct soap*, int)
        friend SOAP_FMAC1 ns1__NameAndAddress16 * SOAP_FMAC2 soap_instantiate_ns1__NameAndAddress16(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:292 */
#ifndef SOAP_TYPE_ns1__OrganisationIdentification29
#define SOAP_TYPE_ns1__OrganisationIdentification29 (74)
/* complex XML schema type 'ns1:OrganisationIdentification29': */
class SOAP_CMAC ns1__OrganisationIdentification29 {
      public:
        /// Optional element 'AnyBIC' of XML schema type 'ns1:AnyBICDec2014Identifier'
        std::string *AnyBIC;
        /// Optional element 'LEI' of XML schema type 'ns1:LEIIdentifier'
        std::string *LEI;
        /// Optional element 'Othr' of XML schema type 'ns1:GenericOrganisationIdentification1'
        std::vector<ns1__GenericOrganisationIdentification1 *> Othr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OrganisationIdentification29
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OrganisationIdentification29; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OrganisationIdentification29, default initialized and not managed by a soap context
        virtual ns1__OrganisationIdentification29 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OrganisationIdentification29); }
      public:
        /// Constructor with default initializations
        ns1__OrganisationIdentification29() : AnyBIC(), LEI(), Othr(), soap() { }
        virtual ~ns1__OrganisationIdentification29() { }
        /// Friend allocator used by soap_new_ns1__OrganisationIdentification29(struct soap*, int)
        friend SOAP_FMAC1 ns1__OrganisationIdentification29 * SOAP_FMAC2 soap_instantiate_ns1__OrganisationIdentification29(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2561 */
#ifndef SOAP_TYPE__ns1__union_OrganisationIdentificationSchemeName1Choice
#define SOAP_TYPE__ns1__union_OrganisationIdentificationSchemeName1Choice (317)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_OrganisationIdentificationSchemeName1Choice
{
        #define SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:294 */
#ifndef SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice (75)
/* Choice: */
class SOAP_CMAC ns1__OrganisationIdentificationSchemeName1Choice {
      public:
        /// Union with union _ns1__union_OrganisationIdentificationSchemeName1Choice variant selector __union_OrganisationIdentificationSchemeName1Choice set to one of: SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Cd SOAP_UNION__ns1__union_OrganisationIdentificationSchemeName1Choice_Prtry
        int __union_OrganisationIdentificationSchemeName1Choice;
        union _ns1__union_OrganisationIdentificationSchemeName1Choice union_OrganisationIdentificationSchemeName1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OrganisationIdentificationSchemeName1Choice, default initialized and not managed by a soap context
        virtual ns1__OrganisationIdentificationSchemeName1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OrganisationIdentificationSchemeName1Choice); }
      public:
        /// Constructor with default initializations
        ns1__OrganisationIdentificationSchemeName1Choice() : __union_OrganisationIdentificationSchemeName1Choice(), soap() { }
        virtual ~ns1__OrganisationIdentificationSchemeName1Choice() { }
        /// Friend allocator used by soap_new_ns1__OrganisationIdentificationSchemeName1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__OrganisationIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__OrganisationIdentificationSchemeName1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:296 */
#ifndef SOAP_TYPE_ns1__OtherContact1
#define SOAP_TYPE_ns1__OtherContact1 (76)
/* complex XML schema type 'ns1:OtherContact1': */
class SOAP_CMAC ns1__OtherContact1 {
      public:
        /// Required element 'ChanlTp' of XML schema type 'ns1:Max4Text'
        std::string ChanlTp;
        /// Optional element 'Id' of XML schema type 'ns1:Max128Text'
        std::string *Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OtherContact1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OtherContact1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OtherContact1, default initialized and not managed by a soap context
        virtual ns1__OtherContact1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OtherContact1); }
      public:
        /// Constructor with default initializations
        ns1__OtherContact1() : ChanlTp(), Id(), soap() { }
        virtual ~ns1__OtherContact1() { }
        /// Friend allocator used by soap_new_ns1__OtherContact1(struct soap*, int)
        friend SOAP_FMAC1 ns1__OtherContact1 * SOAP_FMAC2 soap_instantiate_ns1__OtherContact1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2614 */
#ifndef SOAP_TYPE__ns1__union_Party38Choice
#define SOAP_TYPE__ns1__union_Party38Choice (319)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_Party38Choice
{
        #define SOAP_UNION__ns1__union_Party38Choice_OrgId	(1)	/**< union variant selector value for member OrgId */
        ns1__OrganisationIdentification29 *OrgId;
        #define SOAP_UNION__ns1__union_Party38Choice_PrvtId	(2)	/**< union variant selector value for member PrvtId */
        ns1__PersonIdentification13 *PrvtId;
};
#endif

/* pain.h:298 */
#ifndef SOAP_TYPE_ns1__Party38Choice
#define SOAP_TYPE_ns1__Party38Choice (77)
/* Choice: */
class SOAP_CMAC ns1__Party38Choice {
      public:
        /// Union with union _ns1__union_Party38Choice variant selector __union_Party38Choice set to one of: SOAP_UNION__ns1__union_Party38Choice_OrgId SOAP_UNION__ns1__union_Party38Choice_PrvtId
        int __union_Party38Choice;
        union _ns1__union_Party38Choice union_Party38Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Party38Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Party38Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Party38Choice, default initialized and not managed by a soap context
        virtual ns1__Party38Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Party38Choice); }
      public:
        /// Constructor with default initializations
        ns1__Party38Choice() : __union_Party38Choice(), soap() { }
        virtual ~ns1__Party38Choice() { }
        /// Friend allocator used by soap_new_ns1__Party38Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__Party38Choice * SOAP_FMAC2 soap_instantiate_ns1__Party38Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:300 */
#ifndef SOAP_TYPE_ns1__PartyIdentification135
#define SOAP_TYPE_ns1__PartyIdentification135 (78)
/* complex XML schema type 'ns1:PartyIdentification135': */
class SOAP_CMAC ns1__PartyIdentification135 {
      public:
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Optional element 'PstlAdr' of XML schema type 'ns1:PostalAddress24'
        ns1__PostalAddress24 *PstlAdr;
        /// Optional element 'Id' of XML schema type 'ns1:Party38Choice'
        ns1__Party38Choice *Id;
        /// Optional element 'CtryOfRes' of XML schema type 'ns1:CountryCode'
        std::string *CtryOfRes;
        /// Optional element 'CtctDtls' of XML schema type 'ns1:Contact4'
        ns1__Contact4 *CtctDtls;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PartyIdentification135
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PartyIdentification135; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PartyIdentification135, default initialized and not managed by a soap context
        virtual ns1__PartyIdentification135 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PartyIdentification135); }
      public:
        /// Constructor with default initializations
        ns1__PartyIdentification135() : Nm(), PstlAdr(), Id(), CtryOfRes(), CtctDtls(), soap() { }
        virtual ~ns1__PartyIdentification135() { }
        /// Friend allocator used by soap_new_ns1__PartyIdentification135(struct soap*, int)
        friend SOAP_FMAC1 ns1__PartyIdentification135 * SOAP_FMAC2 soap_instantiate_ns1__PartyIdentification135(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:302 */
#ifndef SOAP_TYPE_ns1__PaymentIdentification6
#define SOAP_TYPE_ns1__PaymentIdentification6 (79)
/* complex XML schema type 'ns1:PaymentIdentification6': */
class SOAP_CMAC ns1__PaymentIdentification6 {
      public:
        /// Optional element 'InstrId' of XML schema type 'ns1:Max35Text'
        std::string *InstrId;
        /// Required element 'EndToEndId' of XML schema type 'ns1:Max35Text'
        std::string EndToEndId;
        /// Optional element 'UETR' of XML schema type 'ns1:UUIDv4Identifier'
        std::string *UETR;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentIdentification6
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PaymentIdentification6; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentIdentification6, default initialized and not managed by a soap context
        virtual ns1__PaymentIdentification6 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PaymentIdentification6); }
      public:
        /// Constructor with default initializations
        ns1__PaymentIdentification6() : InstrId(), EndToEndId(), UETR(), soap() { }
        virtual ~ns1__PaymentIdentification6() { }
        /// Friend allocator used by soap_new_ns1__PaymentIdentification6(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentIdentification6 * SOAP_FMAC2 soap_instantiate_ns1__PaymentIdentification6(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:304 */
#ifndef SOAP_TYPE_ns1__PaymentInitiationSource1
#define SOAP_TYPE_ns1__PaymentInitiationSource1 (80)
/* complex XML schema type 'ns1:PaymentInitiationSource1': */
class SOAP_CMAC ns1__PaymentInitiationSource1 {
      public:
        /// Required element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string Nm;
        /// Optional element 'Prvdr' of XML schema type 'ns1:Max35Text'
        std::string *Prvdr;
        /// Optional element 'Vrsn' of XML schema type 'ns1:Max35Text'
        std::string *Vrsn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentInitiationSource1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PaymentInitiationSource1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentInitiationSource1, default initialized and not managed by a soap context
        virtual ns1__PaymentInitiationSource1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PaymentInitiationSource1); }
      public:
        /// Constructor with default initializations
        ns1__PaymentInitiationSource1() : Nm(), Prvdr(), Vrsn(), soap() { }
        virtual ~ns1__PaymentInitiationSource1() { }
        /// Friend allocator used by soap_new_ns1__PaymentInitiationSource1(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentInitiationSource1 * SOAP_FMAC2 soap_instantiate_ns1__PaymentInitiationSource1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:306 */
#ifndef SOAP_TYPE_ns1__PaymentInstruction40
#define SOAP_TYPE_ns1__PaymentInstruction40 (81)
/* complex XML schema type 'ns1:PaymentInstruction40': */
class SOAP_CMAC ns1__PaymentInstruction40 {
      public:
        /// Required element 'PmtInfId' of XML schema type 'ns1:Max35Text'
        std::string PmtInfId;
        /// Required element 'PmtMtd' of XML schema type 'ns1:PaymentMethod3Code'
        enum ns1__PaymentMethod3Code PmtMtd;
        /// Optional element 'ReqdAdvcTp' of XML schema type 'ns1:AdviceType1'
        ns1__AdviceType1 *ReqdAdvcTp;
        /// Optional element 'BtchBookg' of XML schema type 'ns1:BatchBookingIndicator'
        bool *BtchBookg;
        /// Optional element 'NbOfTxs' of XML schema type 'ns1:Max15NumericText'
        std::string *NbOfTxs;
        /// Optional element 'CtrlSum' of XML schema type 'ns1:DecimalNumber'
        std::string *CtrlSum;
        /// Optional element 'PmtTpInf' of XML schema type 'ns1:PaymentTypeInformation26'
        ns1__PaymentTypeInformation26 *PmtTpInf;
        /// Required element 'ReqdExctnDt' of XML schema type 'ns1:DateAndDateTime2Choice'
        ns1__DateAndDateTime2Choice *ReqdExctnDt;
        /// Optional element 'PoolgAdjstmntDt' of XML schema type 'ns1:ISODate'
        std::string *PoolgAdjstmntDt;
        /// Required element 'Dbtr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *Dbtr;
        /// Required element 'DbtrAcct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *DbtrAcct;
        /// Required element 'DbtrAgt' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *DbtrAgt;
        /// Optional element 'DbtrAgtAcct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *DbtrAgtAcct;
        /// Optional element 'InstrForDbtrAgt' of XML schema type 'ns1:Max140Text'
        std::string *InstrForDbtrAgt;
        /// Optional element 'UltmtDbtr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *UltmtDbtr;
        /// Optional element 'ChrgBr' of XML schema type 'ns1:ChargeBearerType1Code'
        enum ns1__ChargeBearerType1Code *ChrgBr;
        /// Optional element 'ChrgsAcct' of XML schema type 'ns1:CashAccount40'
        ns1__CashAccount40 *ChrgsAcct;
        /// Optional element 'ChrgsAcctAgt' of XML schema type 'ns1:BranchAndFinancialInstitutionIdentification6'
        ns1__BranchAndFinancialInstitutionIdentification6 *ChrgsAcctAgt;
        /// Required element 'CdtTrfTxInf' of XML schema type 'ns1:CreditTransferTransaction54'
        std::vector<ns1__CreditTransferTransaction54 *> CdtTrfTxInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentInstruction40
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PaymentInstruction40; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentInstruction40, default initialized and not managed by a soap context
        virtual ns1__PaymentInstruction40 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PaymentInstruction40); }
      public:
        /// Constructor with default initializations
        ns1__PaymentInstruction40() : PmtInfId(), PmtMtd(), ReqdAdvcTp(), BtchBookg(), NbOfTxs(), CtrlSum(), PmtTpInf(), ReqdExctnDt(), PoolgAdjstmntDt(), Dbtr(), DbtrAcct(), DbtrAgt(), DbtrAgtAcct(), InstrForDbtrAgt(), UltmtDbtr(), ChrgBr(), ChrgsAcct(), ChrgsAcctAgt(), CdtTrfTxInf(), soap() { }
        virtual ~ns1__PaymentInstruction40() { }
        /// Friend allocator used by soap_new_ns1__PaymentInstruction40(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentInstruction40 * SOAP_FMAC2 soap_instantiate_ns1__PaymentInstruction40(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:308 */
#ifndef SOAP_TYPE_ns1__PaymentTypeInformation26
#define SOAP_TYPE_ns1__PaymentTypeInformation26 (82)
/* complex XML schema type 'ns1:PaymentTypeInformation26': */
class SOAP_CMAC ns1__PaymentTypeInformation26 {
      public:
        /// Optional element 'InstrPrty' of XML schema type 'ns1:Priority2Code'
        enum ns1__Priority2Code *InstrPrty;
        /// Optional element 'SvcLvl' of XML schema type 'ns1:ServiceLevel8Choice'
        std::vector<ns1__ServiceLevel8Choice *> SvcLvl;
        /// Optional element 'LclInstrm' of XML schema type 'ns1:LocalInstrument2Choice'
        ns1__LocalInstrument2Choice *LclInstrm;
        /// Optional element 'CtgyPurp' of XML schema type 'ns1:CategoryPurpose1Choice'
        ns1__CategoryPurpose1Choice *CtgyPurp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentTypeInformation26
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PaymentTypeInformation26; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentTypeInformation26, default initialized and not managed by a soap context
        virtual ns1__PaymentTypeInformation26 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PaymentTypeInformation26); }
      public:
        /// Constructor with default initializations
        ns1__PaymentTypeInformation26() : InstrPrty(), SvcLvl(), LclInstrm(), CtgyPurp(), soap() { }
        virtual ~ns1__PaymentTypeInformation26() { }
        /// Friend allocator used by soap_new_ns1__PaymentTypeInformation26(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentTypeInformation26 * SOAP_FMAC2 soap_instantiate_ns1__PaymentTypeInformation26(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:310 */
#ifndef SOAP_TYPE_ns1__PersonIdentification13
#define SOAP_TYPE_ns1__PersonIdentification13 (83)
/* complex XML schema type 'ns1:PersonIdentification13': */
class SOAP_CMAC ns1__PersonIdentification13 {
      public:
        /// Optional element 'DtAndPlcOfBirth' of XML schema type 'ns1:DateAndPlaceOfBirth1'
        ns1__DateAndPlaceOfBirth1 *DtAndPlcOfBirth;
        /// Optional element 'Othr' of XML schema type 'ns1:GenericPersonIdentification1'
        std::vector<ns1__GenericPersonIdentification1 *> Othr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PersonIdentification13
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PersonIdentification13; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PersonIdentification13, default initialized and not managed by a soap context
        virtual ns1__PersonIdentification13 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PersonIdentification13); }
      public:
        /// Constructor with default initializations
        ns1__PersonIdentification13() : DtAndPlcOfBirth(), Othr(), soap() { }
        virtual ~ns1__PersonIdentification13() { }
        /// Friend allocator used by soap_new_ns1__PersonIdentification13(struct soap*, int)
        friend SOAP_FMAC1 ns1__PersonIdentification13 * SOAP_FMAC2 soap_instantiate_ns1__PersonIdentification13(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2830 */
#ifndef SOAP_TYPE__ns1__union_PersonIdentificationSchemeName1Choice
#define SOAP_TYPE__ns1__union_PersonIdentificationSchemeName1Choice (336)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_PersonIdentificationSchemeName1Choice
{
        #define SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:312 */
#ifndef SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice (84)
/* Choice: */
class SOAP_CMAC ns1__PersonIdentificationSchemeName1Choice {
      public:
        /// Union with union _ns1__union_PersonIdentificationSchemeName1Choice variant selector __union_PersonIdentificationSchemeName1Choice set to one of: SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Cd SOAP_UNION__ns1__union_PersonIdentificationSchemeName1Choice_Prtry
        int __union_PersonIdentificationSchemeName1Choice;
        union _ns1__union_PersonIdentificationSchemeName1Choice union_PersonIdentificationSchemeName1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PersonIdentificationSchemeName1Choice, default initialized and not managed by a soap context
        virtual ns1__PersonIdentificationSchemeName1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PersonIdentificationSchemeName1Choice); }
      public:
        /// Constructor with default initializations
        ns1__PersonIdentificationSchemeName1Choice() : __union_PersonIdentificationSchemeName1Choice(), soap() { }
        virtual ~ns1__PersonIdentificationSchemeName1Choice() { }
        /// Friend allocator used by soap_new_ns1__PersonIdentificationSchemeName1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__PersonIdentificationSchemeName1Choice * SOAP_FMAC2 soap_instantiate_ns1__PersonIdentificationSchemeName1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:314 */
#ifndef SOAP_TYPE_ns1__PostalAddress24
#define SOAP_TYPE_ns1__PostalAddress24 (85)
/* complex XML schema type 'ns1:PostalAddress24': */
class SOAP_CMAC ns1__PostalAddress24 {
      public:
        /// Optional element 'AdrTp' of XML schema type 'ns1:AddressType3Choice'
        ns1__AddressType3Choice *AdrTp;
        /// Optional element 'Dept' of XML schema type 'ns1:Max70Text'
        std::string *Dept;
        /// Optional element 'SubDept' of XML schema type 'ns1:Max70Text'
        std::string *SubDept;
        /// Optional element 'StrtNm' of XML schema type 'ns1:Max70Text'
        std::string *StrtNm;
        /// Optional element 'BldgNb' of XML schema type 'ns1:Max16Text'
        std::string *BldgNb;
        /// Optional element 'BldgNm' of XML schema type 'ns1:Max35Text'
        std::string *BldgNm;
        /// Optional element 'Flr' of XML schema type 'ns1:Max70Text'
        std::string *Flr;
        /// Optional element 'PstBx' of XML schema type 'ns1:Max16Text'
        std::string *PstBx;
        /// Optional element 'Room' of XML schema type 'ns1:Max70Text'
        std::string *Room;
        /// Optional element 'PstCd' of XML schema type 'ns1:Max16Text'
        std::string *PstCd;
        /// Optional element 'TwnNm' of XML schema type 'ns1:Max35Text'
        std::string *TwnNm;
        /// Optional element 'TwnLctnNm' of XML schema type 'ns1:Max35Text'
        std::string *TwnLctnNm;
        /// Optional element 'DstrctNm' of XML schema type 'ns1:Max35Text'
        std::string *DstrctNm;
        /// Optional element 'CtrySubDvsn' of XML schema type 'ns1:Max35Text'
        std::string *CtrySubDvsn;
        /// Optional element 'Ctry' of XML schema type 'ns1:CountryCode'
        std::string *Ctry;
        /// Sequence of 0 to 7 elements 'AdrLine' of XML schema type 'ns1:Max70Text'
        std::vector<std::string> AdrLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PostalAddress24
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PostalAddress24; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PostalAddress24, default initialized and not managed by a soap context
        virtual ns1__PostalAddress24 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PostalAddress24); }
      public:
        /// Constructor with default initializations
        ns1__PostalAddress24() : AdrTp(), Dept(), SubDept(), StrtNm(), BldgNb(), BldgNm(), Flr(), PstBx(), Room(), PstCd(), TwnNm(), TwnLctnNm(), DstrctNm(), CtrySubDvsn(), Ctry(), AdrLine(), soap() { }
        virtual ~ns1__PostalAddress24() { }
        /// Friend allocator used by soap_new_ns1__PostalAddress24(struct soap*, int)
        friend SOAP_FMAC1 ns1__PostalAddress24 * SOAP_FMAC2 soap_instantiate_ns1__PostalAddress24(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:316 */
#ifndef SOAP_TYPE_ns1__ProxyAccountIdentification1
#define SOAP_TYPE_ns1__ProxyAccountIdentification1 (86)
/* complex XML schema type 'ns1:ProxyAccountIdentification1': */
class SOAP_CMAC ns1__ProxyAccountIdentification1 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:ProxyAccountType1Choice'
        ns1__ProxyAccountType1Choice *Tp;
        /// Required element 'Id' of XML schema type 'ns1:Max2048Text'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ProxyAccountIdentification1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ProxyAccountIdentification1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ProxyAccountIdentification1, default initialized and not managed by a soap context
        virtual ns1__ProxyAccountIdentification1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ProxyAccountIdentification1); }
      public:
        /// Constructor with default initializations
        ns1__ProxyAccountIdentification1() : Tp(), Id(), soap() { }
        virtual ~ns1__ProxyAccountIdentification1() { }
        /// Friend allocator used by soap_new_ns1__ProxyAccountIdentification1(struct soap*, int)
        friend SOAP_FMAC1 ns1__ProxyAccountIdentification1 * SOAP_FMAC2 soap_instantiate_ns1__ProxyAccountIdentification1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2934 */
#ifndef SOAP_TYPE__ns1__union_ProxyAccountType1Choice
#define SOAP_TYPE__ns1__union_ProxyAccountType1Choice (341)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_ProxyAccountType1Choice
{
        #define SOAP_UNION__ns1__union_ProxyAccountType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_ProxyAccountType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:318 */
#ifndef SOAP_TYPE_ns1__ProxyAccountType1Choice
#define SOAP_TYPE_ns1__ProxyAccountType1Choice (87)
/* Choice: */
class SOAP_CMAC ns1__ProxyAccountType1Choice {
      public:
        /// Union with union _ns1__union_ProxyAccountType1Choice variant selector __union_ProxyAccountType1Choice set to one of: SOAP_UNION__ns1__union_ProxyAccountType1Choice_Cd SOAP_UNION__ns1__union_ProxyAccountType1Choice_Prtry
        int __union_ProxyAccountType1Choice;
        union _ns1__union_ProxyAccountType1Choice union_ProxyAccountType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ProxyAccountType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ProxyAccountType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ProxyAccountType1Choice, default initialized and not managed by a soap context
        virtual ns1__ProxyAccountType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ProxyAccountType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__ProxyAccountType1Choice() : __union_ProxyAccountType1Choice(), soap() { }
        virtual ~ns1__ProxyAccountType1Choice() { }
        /// Friend allocator used by soap_new_ns1__ProxyAccountType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__ProxyAccountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__ProxyAccountType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:2964 */
#ifndef SOAP_TYPE__ns1__union_Purpose2Choice
#define SOAP_TYPE__ns1__union_Purpose2Choice (343)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_Purpose2Choice
{
        #define SOAP_UNION__ns1__union_Purpose2Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_Purpose2Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:320 */
#ifndef SOAP_TYPE_ns1__Purpose2Choice
#define SOAP_TYPE_ns1__Purpose2Choice (88)
/* Choice: */
class SOAP_CMAC ns1__Purpose2Choice {
      public:
        /// Union with union _ns1__union_Purpose2Choice variant selector __union_Purpose2Choice set to one of: SOAP_UNION__ns1__union_Purpose2Choice_Cd SOAP_UNION__ns1__union_Purpose2Choice_Prtry
        int __union_Purpose2Choice;
        union _ns1__union_Purpose2Choice union_Purpose2Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Purpose2Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Purpose2Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Purpose2Choice, default initialized and not managed by a soap context
        virtual ns1__Purpose2Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Purpose2Choice); }
      public:
        /// Constructor with default initializations
        ns1__Purpose2Choice() : __union_Purpose2Choice(), soap() { }
        virtual ~ns1__Purpose2Choice() { }
        /// Friend allocator used by soap_new_ns1__Purpose2Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__Purpose2Choice * SOAP_FMAC2 soap_instantiate_ns1__Purpose2Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:322 */
#ifndef SOAP_TYPE_ns1__ReferredDocumentInformation7
#define SOAP_TYPE_ns1__ReferredDocumentInformation7 (89)
/* complex XML schema type 'ns1:ReferredDocumentInformation7': */
class SOAP_CMAC ns1__ReferredDocumentInformation7 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:ReferredDocumentType4'
        ns1__ReferredDocumentType4 *Tp;
        /// Optional element 'Nb' of XML schema type 'ns1:Max35Text'
        std::string *Nb;
        /// Optional element 'RltdDt' of XML schema type 'ns1:ISODate'
        std::string *RltdDt;
        /// Optional element 'LineDtls' of XML schema type 'ns1:DocumentLineInformation1'
        std::vector<ns1__DocumentLineInformation1 *> LineDtls;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReferredDocumentInformation7
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ReferredDocumentInformation7; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReferredDocumentInformation7, default initialized and not managed by a soap context
        virtual ns1__ReferredDocumentInformation7 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ReferredDocumentInformation7); }
      public:
        /// Constructor with default initializations
        ns1__ReferredDocumentInformation7() : Tp(), Nb(), RltdDt(), LineDtls(), soap() { }
        virtual ~ns1__ReferredDocumentInformation7() { }
        /// Friend allocator used by soap_new_ns1__ReferredDocumentInformation7(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReferredDocumentInformation7 * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentInformation7(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:3021 */
#ifndef SOAP_TYPE__ns1__union_ReferredDocumentType3Choice
#define SOAP_TYPE__ns1__union_ReferredDocumentType3Choice (348)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_ReferredDocumentType3Choice
{
        #define SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Cd	(1)	/**< union variant selector value for member Cd */
        enum ns1__DocumentType6Code Cd;
        #define SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:324 */
#ifndef SOAP_TYPE_ns1__ReferredDocumentType3Choice
#define SOAP_TYPE_ns1__ReferredDocumentType3Choice (90)
/* Choice: */
class SOAP_CMAC ns1__ReferredDocumentType3Choice {
      public:
        /// Union with union _ns1__union_ReferredDocumentType3Choice variant selector __union_ReferredDocumentType3Choice set to one of: SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Cd SOAP_UNION__ns1__union_ReferredDocumentType3Choice_Prtry
        int __union_ReferredDocumentType3Choice;
        union _ns1__union_ReferredDocumentType3Choice union_ReferredDocumentType3Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReferredDocumentType3Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ReferredDocumentType3Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReferredDocumentType3Choice, default initialized and not managed by a soap context
        virtual ns1__ReferredDocumentType3Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ReferredDocumentType3Choice); }
      public:
        /// Constructor with default initializations
        ns1__ReferredDocumentType3Choice() : __union_ReferredDocumentType3Choice(), soap() { }
        virtual ~ns1__ReferredDocumentType3Choice() { }
        /// Friend allocator used by soap_new_ns1__ReferredDocumentType3Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReferredDocumentType3Choice * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentType3Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:326 */
#ifndef SOAP_TYPE_ns1__ReferredDocumentType4
#define SOAP_TYPE_ns1__ReferredDocumentType4 (91)
/* complex XML schema type 'ns1:ReferredDocumentType4': */
class SOAP_CMAC ns1__ReferredDocumentType4 {
      public:
        /// Required element 'CdOrPrtry' of XML schema type 'ns1:ReferredDocumentType3Choice'
        ns1__ReferredDocumentType3Choice *CdOrPrtry;
        /// Optional element 'Issr' of XML schema type 'ns1:Max35Text'
        std::string *Issr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReferredDocumentType4
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ReferredDocumentType4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReferredDocumentType4, default initialized and not managed by a soap context
        virtual ns1__ReferredDocumentType4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ReferredDocumentType4); }
      public:
        /// Constructor with default initializations
        ns1__ReferredDocumentType4() : CdOrPrtry(), Issr(), soap() { }
        virtual ~ns1__ReferredDocumentType4() { }
        /// Friend allocator used by soap_new_ns1__ReferredDocumentType4(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReferredDocumentType4 * SOAP_FMAC2 soap_instantiate_ns1__ReferredDocumentType4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:328 */
#ifndef SOAP_TYPE_ns1__RegulatoryAuthority2
#define SOAP_TYPE_ns1__RegulatoryAuthority2 (92)
/* complex XML schema type 'ns1:RegulatoryAuthority2': */
class SOAP_CMAC ns1__RegulatoryAuthority2 {
      public:
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Optional element 'Ctry' of XML schema type 'ns1:CountryCode'
        std::string *Ctry;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RegulatoryAuthority2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RegulatoryAuthority2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RegulatoryAuthority2, default initialized and not managed by a soap context
        virtual ns1__RegulatoryAuthority2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RegulatoryAuthority2); }
      public:
        /// Constructor with default initializations
        ns1__RegulatoryAuthority2() : Nm(), Ctry(), soap() { }
        virtual ~ns1__RegulatoryAuthority2() { }
        /// Friend allocator used by soap_new_ns1__RegulatoryAuthority2(struct soap*, int)
        friend SOAP_FMAC1 ns1__RegulatoryAuthority2 * SOAP_FMAC2 soap_instantiate_ns1__RegulatoryAuthority2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:330 */
#ifndef SOAP_TYPE_ns1__RegulatoryReporting3
#define SOAP_TYPE_ns1__RegulatoryReporting3 (93)
/* complex XML schema type 'ns1:RegulatoryReporting3': */
class SOAP_CMAC ns1__RegulatoryReporting3 {
      public:
        /// Optional element 'DbtCdtRptgInd' of XML schema type 'ns1:RegulatoryReportingType1Code'
        enum ns1__RegulatoryReportingType1Code *DbtCdtRptgInd;
        /// Optional element 'Authrty' of XML schema type 'ns1:RegulatoryAuthority2'
        ns1__RegulatoryAuthority2 *Authrty;
        /// Optional element 'Dtls' of XML schema type 'ns1:StructuredRegulatoryReporting3'
        std::vector<ns1__StructuredRegulatoryReporting3 *> Dtls;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RegulatoryReporting3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RegulatoryReporting3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RegulatoryReporting3, default initialized and not managed by a soap context
        virtual ns1__RegulatoryReporting3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RegulatoryReporting3); }
      public:
        /// Constructor with default initializations
        ns1__RegulatoryReporting3() : DbtCdtRptgInd(), Authrty(), Dtls(), soap() { }
        virtual ~ns1__RegulatoryReporting3() { }
        /// Friend allocator used by soap_new_ns1__RegulatoryReporting3(struct soap*, int)
        friend SOAP_FMAC1 ns1__RegulatoryReporting3 * SOAP_FMAC2 soap_instantiate_ns1__RegulatoryReporting3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:332 */
#ifndef SOAP_TYPE_ns1__RemittanceAmount2
#define SOAP_TYPE_ns1__RemittanceAmount2 (94)
/* complex XML schema type 'ns1:RemittanceAmount2': */
class SOAP_CMAC ns1__RemittanceAmount2 {
      public:
        /// Optional element 'DuePyblAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *DuePyblAmt;
        /// Optional element 'DscntApldAmt' of XML schema type 'ns1:DiscountAmountAndType1'
        std::vector<ns1__DiscountAmountAndType1 *> DscntApldAmt;
        /// Optional element 'CdtNoteAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *CdtNoteAmt;
        /// Optional element 'TaxAmt' of XML schema type 'ns1:TaxAmountAndType1'
        std::vector<ns1__TaxAmountAndType1 *> TaxAmt;
        /// Optional element 'AdjstmntAmtAndRsn' of XML schema type 'ns1:DocumentAdjustment1'
        std::vector<ns1__DocumentAdjustment1 *> AdjstmntAmtAndRsn;
        /// Optional element 'RmtdAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *RmtdAmt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RemittanceAmount2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RemittanceAmount2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RemittanceAmount2, default initialized and not managed by a soap context
        virtual ns1__RemittanceAmount2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RemittanceAmount2); }
      public:
        /// Constructor with default initializations
        ns1__RemittanceAmount2() : DuePyblAmt(), DscntApldAmt(), CdtNoteAmt(), TaxAmt(), AdjstmntAmtAndRsn(), RmtdAmt(), soap() { }
        virtual ~ns1__RemittanceAmount2() { }
        /// Friend allocator used by soap_new_ns1__RemittanceAmount2(struct soap*, int)
        friend SOAP_FMAC1 ns1__RemittanceAmount2 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceAmount2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:334 */
#ifndef SOAP_TYPE_ns1__RemittanceAmount3
#define SOAP_TYPE_ns1__RemittanceAmount3 (95)
/* complex XML schema type 'ns1:RemittanceAmount3': */
class SOAP_CMAC ns1__RemittanceAmount3 {
      public:
        /// Optional element 'DuePyblAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *DuePyblAmt;
        /// Optional element 'DscntApldAmt' of XML schema type 'ns1:DiscountAmountAndType1'
        std::vector<ns1__DiscountAmountAndType1 *> DscntApldAmt;
        /// Optional element 'CdtNoteAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *CdtNoteAmt;
        /// Optional element 'TaxAmt' of XML schema type 'ns1:TaxAmountAndType1'
        std::vector<ns1__TaxAmountAndType1 *> TaxAmt;
        /// Optional element 'AdjstmntAmtAndRsn' of XML schema type 'ns1:DocumentAdjustment1'
        std::vector<ns1__DocumentAdjustment1 *> AdjstmntAmtAndRsn;
        /// Optional element 'RmtdAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *RmtdAmt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RemittanceAmount3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RemittanceAmount3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RemittanceAmount3, default initialized and not managed by a soap context
        virtual ns1__RemittanceAmount3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RemittanceAmount3); }
      public:
        /// Constructor with default initializations
        ns1__RemittanceAmount3() : DuePyblAmt(), DscntApldAmt(), CdtNoteAmt(), TaxAmt(), AdjstmntAmtAndRsn(), RmtdAmt(), soap() { }
        virtual ~ns1__RemittanceAmount3() { }
        /// Friend allocator used by soap_new_ns1__RemittanceAmount3(struct soap*, int)
        friend SOAP_FMAC1 ns1__RemittanceAmount3 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceAmount3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:336 */
#ifndef SOAP_TYPE_ns1__RemittanceInformation21
#define SOAP_TYPE_ns1__RemittanceInformation21 (96)
/* complex XML schema type 'ns1:RemittanceInformation21': */
class SOAP_CMAC ns1__RemittanceInformation21 {
      public:
        /// Optional element 'Ustrd' of XML schema type 'ns1:Max140Text'
        std::vector<std::string> Ustrd;
        /// Optional element 'Strd' of XML schema type 'ns1:StructuredRemittanceInformation17'
        std::vector<ns1__StructuredRemittanceInformation17 *> Strd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RemittanceInformation21
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RemittanceInformation21; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RemittanceInformation21, default initialized and not managed by a soap context
        virtual ns1__RemittanceInformation21 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RemittanceInformation21); }
      public:
        /// Constructor with default initializations
        ns1__RemittanceInformation21() : Ustrd(), Strd(), soap() { }
        virtual ~ns1__RemittanceInformation21() { }
        /// Friend allocator used by soap_new_ns1__RemittanceInformation21(struct soap*, int)
        friend SOAP_FMAC1 ns1__RemittanceInformation21 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceInformation21(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:338 */
#ifndef SOAP_TYPE_ns1__RemittanceLocation7
#define SOAP_TYPE_ns1__RemittanceLocation7 (97)
/* complex XML schema type 'ns1:RemittanceLocation7': */
class SOAP_CMAC ns1__RemittanceLocation7 {
      public:
        /// Optional element 'RmtId' of XML schema type 'ns1:Max35Text'
        std::string *RmtId;
        /// Optional element 'RmtLctnDtls' of XML schema type 'ns1:RemittanceLocationData1'
        std::vector<ns1__RemittanceLocationData1 *> RmtLctnDtls;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RemittanceLocation7
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RemittanceLocation7; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RemittanceLocation7, default initialized and not managed by a soap context
        virtual ns1__RemittanceLocation7 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RemittanceLocation7); }
      public:
        /// Constructor with default initializations
        ns1__RemittanceLocation7() : RmtId(), RmtLctnDtls(), soap() { }
        virtual ~ns1__RemittanceLocation7() { }
        /// Friend allocator used by soap_new_ns1__RemittanceLocation7(struct soap*, int)
        friend SOAP_FMAC1 ns1__RemittanceLocation7 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceLocation7(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:340 */
#ifndef SOAP_TYPE_ns1__RemittanceLocationData1
#define SOAP_TYPE_ns1__RemittanceLocationData1 (98)
/* complex XML schema type 'ns1:RemittanceLocationData1': */
class SOAP_CMAC ns1__RemittanceLocationData1 {
      public:
        /// Required element 'Mtd' of XML schema type 'ns1:RemittanceLocationMethod2Code'
        enum ns1__RemittanceLocationMethod2Code Mtd;
        /// Optional element 'ElctrncAdr' of XML schema type 'ns1:Max2048Text'
        std::string *ElctrncAdr;
        /// Optional element 'PstlAdr' of XML schema type 'ns1:NameAndAddress16'
        ns1__NameAndAddress16 *PstlAdr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RemittanceLocationData1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RemittanceLocationData1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RemittanceLocationData1, default initialized and not managed by a soap context
        virtual ns1__RemittanceLocationData1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RemittanceLocationData1); }
      public:
        /// Constructor with default initializations
        ns1__RemittanceLocationData1() : Mtd(), ElctrncAdr(), PstlAdr(), soap() { }
        virtual ~ns1__RemittanceLocationData1() { }
        /// Friend allocator used by soap_new_ns1__RemittanceLocationData1(struct soap*, int)
        friend SOAP_FMAC1 ns1__RemittanceLocationData1 * SOAP_FMAC2 soap_instantiate_ns1__RemittanceLocationData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:3255 */
#ifndef SOAP_TYPE__ns1__union_ServiceLevel8Choice
#define SOAP_TYPE__ns1__union_ServiceLevel8Choice (365)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_ServiceLevel8Choice
{
        #define SOAP_UNION__ns1__union_ServiceLevel8Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_ServiceLevel8Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:342 */
#ifndef SOAP_TYPE_ns1__ServiceLevel8Choice
#define SOAP_TYPE_ns1__ServiceLevel8Choice (99)
/* Choice: */
class SOAP_CMAC ns1__ServiceLevel8Choice {
      public:
        /// Union with union _ns1__union_ServiceLevel8Choice variant selector __union_ServiceLevel8Choice set to one of: SOAP_UNION__ns1__union_ServiceLevel8Choice_Cd SOAP_UNION__ns1__union_ServiceLevel8Choice_Prtry
        int __union_ServiceLevel8Choice;
        union _ns1__union_ServiceLevel8Choice union_ServiceLevel8Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ServiceLevel8Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ServiceLevel8Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ServiceLevel8Choice, default initialized and not managed by a soap context
        virtual ns1__ServiceLevel8Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ServiceLevel8Choice); }
      public:
        /// Constructor with default initializations
        ns1__ServiceLevel8Choice() : __union_ServiceLevel8Choice(), soap() { }
        virtual ~ns1__ServiceLevel8Choice() { }
        /// Friend allocator used by soap_new_ns1__ServiceLevel8Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__ServiceLevel8Choice * SOAP_FMAC2 soap_instantiate_ns1__ServiceLevel8Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:344 */
#ifndef SOAP_TYPE_ns1__StructuredRegulatoryReporting3
#define SOAP_TYPE_ns1__StructuredRegulatoryReporting3 (100)
/* complex XML schema type 'ns1:StructuredRegulatoryReporting3': */
class SOAP_CMAC ns1__StructuredRegulatoryReporting3 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:Max35Text'
        std::string *Tp;
        /// Optional element 'Dt' of XML schema type 'ns1:ISODate'
        std::string *Dt;
        /// Optional element 'Ctry' of XML schema type 'ns1:CountryCode'
        std::string *Ctry;
        /// Optional element 'Cd' of XML schema type 'ns1:Max10Text'
        std::string *Cd;
        /// Optional element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Optional element 'Inf' of XML schema type 'ns1:Max35Text'
        std::vector<std::string> Inf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StructuredRegulatoryReporting3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__StructuredRegulatoryReporting3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StructuredRegulatoryReporting3, default initialized and not managed by a soap context
        virtual ns1__StructuredRegulatoryReporting3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__StructuredRegulatoryReporting3); }
      public:
        /// Constructor with default initializations
        ns1__StructuredRegulatoryReporting3() : Tp(), Dt(), Ctry(), Cd(), Amt(), Inf(), soap() { }
        virtual ~ns1__StructuredRegulatoryReporting3() { }
        /// Friend allocator used by soap_new_ns1__StructuredRegulatoryReporting3(struct soap*, int)
        friend SOAP_FMAC1 ns1__StructuredRegulatoryReporting3 * SOAP_FMAC2 soap_instantiate_ns1__StructuredRegulatoryReporting3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:346 */
#ifndef SOAP_TYPE_ns1__StructuredRemittanceInformation17
#define SOAP_TYPE_ns1__StructuredRemittanceInformation17 (101)
/* complex XML schema type 'ns1:StructuredRemittanceInformation17': */
class SOAP_CMAC ns1__StructuredRemittanceInformation17 {
      public:
        /// Optional element 'RfrdDocInf' of XML schema type 'ns1:ReferredDocumentInformation7'
        std::vector<ns1__ReferredDocumentInformation7 *> RfrdDocInf;
        /// Optional element 'RfrdDocAmt' of XML schema type 'ns1:RemittanceAmount2'
        ns1__RemittanceAmount2 *RfrdDocAmt;
        /// Optional element 'CdtrRefInf' of XML schema type 'ns1:CreditorReferenceInformation2'
        ns1__CreditorReferenceInformation2 *CdtrRefInf;
        /// Optional element 'Invcr' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *Invcr;
        /// Optional element 'Invcee' of XML schema type 'ns1:PartyIdentification135'
        ns1__PartyIdentification135 *Invcee;
        /// Optional element 'TaxRmt' of XML schema type 'ns1:TaxData1'
        ns1__TaxData1 *TaxRmt;
        /// Optional element 'GrnshmtRmt' of XML schema type 'ns1:Garnishment3'
        ns1__Garnishment3 *GrnshmtRmt;
        /// Sequence of 0 to 3 elements 'AddtlRmtInf' of XML schema type 'ns1:Max140Text'
        std::vector<std::string> AddtlRmtInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StructuredRemittanceInformation17
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__StructuredRemittanceInformation17; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StructuredRemittanceInformation17, default initialized and not managed by a soap context
        virtual ns1__StructuredRemittanceInformation17 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__StructuredRemittanceInformation17); }
      public:
        /// Constructor with default initializations
        ns1__StructuredRemittanceInformation17() : RfrdDocInf(), RfrdDocAmt(), CdtrRefInf(), Invcr(), Invcee(), TaxRmt(), GrnshmtRmt(), AddtlRmtInf(), soap() { }
        virtual ~ns1__StructuredRemittanceInformation17() { }
        /// Friend allocator used by soap_new_ns1__StructuredRemittanceInformation17(struct soap*, int)
        friend SOAP_FMAC1 ns1__StructuredRemittanceInformation17 * SOAP_FMAC2 soap_instantiate_ns1__StructuredRemittanceInformation17(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:348 */
#ifndef SOAP_TYPE_ns1__SupplementaryData1
#define SOAP_TYPE_ns1__SupplementaryData1 (102)
/* complex XML schema type 'ns1:SupplementaryData1': */
class SOAP_CMAC ns1__SupplementaryData1 {
      public:
        /// Optional element 'PlcAndNm' of XML schema type 'ns1:Max350Text'
        std::string *PlcAndNm;
        /// Required element 'Envlp' of XML schema type 'ns1:SupplementaryDataEnvelope1'
        ns1__SupplementaryDataEnvelope1 *Envlp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SupplementaryData1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SupplementaryData1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SupplementaryData1, default initialized and not managed by a soap context
        virtual ns1__SupplementaryData1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SupplementaryData1); }
      public:
        /// Constructor with default initializations
        ns1__SupplementaryData1() : PlcAndNm(), Envlp(), soap() { }
        virtual ~ns1__SupplementaryData1() { }
        /// Friend allocator used by soap_new_ns1__SupplementaryData1(struct soap*, int)
        friend SOAP_FMAC1 ns1__SupplementaryData1 * SOAP_FMAC2 soap_instantiate_ns1__SupplementaryData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:350 */
#ifndef SOAP_TYPE_ns1__SupplementaryDataEnvelope1
#define SOAP_TYPE_ns1__SupplementaryDataEnvelope1 (103)
/* complex XML schema type 'ns1:SupplementaryDataEnvelope1': */
class SOAP_CMAC ns1__SupplementaryDataEnvelope1 {
      public:
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SupplementaryDataEnvelope1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SupplementaryDataEnvelope1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SupplementaryDataEnvelope1, default initialized and not managed by a soap context
        virtual ns1__SupplementaryDataEnvelope1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SupplementaryDataEnvelope1); }
      public:
        /// Constructor with default initializations
        ns1__SupplementaryDataEnvelope1() : __any(), soap() { }
        virtual ~ns1__SupplementaryDataEnvelope1() { }
        /// Friend allocator used by soap_new_ns1__SupplementaryDataEnvelope1(struct soap*, int)
        friend SOAP_FMAC1 ns1__SupplementaryDataEnvelope1 * SOAP_FMAC2 soap_instantiate_ns1__SupplementaryDataEnvelope1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:352 */
#ifndef SOAP_TYPE_ns1__TaxAmount3
#define SOAP_TYPE_ns1__TaxAmount3 (104)
/* complex XML schema type 'ns1:TaxAmount3': */
class SOAP_CMAC ns1__TaxAmount3 {
      public:
        /// Optional element 'Rate' of XML schema type 'ns1:PercentageRate'
        std::string *Rate;
        /// Optional element 'TaxblBaseAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TaxblBaseAmt;
        /// Optional element 'TtlAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TtlAmt;
        /// Optional element 'Dtls' of XML schema type 'ns1:TaxRecordDetails3'
        std::vector<ns1__TaxRecordDetails3 *> Dtls;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxAmount3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxAmount3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxAmount3, default initialized and not managed by a soap context
        virtual ns1__TaxAmount3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxAmount3); }
      public:
        /// Constructor with default initializations
        ns1__TaxAmount3() : Rate(), TaxblBaseAmt(), TtlAmt(), Dtls(), soap() { }
        virtual ~ns1__TaxAmount3() { }
        /// Friend allocator used by soap_new_ns1__TaxAmount3(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxAmount3 * SOAP_FMAC2 soap_instantiate_ns1__TaxAmount3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:354 */
#ifndef SOAP_TYPE_ns1__TaxAmountAndType1
#define SOAP_TYPE_ns1__TaxAmountAndType1 (105)
/* complex XML schema type 'ns1:TaxAmountAndType1': */
class SOAP_CMAC ns1__TaxAmountAndType1 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:TaxAmountType1Choice'
        ns1__TaxAmountType1Choice *Tp;
        /// Required element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxAmountAndType1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxAmountAndType1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxAmountAndType1, default initialized and not managed by a soap context
        virtual ns1__TaxAmountAndType1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxAmountAndType1); }
      public:
        /// Constructor with default initializations
        ns1__TaxAmountAndType1() : Tp(), Amt(), soap() { }
        virtual ~ns1__TaxAmountAndType1() { }
        /// Friend allocator used by soap_new_ns1__TaxAmountAndType1(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxAmountAndType1 * SOAP_FMAC2 soap_instantiate_ns1__TaxAmountAndType1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:3450 */
#ifndef SOAP_TYPE__ns1__union_TaxAmountType1Choice
#define SOAP_TYPE__ns1__union_TaxAmountType1Choice (380)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_TaxAmountType1Choice
{
        #define SOAP_UNION__ns1__union_TaxAmountType1Choice_Cd	(1)	/**< union variant selector value for member Cd */
        std::string *Cd;
        #define SOAP_UNION__ns1__union_TaxAmountType1Choice_Prtry	(2)	/**< union variant selector value for member Prtry */
        std::string *Prtry;
};
#endif

/* pain.h:356 */
#ifndef SOAP_TYPE_ns1__TaxAmountType1Choice
#define SOAP_TYPE_ns1__TaxAmountType1Choice (106)
/* Choice: */
class SOAP_CMAC ns1__TaxAmountType1Choice {
      public:
        /// Union with union _ns1__union_TaxAmountType1Choice variant selector __union_TaxAmountType1Choice set to one of: SOAP_UNION__ns1__union_TaxAmountType1Choice_Cd SOAP_UNION__ns1__union_TaxAmountType1Choice_Prtry
        int __union_TaxAmountType1Choice;
        union _ns1__union_TaxAmountType1Choice union_TaxAmountType1Choice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxAmountType1Choice
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxAmountType1Choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxAmountType1Choice, default initialized and not managed by a soap context
        virtual ns1__TaxAmountType1Choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxAmountType1Choice); }
      public:
        /// Constructor with default initializations
        ns1__TaxAmountType1Choice() : __union_TaxAmountType1Choice(), soap() { }
        virtual ~ns1__TaxAmountType1Choice() { }
        /// Friend allocator used by soap_new_ns1__TaxAmountType1Choice(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxAmountType1Choice * SOAP_FMAC2 soap_instantiate_ns1__TaxAmountType1Choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:358 */
#ifndef SOAP_TYPE_ns1__TaxAuthorisation1
#define SOAP_TYPE_ns1__TaxAuthorisation1 (107)
/* complex XML schema type 'ns1:TaxAuthorisation1': */
class SOAP_CMAC ns1__TaxAuthorisation1 {
      public:
        /// Optional element 'Titl' of XML schema type 'ns1:Max35Text'
        std::string *Titl;
        /// Optional element 'Nm' of XML schema type 'ns1:Max140Text'
        std::string *Nm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxAuthorisation1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxAuthorisation1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxAuthorisation1, default initialized and not managed by a soap context
        virtual ns1__TaxAuthorisation1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxAuthorisation1); }
      public:
        /// Constructor with default initializations
        ns1__TaxAuthorisation1() : Titl(), Nm(), soap() { }
        virtual ~ns1__TaxAuthorisation1() { }
        /// Friend allocator used by soap_new_ns1__TaxAuthorisation1(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxAuthorisation1 * SOAP_FMAC2 soap_instantiate_ns1__TaxAuthorisation1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:360 */
#ifndef SOAP_TYPE_ns1__TaxData1
#define SOAP_TYPE_ns1__TaxData1 (108)
/* complex XML schema type 'ns1:TaxData1': */
class SOAP_CMAC ns1__TaxData1 {
      public:
        /// Optional element 'Cdtr' of XML schema type 'ns1:TaxParty1'
        ns1__TaxParty1 *Cdtr;
        /// Optional element 'Dbtr' of XML schema type 'ns1:TaxParty2'
        ns1__TaxParty2 *Dbtr;
        /// Optional element 'UltmtDbtr' of XML schema type 'ns1:TaxParty2'
        ns1__TaxParty2 *UltmtDbtr;
        /// Optional element 'AdmstnZone' of XML schema type 'ns1:Max35Text'
        std::string *AdmstnZone;
        /// Optional element 'RefNb' of XML schema type 'ns1:Max140Text'
        std::string *RefNb;
        /// Optional element 'Mtd' of XML schema type 'ns1:Max35Text'
        std::string *Mtd;
        /// Optional element 'TtlTaxblBaseAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TtlTaxblBaseAmt;
        /// Optional element 'TtlTaxAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TtlTaxAmt;
        /// Optional element 'Dt' of XML schema type 'ns1:ISODate'
        std::string *Dt;
        /// Optional element 'SeqNb' of XML schema type 'ns1:Number'
        std::string *SeqNb;
        /// Optional element 'Rcrd' of XML schema type 'ns1:TaxRecord3'
        std::vector<ns1__TaxRecord3 *> Rcrd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxData1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxData1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxData1, default initialized and not managed by a soap context
        virtual ns1__TaxData1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxData1); }
      public:
        /// Constructor with default initializations
        ns1__TaxData1() : Cdtr(), Dbtr(), UltmtDbtr(), AdmstnZone(), RefNb(), Mtd(), TtlTaxblBaseAmt(), TtlTaxAmt(), Dt(), SeqNb(), Rcrd(), soap() { }
        virtual ~ns1__TaxData1() { }
        /// Friend allocator used by soap_new_ns1__TaxData1(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxData1 * SOAP_FMAC2 soap_instantiate_ns1__TaxData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:362 */
#ifndef SOAP_TYPE_ns1__TaxInformation10
#define SOAP_TYPE_ns1__TaxInformation10 (109)
/* complex XML schema type 'ns1:TaxInformation10': */
class SOAP_CMAC ns1__TaxInformation10 {
      public:
        /// Optional element 'Cdtr' of XML schema type 'ns1:TaxParty1'
        ns1__TaxParty1 *Cdtr;
        /// Optional element 'Dbtr' of XML schema type 'ns1:TaxParty2'
        ns1__TaxParty2 *Dbtr;
        /// Optional element 'AdmstnZone' of XML schema type 'ns1:Max35Text'
        std::string *AdmstnZone;
        /// Optional element 'RefNb' of XML schema type 'ns1:Max140Text'
        std::string *RefNb;
        /// Optional element 'Mtd' of XML schema type 'ns1:Max35Text'
        std::string *Mtd;
        /// Optional element 'TtlTaxblBaseAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TtlTaxblBaseAmt;
        /// Optional element 'TtlTaxAmt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *TtlTaxAmt;
        /// Optional element 'Dt' of XML schema type 'ns1:ISODate'
        std::string *Dt;
        /// Optional element 'SeqNb' of XML schema type 'ns1:Number'
        std::string *SeqNb;
        /// Optional element 'Rcrd' of XML schema type 'ns1:TaxRecord3'
        std::vector<ns1__TaxRecord3 *> Rcrd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxInformation10
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxInformation10; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxInformation10, default initialized and not managed by a soap context
        virtual ns1__TaxInformation10 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxInformation10); }
      public:
        /// Constructor with default initializations
        ns1__TaxInformation10() : Cdtr(), Dbtr(), AdmstnZone(), RefNb(), Mtd(), TtlTaxblBaseAmt(), TtlTaxAmt(), Dt(), SeqNb(), Rcrd(), soap() { }
        virtual ~ns1__TaxInformation10() { }
        /// Friend allocator used by soap_new_ns1__TaxInformation10(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxInformation10 * SOAP_FMAC2 soap_instantiate_ns1__TaxInformation10(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:364 */
#ifndef SOAP_TYPE_ns1__TaxParty1
#define SOAP_TYPE_ns1__TaxParty1 (110)
/* complex XML schema type 'ns1:TaxParty1': */
class SOAP_CMAC ns1__TaxParty1 {
      public:
        /// Optional element 'TaxId' of XML schema type 'ns1:Max35Text'
        std::string *TaxId;
        /// Optional element 'RegnId' of XML schema type 'ns1:Max35Text'
        std::string *RegnId;
        /// Optional element 'TaxTp' of XML schema type 'ns1:Max35Text'
        std::string *TaxTp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxParty1
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxParty1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxParty1, default initialized and not managed by a soap context
        virtual ns1__TaxParty1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxParty1); }
      public:
        /// Constructor with default initializations
        ns1__TaxParty1() : TaxId(), RegnId(), TaxTp(), soap() { }
        virtual ~ns1__TaxParty1() { }
        /// Friend allocator used by soap_new_ns1__TaxParty1(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxParty1 * SOAP_FMAC2 soap_instantiate_ns1__TaxParty1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:366 */
#ifndef SOAP_TYPE_ns1__TaxParty2
#define SOAP_TYPE_ns1__TaxParty2 (111)
/* complex XML schema type 'ns1:TaxParty2': */
class SOAP_CMAC ns1__TaxParty2 {
      public:
        /// Optional element 'TaxId' of XML schema type 'ns1:Max35Text'
        std::string *TaxId;
        /// Optional element 'RegnId' of XML schema type 'ns1:Max35Text'
        std::string *RegnId;
        /// Optional element 'TaxTp' of XML schema type 'ns1:Max35Text'
        std::string *TaxTp;
        /// Optional element 'Authstn' of XML schema type 'ns1:TaxAuthorisation1'
        ns1__TaxAuthorisation1 *Authstn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxParty2
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxParty2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxParty2, default initialized and not managed by a soap context
        virtual ns1__TaxParty2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxParty2); }
      public:
        /// Constructor with default initializations
        ns1__TaxParty2() : TaxId(), RegnId(), TaxTp(), Authstn(), soap() { }
        virtual ~ns1__TaxParty2() { }
        /// Friend allocator used by soap_new_ns1__TaxParty2(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxParty2 * SOAP_FMAC2 soap_instantiate_ns1__TaxParty2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:368 */
#ifndef SOAP_TYPE_ns1__TaxPeriod3
#define SOAP_TYPE_ns1__TaxPeriod3 (112)
/* complex XML schema type 'ns1:TaxPeriod3': */
class SOAP_CMAC ns1__TaxPeriod3 {
      public:
        /// Optional element 'Yr' of XML schema type 'ns1:ISOYear'
        std::string *Yr;
        /// Optional element 'Tp' of XML schema type 'ns1:TaxRecordPeriod1Code'
        enum ns1__TaxRecordPeriod1Code *Tp;
        /// Optional element 'FrToDt' of XML schema type 'ns1:DatePeriod2'
        ns1__DatePeriod2 *FrToDt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxPeriod3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxPeriod3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxPeriod3, default initialized and not managed by a soap context
        virtual ns1__TaxPeriod3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxPeriod3); }
      public:
        /// Constructor with default initializations
        ns1__TaxPeriod3() : Yr(), Tp(), FrToDt(), soap() { }
        virtual ~ns1__TaxPeriod3() { }
        /// Friend allocator used by soap_new_ns1__TaxPeriod3(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxPeriod3 * SOAP_FMAC2 soap_instantiate_ns1__TaxPeriod3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:370 */
#ifndef SOAP_TYPE_ns1__TaxRecord3
#define SOAP_TYPE_ns1__TaxRecord3 (113)
/* complex XML schema type 'ns1:TaxRecord3': */
class SOAP_CMAC ns1__TaxRecord3 {
      public:
        /// Optional element 'Tp' of XML schema type 'ns1:Max35Text'
        std::string *Tp;
        /// Optional element 'Ctgy' of XML schema type 'ns1:Max35Text'
        std::string *Ctgy;
        /// Optional element 'CtgyDtls' of XML schema type 'ns1:Max35Text'
        std::string *CtgyDtls;
        /// Optional element 'DbtrSts' of XML schema type 'ns1:Max35Text'
        std::string *DbtrSts;
        /// Optional element 'CertId' of XML schema type 'ns1:Max35Text'
        std::string *CertId;
        /// Optional element 'FrmsCd' of XML schema type 'ns1:Max35Text'
        std::string *FrmsCd;
        /// Optional element 'Prd' of XML schema type 'ns1:TaxPeriod3'
        ns1__TaxPeriod3 *Prd;
        /// Optional element 'TaxAmt' of XML schema type 'ns1:TaxAmount3'
        ns1__TaxAmount3 *TaxAmt;
        /// Optional element 'AddtlInf' of XML schema type 'ns1:Max140Text'
        std::string *AddtlInf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxRecord3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxRecord3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxRecord3, default initialized and not managed by a soap context
        virtual ns1__TaxRecord3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxRecord3); }
      public:
        /// Constructor with default initializations
        ns1__TaxRecord3() : Tp(), Ctgy(), CtgyDtls(), DbtrSts(), CertId(), FrmsCd(), Prd(), TaxAmt(), AddtlInf(), soap() { }
        virtual ~ns1__TaxRecord3() { }
        /// Friend allocator used by soap_new_ns1__TaxRecord3(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxRecord3 * SOAP_FMAC2 soap_instantiate_ns1__TaxRecord3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:372 */
#ifndef SOAP_TYPE_ns1__TaxRecordDetails3
#define SOAP_TYPE_ns1__TaxRecordDetails3 (114)
/* complex XML schema type 'ns1:TaxRecordDetails3': */
class SOAP_CMAC ns1__TaxRecordDetails3 {
      public:
        /// Optional element 'Prd' of XML schema type 'ns1:TaxPeriod3'
        ns1__TaxPeriod3 *Prd;
        /// Required element 'Amt' of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount'
        ns1__ActiveOrHistoricCurrencyAndAmount *Amt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TaxRecordDetails3
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TaxRecordDetails3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TaxRecordDetails3, default initialized and not managed by a soap context
        virtual ns1__TaxRecordDetails3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TaxRecordDetails3); }
      public:
        /// Constructor with default initializations
        ns1__TaxRecordDetails3() : Prd(), Amt(), soap() { }
        virtual ~ns1__TaxRecordDetails3() { }
        /// Friend allocator used by soap_new_ns1__TaxRecordDetails3(struct soap*, int)
        friend SOAP_FMAC1 ns1__TaxRecordDetails3 * SOAP_FMAC2 soap_instantiate_ns1__TaxRecordDetails3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:180 */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount (18)
/* simple XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount': */
class SOAP_CMAC ns1__ActiveOrHistoricCurrencyAndAmount {
      public:
        /// Simple content of XML schema type 'ns1:ActiveOrHistoricCurrencyAndAmount_SimpleType' wrapped by this struct
        std::string __item;
        /// Required attribute 'Ccy' of XML schema type 'ns1:ActiveOrHistoricCurrencyCode'
        std::string Ccy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActiveOrHistoricCurrencyAndAmount, default initialized and not managed by a soap context
        virtual ns1__ActiveOrHistoricCurrencyAndAmount *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ActiveOrHistoricCurrencyAndAmount); }
      public:
        /// Constructor with default initializations
        ns1__ActiveOrHistoricCurrencyAndAmount() : __item(), Ccy(), soap() { }
        virtual ~ns1__ActiveOrHistoricCurrencyAndAmount() { }
        /// Friend allocator used by soap_new_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActiveOrHistoricCurrencyAndAmount * SOAP_FMAC2 soap_instantiate_ns1__ActiveOrHistoricCurrencyAndAmount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* pain.h:3797 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (393)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* pain.h:3797 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (394)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* pain.h:3797 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (396)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* pain.h:3797 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (399)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* pain.h:3797 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (400)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* pain.h:160 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (13)
typedef std::string xsd__date;
#endif

/* pain.h:163 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (14)
typedef std::string xsd__decimal;
#endif

/* pain.h:166 */
#ifndef SOAP_TYPE_xsd__gYear
#define SOAP_TYPE_xsd__gYear (15)
typedef std::string xsd__gYear;
#endif

/* pain.h:387 */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType (115)
typedef xsd__decimal ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType;
#endif

/* pain.h:392 */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode (116)
typedef std::string ns1__ActiveOrHistoricCurrencyCode;
#endif

/* pain.h:419 */
#ifndef SOAP_TYPE_ns1__AnyBICDec2014Identifier
#define SOAP_TYPE_ns1__AnyBICDec2014Identifier (119)
typedef std::string ns1__AnyBICDec2014Identifier;
#endif

/* pain.h:435 */
#ifndef SOAP_TYPE_ns1__BICFIDec2014Identifier
#define SOAP_TYPE_ns1__BICFIDec2014Identifier (121)
typedef std::string ns1__BICFIDec2014Identifier;
#endif

/* pain.h:441 */
#ifndef SOAP_TYPE_ns1__BaseOneRate
#define SOAP_TYPE_ns1__BaseOneRate (122)
typedef xsd__decimal ns1__BaseOneRate;
#endif

/* pain.h:445 */
#ifndef SOAP_TYPE_ns1__BatchBookingIndicator
#define SOAP_TYPE_ns1__BatchBookingIndicator (124)
typedef bool ns1__BatchBookingIndicator;
#endif

/* pain.h:492 */
#ifndef SOAP_TYPE_ns1__CountryCode
#define SOAP_TYPE_ns1__CountryCode (128)
typedef std::string ns1__CountryCode;
#endif

/* pain.h:507 */
#ifndef SOAP_TYPE_ns1__DecimalNumber
#define SOAP_TYPE_ns1__DecimalNumber (130)
typedef xsd__decimal ns1__DecimalNumber;
#endif

/* pain.h:548 */
#ifndef SOAP_TYPE_ns1__Exact2NumericText
#define SOAP_TYPE_ns1__Exact2NumericText (133)
typedef std::string ns1__Exact2NumericText;
#endif

/* pain.h:553 */
#ifndef SOAP_TYPE_ns1__Exact4AlphaNumericText
#define SOAP_TYPE_ns1__Exact4AlphaNumericText (134)
typedef std::string ns1__Exact4AlphaNumericText;
#endif

/* pain.h:568 */
#ifndef SOAP_TYPE_ns1__ExternalAccountIdentification1Code
#define SOAP_TYPE_ns1__ExternalAccountIdentification1Code (136)
typedef std::string ns1__ExternalAccountIdentification1Code;
#endif

/* pain.h:573 */
#ifndef SOAP_TYPE_ns1__ExternalCashAccountType1Code
#define SOAP_TYPE_ns1__ExternalCashAccountType1Code (137)
typedef std::string ns1__ExternalCashAccountType1Code;
#endif

/* pain.h:578 */
#ifndef SOAP_TYPE_ns1__ExternalCategoryPurpose1Code
#define SOAP_TYPE_ns1__ExternalCategoryPurpose1Code (138)
typedef std::string ns1__ExternalCategoryPurpose1Code;
#endif

/* pain.h:583 */
#ifndef SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code
#define SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code (139)
typedef std::string ns1__ExternalClearingSystemIdentification1Code;
#endif

/* pain.h:588 */
#ifndef SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code
#define SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code (140)
typedef std::string ns1__ExternalCreditorAgentInstruction1Code;
#endif

/* pain.h:593 */
#ifndef SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code
#define SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code (141)
typedef std::string ns1__ExternalDebtorAgentInstruction1Code;
#endif

/* pain.h:598 */
#ifndef SOAP_TYPE_ns1__ExternalDiscountAmountType1Code
#define SOAP_TYPE_ns1__ExternalDiscountAmountType1Code (142)
typedef std::string ns1__ExternalDiscountAmountType1Code;
#endif

/* pain.h:603 */
#ifndef SOAP_TYPE_ns1__ExternalDocumentLineType1Code
#define SOAP_TYPE_ns1__ExternalDocumentLineType1Code (143)
typedef std::string ns1__ExternalDocumentLineType1Code;
#endif

/* pain.h:608 */
#ifndef SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code
#define SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code (144)
typedef std::string ns1__ExternalFinancialInstitutionIdentification1Code;
#endif

/* pain.h:613 */
#ifndef SOAP_TYPE_ns1__ExternalGarnishmentType1Code
#define SOAP_TYPE_ns1__ExternalGarnishmentType1Code (145)
typedef std::string ns1__ExternalGarnishmentType1Code;
#endif

/* pain.h:618 */
#ifndef SOAP_TYPE_ns1__ExternalLocalInstrument1Code
#define SOAP_TYPE_ns1__ExternalLocalInstrument1Code (146)
typedef std::string ns1__ExternalLocalInstrument1Code;
#endif

/* pain.h:623 */
#ifndef SOAP_TYPE_ns1__ExternalMandateSetupReason1Code
#define SOAP_TYPE_ns1__ExternalMandateSetupReason1Code (147)
typedef std::string ns1__ExternalMandateSetupReason1Code;
#endif

/* pain.h:628 */
#ifndef SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code
#define SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code (148)
typedef std::string ns1__ExternalOrganisationIdentification1Code;
#endif

/* pain.h:633 */
#ifndef SOAP_TYPE_ns1__ExternalPersonIdentification1Code
#define SOAP_TYPE_ns1__ExternalPersonIdentification1Code (149)
typedef std::string ns1__ExternalPersonIdentification1Code;
#endif

/* pain.h:638 */
#ifndef SOAP_TYPE_ns1__ExternalProxyAccountType1Code
#define SOAP_TYPE_ns1__ExternalProxyAccountType1Code (150)
typedef std::string ns1__ExternalProxyAccountType1Code;
#endif

/* pain.h:643 */
#ifndef SOAP_TYPE_ns1__ExternalPurpose1Code
#define SOAP_TYPE_ns1__ExternalPurpose1Code (151)
typedef std::string ns1__ExternalPurpose1Code;
#endif

/* pain.h:648 */
#ifndef SOAP_TYPE_ns1__ExternalServiceLevel1Code
#define SOAP_TYPE_ns1__ExternalServiceLevel1Code (152)
typedef std::string ns1__ExternalServiceLevel1Code;
#endif

/* pain.h:653 */
#ifndef SOAP_TYPE_ns1__ExternalTaxAmountType1Code
#define SOAP_TYPE_ns1__ExternalTaxAmountType1Code (153)
typedef std::string ns1__ExternalTaxAmountType1Code;
#endif

/* pain.h:674 */
#ifndef SOAP_TYPE_ns1__IBAN2007Identifier
#define SOAP_TYPE_ns1__IBAN2007Identifier (155)
typedef std::string ns1__IBAN2007Identifier;
#endif

/* pain.h:678 */
#ifndef SOAP_TYPE_ns1__ISODate
#define SOAP_TYPE_ns1__ISODate (156)
typedef xsd__date ns1__ISODate;
#endif

/* pain.h:682 */
#ifndef SOAP_TYPE_ns1__ISODateTime
#define SOAP_TYPE_ns1__ISODateTime (158)
typedef time_t ns1__ISODateTime;
#endif

/* pain.h:686 */
#ifndef SOAP_TYPE_ns1__ISOYear
#define SOAP_TYPE_ns1__ISOYear (159)
typedef xsd__gYear ns1__ISOYear;
#endif

/* pain.h:691 */
#ifndef SOAP_TYPE_ns1__LEIIdentifier
#define SOAP_TYPE_ns1__LEIIdentifier (160)
typedef std::string ns1__LEIIdentifier;
#endif

/* pain.h:706 */
#ifndef SOAP_TYPE_ns1__Max10KBinary
#define SOAP_TYPE_ns1__Max10KBinary (162)
typedef xsd__base64Binary ns1__Max10KBinary;
#endif

/* pain.h:711 */
#ifndef SOAP_TYPE_ns1__Max10Text
#define SOAP_TYPE_ns1__Max10Text (163)
typedef std::string ns1__Max10Text;
#endif

/* pain.h:716 */
#ifndef SOAP_TYPE_ns1__Max128Text
#define SOAP_TYPE_ns1__Max128Text (164)
typedef std::string ns1__Max128Text;
#endif

/* pain.h:721 */
#ifndef SOAP_TYPE_ns1__Max140Text
#define SOAP_TYPE_ns1__Max140Text (165)
typedef std::string ns1__Max140Text;
#endif

/* pain.h:726 */
#ifndef SOAP_TYPE_ns1__Max15NumericText
#define SOAP_TYPE_ns1__Max15NumericText (166)
typedef std::string ns1__Max15NumericText;
#endif

/* pain.h:731 */
#ifndef SOAP_TYPE_ns1__Max16Text
#define SOAP_TYPE_ns1__Max16Text (167)
typedef std::string ns1__Max16Text;
#endif

/* pain.h:736 */
#ifndef SOAP_TYPE_ns1__Max2048Text
#define SOAP_TYPE_ns1__Max2048Text (168)
typedef std::string ns1__Max2048Text;
#endif

/* pain.h:741 */
#ifndef SOAP_TYPE_ns1__Max34Text
#define SOAP_TYPE_ns1__Max34Text (169)
typedef std::string ns1__Max34Text;
#endif

/* pain.h:746 */
#ifndef SOAP_TYPE_ns1__Max350Text
#define SOAP_TYPE_ns1__Max350Text (170)
typedef std::string ns1__Max350Text;
#endif

/* pain.h:751 */
#ifndef SOAP_TYPE_ns1__Max35Text
#define SOAP_TYPE_ns1__Max35Text (171)
typedef std::string ns1__Max35Text;
#endif

/* pain.h:756 */
#ifndef SOAP_TYPE_ns1__Max4Text
#define SOAP_TYPE_ns1__Max4Text (172)
typedef std::string ns1__Max4Text;
#endif

/* pain.h:761 */
#ifndef SOAP_TYPE_ns1__Max70Text
#define SOAP_TYPE_ns1__Max70Text (173)
typedef std::string ns1__Max70Text;
#endif

/* pain.h:779 */
#ifndef SOAP_TYPE_ns1__Number
#define SOAP_TYPE_ns1__Number (175)
typedef xsd__decimal ns1__Number;
#endif

/* pain.h:795 */
#ifndef SOAP_TYPE_ns1__PercentageRate
#define SOAP_TYPE_ns1__PercentageRate (177)
typedef xsd__decimal ns1__PercentageRate;
#endif

/* pain.h:800 */
#ifndef SOAP_TYPE_ns1__PhoneNumber
#define SOAP_TYPE_ns1__PhoneNumber (178)
typedef std::string ns1__PhoneNumber;
#endif

/* pain.h:873 */
#ifndef SOAP_TYPE_ns1__TrueFalseIndicator
#define SOAP_TYPE_ns1__TrueFalseIndicator (184)
typedef bool ns1__TrueFalseIndicator;
#endif

/* pain.h:878 */
#ifndef SOAP_TYPE_ns1__UUIDv4Identifier
#define SOAP_TYPE_ns1__UUIDv4Identifier (185)
typedef std::string ns1__UUIDv4Identifier;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (10)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (9)
#endif

/* ns1__ISODateTime has binding name 'ns1__ISODateTime' for type 'ns1:ISODateTime' */
#ifndef SOAP_TYPE_ns1__ISODateTime
#define SOAP_TYPE_ns1__ISODateTime (158)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (157)
#endif

/* ns1__TrueFalseIndicator has binding name 'ns1__TrueFalseIndicator' for type 'ns1:TrueFalseIndicator' */
#ifndef SOAP_TYPE_ns1__TrueFalseIndicator
#define SOAP_TYPE_ns1__TrueFalseIndicator (184)
#endif

/* enum ns1__TaxRecordPeriod1Code has binding name 'ns1__TaxRecordPeriod1Code' for type 'ns1:TaxRecordPeriod1Code' */
#ifndef SOAP_TYPE_ns1__TaxRecordPeriod1Code
#define SOAP_TYPE_ns1__TaxRecordPeriod1Code (183)
#endif

/* enum ns1__RemittanceLocationMethod2Code has binding name 'ns1__RemittanceLocationMethod2Code' for type 'ns1:RemittanceLocationMethod2Code' */
#ifndef SOAP_TYPE_ns1__RemittanceLocationMethod2Code
#define SOAP_TYPE_ns1__RemittanceLocationMethod2Code (182)
#endif

/* enum ns1__RegulatoryReportingType1Code has binding name 'ns1__RegulatoryReportingType1Code' for type 'ns1:RegulatoryReportingType1Code' */
#ifndef SOAP_TYPE_ns1__RegulatoryReportingType1Code
#define SOAP_TYPE_ns1__RegulatoryReportingType1Code (181)
#endif

/* enum ns1__Priority2Code has binding name 'ns1__Priority2Code' for type 'ns1:Priority2Code' */
#ifndef SOAP_TYPE_ns1__Priority2Code
#define SOAP_TYPE_ns1__Priority2Code (180)
#endif

/* enum ns1__PreferredContactMethod1Code has binding name 'ns1__PreferredContactMethod1Code' for type 'ns1:PreferredContactMethod1Code' */
#ifndef SOAP_TYPE_ns1__PreferredContactMethod1Code
#define SOAP_TYPE_ns1__PreferredContactMethod1Code (179)
#endif

/* enum ns1__PaymentMethod3Code has binding name 'ns1__PaymentMethod3Code' for type 'ns1:PaymentMethod3Code' */
#ifndef SOAP_TYPE_ns1__PaymentMethod3Code
#define SOAP_TYPE_ns1__PaymentMethod3Code (176)
#endif

/* enum ns1__NamePrefix2Code has binding name 'ns1__NamePrefix2Code' for type 'ns1:NamePrefix2Code' */
#ifndef SOAP_TYPE_ns1__NamePrefix2Code
#define SOAP_TYPE_ns1__NamePrefix2Code (174)
#endif

/* enum ns1__MandateClassification1Code has binding name 'ns1__MandateClassification1Code' for type 'ns1:MandateClassification1Code' */
#ifndef SOAP_TYPE_ns1__MandateClassification1Code
#define SOAP_TYPE_ns1__MandateClassification1Code (161)
#endif

/* enum ns1__Frequency6Code has binding name 'ns1__Frequency6Code' for type 'ns1:Frequency6Code' */
#ifndef SOAP_TYPE_ns1__Frequency6Code
#define SOAP_TYPE_ns1__Frequency6Code (154)
#endif

/* enum ns1__ExchangeRateType1Code has binding name 'ns1__ExchangeRateType1Code' for type 'ns1:ExchangeRateType1Code' */
#ifndef SOAP_TYPE_ns1__ExchangeRateType1Code
#define SOAP_TYPE_ns1__ExchangeRateType1Code (135)
#endif

/* enum ns1__DocumentType6Code has binding name 'ns1__DocumentType6Code' for type 'ns1:DocumentType6Code' */
#ifndef SOAP_TYPE_ns1__DocumentType6Code
#define SOAP_TYPE_ns1__DocumentType6Code (132)
#endif

/* enum ns1__DocumentType3Code has binding name 'ns1__DocumentType3Code' for type 'ns1:DocumentType3Code' */
#ifndef SOAP_TYPE_ns1__DocumentType3Code
#define SOAP_TYPE_ns1__DocumentType3Code (131)
#endif

/* enum ns1__CreditDebitCode has binding name 'ns1__CreditDebitCode' for type 'ns1:CreditDebitCode' */
#ifndef SOAP_TYPE_ns1__CreditDebitCode
#define SOAP_TYPE_ns1__CreditDebitCode (129)
#endif

/* enum ns1__ChequeType2Code has binding name 'ns1__ChequeType2Code' for type 'ns1:ChequeType2Code' */
#ifndef SOAP_TYPE_ns1__ChequeType2Code
#define SOAP_TYPE_ns1__ChequeType2Code (127)
#endif

/* enum ns1__ChequeDelivery1Code has binding name 'ns1__ChequeDelivery1Code' for type 'ns1:ChequeDelivery1Code' */
#ifndef SOAP_TYPE_ns1__ChequeDelivery1Code
#define SOAP_TYPE_ns1__ChequeDelivery1Code (126)
#endif

/* enum ns1__ChargeBearerType1Code has binding name 'ns1__ChargeBearerType1Code' for type 'ns1:ChargeBearerType1Code' */
#ifndef SOAP_TYPE_ns1__ChargeBearerType1Code
#define SOAP_TYPE_ns1__ChargeBearerType1Code (125)
#endif

/* ns1__BatchBookingIndicator has binding name 'ns1__BatchBookingIndicator' for type 'ns1:BatchBookingIndicator' */
#ifndef SOAP_TYPE_ns1__BatchBookingIndicator
#define SOAP_TYPE_ns1__BatchBookingIndicator (124)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (123)
#endif

/* enum ns1__Authorisation1Code has binding name 'ns1__Authorisation1Code' for type 'ns1:Authorisation1Code' */
#ifndef SOAP_TYPE_ns1__Authorisation1Code
#define SOAP_TYPE_ns1__Authorisation1Code (120)
#endif

/* enum ns1__AdviceType1Code has binding name 'ns1__AdviceType1Code' for type 'ns1:AdviceType1Code' */
#ifndef SOAP_TYPE_ns1__AdviceType1Code
#define SOAP_TYPE_ns1__AdviceType1Code (118)
#endif

/* enum ns1__AddressType2Code has binding name 'ns1__AddressType2Code' for type 'ns1:AddressType2Code' */
#ifndef SOAP_TYPE_ns1__AddressType2Code
#define SOAP_TYPE_ns1__AddressType2Code (117)
#endif

/* ns1__UUIDv4Identifier has binding name 'ns1__UUIDv4Identifier' for type 'ns1:UUIDv4Identifier' */
#ifndef SOAP_TYPE_ns1__UUIDv4Identifier
#define SOAP_TYPE_ns1__UUIDv4Identifier (185)
#endif

/* ns1__PhoneNumber has binding name 'ns1__PhoneNumber' for type 'ns1:PhoneNumber' */
#ifndef SOAP_TYPE_ns1__PhoneNumber
#define SOAP_TYPE_ns1__PhoneNumber (178)
#endif

/* ns1__PercentageRate has binding name 'ns1__PercentageRate' for type 'ns1:PercentageRate' */
#ifndef SOAP_TYPE_ns1__PercentageRate
#define SOAP_TYPE_ns1__PercentageRate (177)
#endif

/* ns1__Number has binding name 'ns1__Number' for type 'ns1:Number' */
#ifndef SOAP_TYPE_ns1__Number
#define SOAP_TYPE_ns1__Number (175)
#endif

/* ns1__Max70Text has binding name 'ns1__Max70Text' for type 'ns1:Max70Text' */
#ifndef SOAP_TYPE_ns1__Max70Text
#define SOAP_TYPE_ns1__Max70Text (173)
#endif

/* ns1__Max4Text has binding name 'ns1__Max4Text' for type 'ns1:Max4Text' */
#ifndef SOAP_TYPE_ns1__Max4Text
#define SOAP_TYPE_ns1__Max4Text (172)
#endif

/* ns1__Max35Text has binding name 'ns1__Max35Text' for type 'ns1:Max35Text' */
#ifndef SOAP_TYPE_ns1__Max35Text
#define SOAP_TYPE_ns1__Max35Text (171)
#endif

/* ns1__Max350Text has binding name 'ns1__Max350Text' for type 'ns1:Max350Text' */
#ifndef SOAP_TYPE_ns1__Max350Text
#define SOAP_TYPE_ns1__Max350Text (170)
#endif

/* ns1__Max34Text has binding name 'ns1__Max34Text' for type 'ns1:Max34Text' */
#ifndef SOAP_TYPE_ns1__Max34Text
#define SOAP_TYPE_ns1__Max34Text (169)
#endif

/* ns1__Max2048Text has binding name 'ns1__Max2048Text' for type 'ns1:Max2048Text' */
#ifndef SOAP_TYPE_ns1__Max2048Text
#define SOAP_TYPE_ns1__Max2048Text (168)
#endif

/* ns1__Max16Text has binding name 'ns1__Max16Text' for type 'ns1:Max16Text' */
#ifndef SOAP_TYPE_ns1__Max16Text
#define SOAP_TYPE_ns1__Max16Text (167)
#endif

/* ns1__Max15NumericText has binding name 'ns1__Max15NumericText' for type 'ns1:Max15NumericText' */
#ifndef SOAP_TYPE_ns1__Max15NumericText
#define SOAP_TYPE_ns1__Max15NumericText (166)
#endif

/* ns1__Max140Text has binding name 'ns1__Max140Text' for type 'ns1:Max140Text' */
#ifndef SOAP_TYPE_ns1__Max140Text
#define SOAP_TYPE_ns1__Max140Text (165)
#endif

/* ns1__Max128Text has binding name 'ns1__Max128Text' for type 'ns1:Max128Text' */
#ifndef SOAP_TYPE_ns1__Max128Text
#define SOAP_TYPE_ns1__Max128Text (164)
#endif

/* ns1__Max10Text has binding name 'ns1__Max10Text' for type 'ns1:Max10Text' */
#ifndef SOAP_TYPE_ns1__Max10Text
#define SOAP_TYPE_ns1__Max10Text (163)
#endif

/* ns1__Max10KBinary has binding name 'ns1__Max10KBinary' for type 'ns1:Max10KBinary' */
#ifndef SOAP_TYPE_ns1__Max10KBinary
#define SOAP_TYPE_ns1__Max10KBinary (162)
#endif

/* ns1__LEIIdentifier has binding name 'ns1__LEIIdentifier' for type 'ns1:LEIIdentifier' */
#ifndef SOAP_TYPE_ns1__LEIIdentifier
#define SOAP_TYPE_ns1__LEIIdentifier (160)
#endif

/* ns1__ISOYear has binding name 'ns1__ISOYear' for type 'ns1:ISOYear' */
#ifndef SOAP_TYPE_ns1__ISOYear
#define SOAP_TYPE_ns1__ISOYear (159)
#endif

/* ns1__ISODate has binding name 'ns1__ISODate' for type 'ns1:ISODate' */
#ifndef SOAP_TYPE_ns1__ISODate
#define SOAP_TYPE_ns1__ISODate (156)
#endif

/* ns1__IBAN2007Identifier has binding name 'ns1__IBAN2007Identifier' for type 'ns1:IBAN2007Identifier' */
#ifndef SOAP_TYPE_ns1__IBAN2007Identifier
#define SOAP_TYPE_ns1__IBAN2007Identifier (155)
#endif

/* ns1__ExternalTaxAmountType1Code has binding name 'ns1__ExternalTaxAmountType1Code' for type 'ns1:ExternalTaxAmountType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalTaxAmountType1Code
#define SOAP_TYPE_ns1__ExternalTaxAmountType1Code (153)
#endif

/* ns1__ExternalServiceLevel1Code has binding name 'ns1__ExternalServiceLevel1Code' for type 'ns1:ExternalServiceLevel1Code' */
#ifndef SOAP_TYPE_ns1__ExternalServiceLevel1Code
#define SOAP_TYPE_ns1__ExternalServiceLevel1Code (152)
#endif

/* ns1__ExternalPurpose1Code has binding name 'ns1__ExternalPurpose1Code' for type 'ns1:ExternalPurpose1Code' */
#ifndef SOAP_TYPE_ns1__ExternalPurpose1Code
#define SOAP_TYPE_ns1__ExternalPurpose1Code (151)
#endif

/* ns1__ExternalProxyAccountType1Code has binding name 'ns1__ExternalProxyAccountType1Code' for type 'ns1:ExternalProxyAccountType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalProxyAccountType1Code
#define SOAP_TYPE_ns1__ExternalProxyAccountType1Code (150)
#endif

/* ns1__ExternalPersonIdentification1Code has binding name 'ns1__ExternalPersonIdentification1Code' for type 'ns1:ExternalPersonIdentification1Code' */
#ifndef SOAP_TYPE_ns1__ExternalPersonIdentification1Code
#define SOAP_TYPE_ns1__ExternalPersonIdentification1Code (149)
#endif

/* ns1__ExternalOrganisationIdentification1Code has binding name 'ns1__ExternalOrganisationIdentification1Code' for type 'ns1:ExternalOrganisationIdentification1Code' */
#ifndef SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code
#define SOAP_TYPE_ns1__ExternalOrganisationIdentification1Code (148)
#endif

/* ns1__ExternalMandateSetupReason1Code has binding name 'ns1__ExternalMandateSetupReason1Code' for type 'ns1:ExternalMandateSetupReason1Code' */
#ifndef SOAP_TYPE_ns1__ExternalMandateSetupReason1Code
#define SOAP_TYPE_ns1__ExternalMandateSetupReason1Code (147)
#endif

/* ns1__ExternalLocalInstrument1Code has binding name 'ns1__ExternalLocalInstrument1Code' for type 'ns1:ExternalLocalInstrument1Code' */
#ifndef SOAP_TYPE_ns1__ExternalLocalInstrument1Code
#define SOAP_TYPE_ns1__ExternalLocalInstrument1Code (146)
#endif

/* ns1__ExternalGarnishmentType1Code has binding name 'ns1__ExternalGarnishmentType1Code' for type 'ns1:ExternalGarnishmentType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalGarnishmentType1Code
#define SOAP_TYPE_ns1__ExternalGarnishmentType1Code (145)
#endif

/* ns1__ExternalFinancialInstitutionIdentification1Code has binding name 'ns1__ExternalFinancialInstitutionIdentification1Code' for type 'ns1:ExternalFinancialInstitutionIdentification1Code' */
#ifndef SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code
#define SOAP_TYPE_ns1__ExternalFinancialInstitutionIdentification1Code (144)
#endif

/* ns1__ExternalDocumentLineType1Code has binding name 'ns1__ExternalDocumentLineType1Code' for type 'ns1:ExternalDocumentLineType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalDocumentLineType1Code
#define SOAP_TYPE_ns1__ExternalDocumentLineType1Code (143)
#endif

/* ns1__ExternalDiscountAmountType1Code has binding name 'ns1__ExternalDiscountAmountType1Code' for type 'ns1:ExternalDiscountAmountType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalDiscountAmountType1Code
#define SOAP_TYPE_ns1__ExternalDiscountAmountType1Code (142)
#endif

/* ns1__ExternalDebtorAgentInstruction1Code has binding name 'ns1__ExternalDebtorAgentInstruction1Code' for type 'ns1:ExternalDebtorAgentInstruction1Code' */
#ifndef SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code
#define SOAP_TYPE_ns1__ExternalDebtorAgentInstruction1Code (141)
#endif

/* ns1__ExternalCreditorAgentInstruction1Code has binding name 'ns1__ExternalCreditorAgentInstruction1Code' for type 'ns1:ExternalCreditorAgentInstruction1Code' */
#ifndef SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code
#define SOAP_TYPE_ns1__ExternalCreditorAgentInstruction1Code (140)
#endif

/* ns1__ExternalClearingSystemIdentification1Code has binding name 'ns1__ExternalClearingSystemIdentification1Code' for type 'ns1:ExternalClearingSystemIdentification1Code' */
#ifndef SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code
#define SOAP_TYPE_ns1__ExternalClearingSystemIdentification1Code (139)
#endif

/* ns1__ExternalCategoryPurpose1Code has binding name 'ns1__ExternalCategoryPurpose1Code' for type 'ns1:ExternalCategoryPurpose1Code' */
#ifndef SOAP_TYPE_ns1__ExternalCategoryPurpose1Code
#define SOAP_TYPE_ns1__ExternalCategoryPurpose1Code (138)
#endif

/* ns1__ExternalCashAccountType1Code has binding name 'ns1__ExternalCashAccountType1Code' for type 'ns1:ExternalCashAccountType1Code' */
#ifndef SOAP_TYPE_ns1__ExternalCashAccountType1Code
#define SOAP_TYPE_ns1__ExternalCashAccountType1Code (137)
#endif

/* ns1__ExternalAccountIdentification1Code has binding name 'ns1__ExternalAccountIdentification1Code' for type 'ns1:ExternalAccountIdentification1Code' */
#ifndef SOAP_TYPE_ns1__ExternalAccountIdentification1Code
#define SOAP_TYPE_ns1__ExternalAccountIdentification1Code (136)
#endif

/* ns1__Exact4AlphaNumericText has binding name 'ns1__Exact4AlphaNumericText' for type 'ns1:Exact4AlphaNumericText' */
#ifndef SOAP_TYPE_ns1__Exact4AlphaNumericText
#define SOAP_TYPE_ns1__Exact4AlphaNumericText (134)
#endif

/* ns1__Exact2NumericText has binding name 'ns1__Exact2NumericText' for type 'ns1:Exact2NumericText' */
#ifndef SOAP_TYPE_ns1__Exact2NumericText
#define SOAP_TYPE_ns1__Exact2NumericText (133)
#endif

/* ns1__DecimalNumber has binding name 'ns1__DecimalNumber' for type 'ns1:DecimalNumber' */
#ifndef SOAP_TYPE_ns1__DecimalNumber
#define SOAP_TYPE_ns1__DecimalNumber (130)
#endif

/* ns1__CountryCode has binding name 'ns1__CountryCode' for type 'ns1:CountryCode' */
#ifndef SOAP_TYPE_ns1__CountryCode
#define SOAP_TYPE_ns1__CountryCode (128)
#endif

/* ns1__BaseOneRate has binding name 'ns1__BaseOneRate' for type 'ns1:BaseOneRate' */
#ifndef SOAP_TYPE_ns1__BaseOneRate
#define SOAP_TYPE_ns1__BaseOneRate (122)
#endif

/* ns1__BICFIDec2014Identifier has binding name 'ns1__BICFIDec2014Identifier' for type 'ns1:BICFIDec2014Identifier' */
#ifndef SOAP_TYPE_ns1__BICFIDec2014Identifier
#define SOAP_TYPE_ns1__BICFIDec2014Identifier (121)
#endif

/* ns1__AnyBICDec2014Identifier has binding name 'ns1__AnyBICDec2014Identifier' for type 'ns1:AnyBICDec2014Identifier' */
#ifndef SOAP_TYPE_ns1__AnyBICDec2014Identifier
#define SOAP_TYPE_ns1__AnyBICDec2014Identifier (119)
#endif

/* ns1__ActiveOrHistoricCurrencyCode has binding name 'ns1__ActiveOrHistoricCurrencyCode' for type 'ns1:ActiveOrHistoricCurrencyCode' */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyCode (116)
#endif

/* ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType has binding name 'ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType' for type 'ns1:ActiveOrHistoricCurrencyAndAmount_SimpleType' */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount_USCORESimpleType (115)
#endif

/* ns1__TaxRecordDetails3 has binding name 'ns1__TaxRecordDetails3' for type 'ns1:TaxRecordDetails3' */
#ifndef SOAP_TYPE_ns1__TaxRecordDetails3
#define SOAP_TYPE_ns1__TaxRecordDetails3 (114)
#endif

/* ns1__TaxRecord3 has binding name 'ns1__TaxRecord3' for type 'ns1:TaxRecord3' */
#ifndef SOAP_TYPE_ns1__TaxRecord3
#define SOAP_TYPE_ns1__TaxRecord3 (113)
#endif

/* ns1__TaxPeriod3 has binding name 'ns1__TaxPeriod3' for type 'ns1:TaxPeriod3' */
#ifndef SOAP_TYPE_ns1__TaxPeriod3
#define SOAP_TYPE_ns1__TaxPeriod3 (112)
#endif

/* ns1__TaxParty2 has binding name 'ns1__TaxParty2' for type 'ns1:TaxParty2' */
#ifndef SOAP_TYPE_ns1__TaxParty2
#define SOAP_TYPE_ns1__TaxParty2 (111)
#endif

/* ns1__TaxParty1 has binding name 'ns1__TaxParty1' for type 'ns1:TaxParty1' */
#ifndef SOAP_TYPE_ns1__TaxParty1
#define SOAP_TYPE_ns1__TaxParty1 (110)
#endif

/* ns1__TaxInformation10 has binding name 'ns1__TaxInformation10' for type 'ns1:TaxInformation10' */
#ifndef SOAP_TYPE_ns1__TaxInformation10
#define SOAP_TYPE_ns1__TaxInformation10 (109)
#endif

/* ns1__TaxData1 has binding name 'ns1__TaxData1' for type 'ns1:TaxData1' */
#ifndef SOAP_TYPE_ns1__TaxData1
#define SOAP_TYPE_ns1__TaxData1 (108)
#endif

/* ns1__TaxAuthorisation1 has binding name 'ns1__TaxAuthorisation1' for type 'ns1:TaxAuthorisation1' */
#ifndef SOAP_TYPE_ns1__TaxAuthorisation1
#define SOAP_TYPE_ns1__TaxAuthorisation1 (107)
#endif

/* ns1__TaxAmountType1Choice has binding name 'ns1__TaxAmountType1Choice' for type 'ns1:TaxAmountType1Choice' */
#ifndef SOAP_TYPE_ns1__TaxAmountType1Choice
#define SOAP_TYPE_ns1__TaxAmountType1Choice (106)
#endif

/* ns1__TaxAmountAndType1 has binding name 'ns1__TaxAmountAndType1' for type 'ns1:TaxAmountAndType1' */
#ifndef SOAP_TYPE_ns1__TaxAmountAndType1
#define SOAP_TYPE_ns1__TaxAmountAndType1 (105)
#endif

/* ns1__TaxAmount3 has binding name 'ns1__TaxAmount3' for type 'ns1:TaxAmount3' */
#ifndef SOAP_TYPE_ns1__TaxAmount3
#define SOAP_TYPE_ns1__TaxAmount3 (104)
#endif

/* ns1__SupplementaryDataEnvelope1 has binding name 'ns1__SupplementaryDataEnvelope1' for type 'ns1:SupplementaryDataEnvelope1' */
#ifndef SOAP_TYPE_ns1__SupplementaryDataEnvelope1
#define SOAP_TYPE_ns1__SupplementaryDataEnvelope1 (103)
#endif

/* ns1__SupplementaryData1 has binding name 'ns1__SupplementaryData1' for type 'ns1:SupplementaryData1' */
#ifndef SOAP_TYPE_ns1__SupplementaryData1
#define SOAP_TYPE_ns1__SupplementaryData1 (102)
#endif

/* ns1__StructuredRemittanceInformation17 has binding name 'ns1__StructuredRemittanceInformation17' for type 'ns1:StructuredRemittanceInformation17' */
#ifndef SOAP_TYPE_ns1__StructuredRemittanceInformation17
#define SOAP_TYPE_ns1__StructuredRemittanceInformation17 (101)
#endif

/* ns1__StructuredRegulatoryReporting3 has binding name 'ns1__StructuredRegulatoryReporting3' for type 'ns1:StructuredRegulatoryReporting3' */
#ifndef SOAP_TYPE_ns1__StructuredRegulatoryReporting3
#define SOAP_TYPE_ns1__StructuredRegulatoryReporting3 (100)
#endif

/* ns1__ServiceLevel8Choice has binding name 'ns1__ServiceLevel8Choice' for type 'ns1:ServiceLevel8Choice' */
#ifndef SOAP_TYPE_ns1__ServiceLevel8Choice
#define SOAP_TYPE_ns1__ServiceLevel8Choice (99)
#endif

/* ns1__RemittanceLocationData1 has binding name 'ns1__RemittanceLocationData1' for type 'ns1:RemittanceLocationData1' */
#ifndef SOAP_TYPE_ns1__RemittanceLocationData1
#define SOAP_TYPE_ns1__RemittanceLocationData1 (98)
#endif

/* ns1__RemittanceLocation7 has binding name 'ns1__RemittanceLocation7' for type 'ns1:RemittanceLocation7' */
#ifndef SOAP_TYPE_ns1__RemittanceLocation7
#define SOAP_TYPE_ns1__RemittanceLocation7 (97)
#endif

/* ns1__RemittanceInformation21 has binding name 'ns1__RemittanceInformation21' for type 'ns1:RemittanceInformation21' */
#ifndef SOAP_TYPE_ns1__RemittanceInformation21
#define SOAP_TYPE_ns1__RemittanceInformation21 (96)
#endif

/* ns1__RemittanceAmount3 has binding name 'ns1__RemittanceAmount3' for type 'ns1:RemittanceAmount3' */
#ifndef SOAP_TYPE_ns1__RemittanceAmount3
#define SOAP_TYPE_ns1__RemittanceAmount3 (95)
#endif

/* ns1__RemittanceAmount2 has binding name 'ns1__RemittanceAmount2' for type 'ns1:RemittanceAmount2' */
#ifndef SOAP_TYPE_ns1__RemittanceAmount2
#define SOAP_TYPE_ns1__RemittanceAmount2 (94)
#endif

/* ns1__RegulatoryReporting3 has binding name 'ns1__RegulatoryReporting3' for type 'ns1:RegulatoryReporting3' */
#ifndef SOAP_TYPE_ns1__RegulatoryReporting3
#define SOAP_TYPE_ns1__RegulatoryReporting3 (93)
#endif

/* ns1__RegulatoryAuthority2 has binding name 'ns1__RegulatoryAuthority2' for type 'ns1:RegulatoryAuthority2' */
#ifndef SOAP_TYPE_ns1__RegulatoryAuthority2
#define SOAP_TYPE_ns1__RegulatoryAuthority2 (92)
#endif

/* ns1__ReferredDocumentType4 has binding name 'ns1__ReferredDocumentType4' for type 'ns1:ReferredDocumentType4' */
#ifndef SOAP_TYPE_ns1__ReferredDocumentType4
#define SOAP_TYPE_ns1__ReferredDocumentType4 (91)
#endif

/* ns1__ReferredDocumentType3Choice has binding name 'ns1__ReferredDocumentType3Choice' for type 'ns1:ReferredDocumentType3Choice' */
#ifndef SOAP_TYPE_ns1__ReferredDocumentType3Choice
#define SOAP_TYPE_ns1__ReferredDocumentType3Choice (90)
#endif

/* ns1__ReferredDocumentInformation7 has binding name 'ns1__ReferredDocumentInformation7' for type 'ns1:ReferredDocumentInformation7' */
#ifndef SOAP_TYPE_ns1__ReferredDocumentInformation7
#define SOAP_TYPE_ns1__ReferredDocumentInformation7 (89)
#endif

/* ns1__Purpose2Choice has binding name 'ns1__Purpose2Choice' for type 'ns1:Purpose2Choice' */
#ifndef SOAP_TYPE_ns1__Purpose2Choice
#define SOAP_TYPE_ns1__Purpose2Choice (88)
#endif

/* ns1__ProxyAccountType1Choice has binding name 'ns1__ProxyAccountType1Choice' for type 'ns1:ProxyAccountType1Choice' */
#ifndef SOAP_TYPE_ns1__ProxyAccountType1Choice
#define SOAP_TYPE_ns1__ProxyAccountType1Choice (87)
#endif

/* ns1__ProxyAccountIdentification1 has binding name 'ns1__ProxyAccountIdentification1' for type 'ns1:ProxyAccountIdentification1' */
#ifndef SOAP_TYPE_ns1__ProxyAccountIdentification1
#define SOAP_TYPE_ns1__ProxyAccountIdentification1 (86)
#endif

/* ns1__PostalAddress24 has binding name 'ns1__PostalAddress24' for type 'ns1:PostalAddress24' */
#ifndef SOAP_TYPE_ns1__PostalAddress24
#define SOAP_TYPE_ns1__PostalAddress24 (85)
#endif

/* ns1__PersonIdentificationSchemeName1Choice has binding name 'ns1__PersonIdentificationSchemeName1Choice' for type 'ns1:PersonIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__PersonIdentificationSchemeName1Choice (84)
#endif

/* ns1__PersonIdentification13 has binding name 'ns1__PersonIdentification13' for type 'ns1:PersonIdentification13' */
#ifndef SOAP_TYPE_ns1__PersonIdentification13
#define SOAP_TYPE_ns1__PersonIdentification13 (83)
#endif

/* ns1__PaymentTypeInformation26 has binding name 'ns1__PaymentTypeInformation26' for type 'ns1:PaymentTypeInformation26' */
#ifndef SOAP_TYPE_ns1__PaymentTypeInformation26
#define SOAP_TYPE_ns1__PaymentTypeInformation26 (82)
#endif

/* ns1__PaymentInstruction40 has binding name 'ns1__PaymentInstruction40' for type 'ns1:PaymentInstruction40' */
#ifndef SOAP_TYPE_ns1__PaymentInstruction40
#define SOAP_TYPE_ns1__PaymentInstruction40 (81)
#endif

/* ns1__PaymentInitiationSource1 has binding name 'ns1__PaymentInitiationSource1' for type 'ns1:PaymentInitiationSource1' */
#ifndef SOAP_TYPE_ns1__PaymentInitiationSource1
#define SOAP_TYPE_ns1__PaymentInitiationSource1 (80)
#endif

/* ns1__PaymentIdentification6 has binding name 'ns1__PaymentIdentification6' for type 'ns1:PaymentIdentification6' */
#ifndef SOAP_TYPE_ns1__PaymentIdentification6
#define SOAP_TYPE_ns1__PaymentIdentification6 (79)
#endif

/* ns1__PartyIdentification135 has binding name 'ns1__PartyIdentification135' for type 'ns1:PartyIdentification135' */
#ifndef SOAP_TYPE_ns1__PartyIdentification135
#define SOAP_TYPE_ns1__PartyIdentification135 (78)
#endif

/* ns1__Party38Choice has binding name 'ns1__Party38Choice' for type 'ns1:Party38Choice' */
#ifndef SOAP_TYPE_ns1__Party38Choice
#define SOAP_TYPE_ns1__Party38Choice (77)
#endif

/* ns1__OtherContact1 has binding name 'ns1__OtherContact1' for type 'ns1:OtherContact1' */
#ifndef SOAP_TYPE_ns1__OtherContact1
#define SOAP_TYPE_ns1__OtherContact1 (76)
#endif

/* ns1__OrganisationIdentificationSchemeName1Choice has binding name 'ns1__OrganisationIdentificationSchemeName1Choice' for type 'ns1:OrganisationIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__OrganisationIdentificationSchemeName1Choice (75)
#endif

/* ns1__OrganisationIdentification29 has binding name 'ns1__OrganisationIdentification29' for type 'ns1:OrganisationIdentification29' */
#ifndef SOAP_TYPE_ns1__OrganisationIdentification29
#define SOAP_TYPE_ns1__OrganisationIdentification29 (74)
#endif

/* ns1__NameAndAddress16 has binding name 'ns1__NameAndAddress16' for type 'ns1:NameAndAddress16' */
#ifndef SOAP_TYPE_ns1__NameAndAddress16
#define SOAP_TYPE_ns1__NameAndAddress16 (73)
#endif

/* ns1__MandateTypeInformation2 has binding name 'ns1__MandateTypeInformation2' for type 'ns1:MandateTypeInformation2' */
#ifndef SOAP_TYPE_ns1__MandateTypeInformation2
#define SOAP_TYPE_ns1__MandateTypeInformation2 (72)
#endif

/* ns1__MandateSetupReason1Choice has binding name 'ns1__MandateSetupReason1Choice' for type 'ns1:MandateSetupReason1Choice' */
#ifndef SOAP_TYPE_ns1__MandateSetupReason1Choice
#define SOAP_TYPE_ns1__MandateSetupReason1Choice (71)
#endif

/* ns1__MandateClassification1Choice has binding name 'ns1__MandateClassification1Choice' for type 'ns1:MandateClassification1Choice' */
#ifndef SOAP_TYPE_ns1__MandateClassification1Choice
#define SOAP_TYPE_ns1__MandateClassification1Choice (70)
#endif

/* ns1__LocalInstrument2Choice has binding name 'ns1__LocalInstrument2Choice' for type 'ns1:LocalInstrument2Choice' */
#ifndef SOAP_TYPE_ns1__LocalInstrument2Choice
#define SOAP_TYPE_ns1__LocalInstrument2Choice (69)
#endif

/* ns1__InstructionForDebtorAgent1 has binding name 'ns1__InstructionForDebtorAgent1' for type 'ns1:InstructionForDebtorAgent1' */
#ifndef SOAP_TYPE_ns1__InstructionForDebtorAgent1
#define SOAP_TYPE_ns1__InstructionForDebtorAgent1 (68)
#endif

/* ns1__InstructionForCreditorAgent3 has binding name 'ns1__InstructionForCreditorAgent3' for type 'ns1:InstructionForCreditorAgent3' */
#ifndef SOAP_TYPE_ns1__InstructionForCreditorAgent3
#define SOAP_TYPE_ns1__InstructionForCreditorAgent3 (67)
#endif

/* ns1__GroupHeader95 has binding name 'ns1__GroupHeader95' for type 'ns1:GroupHeader95' */
#ifndef SOAP_TYPE_ns1__GroupHeader95
#define SOAP_TYPE_ns1__GroupHeader95 (66)
#endif

/* ns1__GenericPersonIdentification1 has binding name 'ns1__GenericPersonIdentification1' for type 'ns1:GenericPersonIdentification1' */
#ifndef SOAP_TYPE_ns1__GenericPersonIdentification1
#define SOAP_TYPE_ns1__GenericPersonIdentification1 (65)
#endif

/* ns1__GenericOrganisationIdentification1 has binding name 'ns1__GenericOrganisationIdentification1' for type 'ns1:GenericOrganisationIdentification1' */
#ifndef SOAP_TYPE_ns1__GenericOrganisationIdentification1
#define SOAP_TYPE_ns1__GenericOrganisationIdentification1 (64)
#endif

/* ns1__GenericIdentification30 has binding name 'ns1__GenericIdentification30' for type 'ns1:GenericIdentification30' */
#ifndef SOAP_TYPE_ns1__GenericIdentification30
#define SOAP_TYPE_ns1__GenericIdentification30 (63)
#endif

/* ns1__GenericFinancialIdentification1 has binding name 'ns1__GenericFinancialIdentification1' for type 'ns1:GenericFinancialIdentification1' */
#ifndef SOAP_TYPE_ns1__GenericFinancialIdentification1
#define SOAP_TYPE_ns1__GenericFinancialIdentification1 (62)
#endif

/* ns1__GenericAccountIdentification1 has binding name 'ns1__GenericAccountIdentification1' for type 'ns1:GenericAccountIdentification1' */
#ifndef SOAP_TYPE_ns1__GenericAccountIdentification1
#define SOAP_TYPE_ns1__GenericAccountIdentification1 (61)
#endif

/* ns1__GarnishmentType1Choice has binding name 'ns1__GarnishmentType1Choice' for type 'ns1:GarnishmentType1Choice' */
#ifndef SOAP_TYPE_ns1__GarnishmentType1Choice
#define SOAP_TYPE_ns1__GarnishmentType1Choice (60)
#endif

/* ns1__GarnishmentType1 has binding name 'ns1__GarnishmentType1' for type 'ns1:GarnishmentType1' */
#ifndef SOAP_TYPE_ns1__GarnishmentType1
#define SOAP_TYPE_ns1__GarnishmentType1 (59)
#endif

/* ns1__Garnishment3 has binding name 'ns1__Garnishment3' for type 'ns1:Garnishment3' */
#ifndef SOAP_TYPE_ns1__Garnishment3
#define SOAP_TYPE_ns1__Garnishment3 (58)
#endif

/* ns1__FrequencyPeriod1 has binding name 'ns1__FrequencyPeriod1' for type 'ns1:FrequencyPeriod1' */
#ifndef SOAP_TYPE_ns1__FrequencyPeriod1
#define SOAP_TYPE_ns1__FrequencyPeriod1 (57)
#endif

/* ns1__FrequencyAndMoment1 has binding name 'ns1__FrequencyAndMoment1' for type 'ns1:FrequencyAndMoment1' */
#ifndef SOAP_TYPE_ns1__FrequencyAndMoment1
#define SOAP_TYPE_ns1__FrequencyAndMoment1 (56)
#endif

/* ns1__Frequency36Choice has binding name 'ns1__Frequency36Choice' for type 'ns1:Frequency36Choice' */
#ifndef SOAP_TYPE_ns1__Frequency36Choice
#define SOAP_TYPE_ns1__Frequency36Choice (55)
#endif

/* ns1__FinancialInstitutionIdentification18 has binding name 'ns1__FinancialInstitutionIdentification18' for type 'ns1:FinancialInstitutionIdentification18' */
#ifndef SOAP_TYPE_ns1__FinancialInstitutionIdentification18
#define SOAP_TYPE_ns1__FinancialInstitutionIdentification18 (54)
#endif

/* ns1__FinancialIdentificationSchemeName1Choice has binding name 'ns1__FinancialIdentificationSchemeName1Choice' for type 'ns1:FinancialIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice
#define SOAP_TYPE_ns1__FinancialIdentificationSchemeName1Choice (53)
#endif

/* ns1__ExchangeRate1 has binding name 'ns1__ExchangeRate1' for type 'ns1:ExchangeRate1' */
#ifndef SOAP_TYPE_ns1__ExchangeRate1
#define SOAP_TYPE_ns1__ExchangeRate1 (52)
#endif

/* ns1__EquivalentAmount2 has binding name 'ns1__EquivalentAmount2' for type 'ns1:EquivalentAmount2' */
#ifndef SOAP_TYPE_ns1__EquivalentAmount2
#define SOAP_TYPE_ns1__EquivalentAmount2 (51)
#endif

/* ns1__DocumentLineType1Choice has binding name 'ns1__DocumentLineType1Choice' for type 'ns1:DocumentLineType1Choice' */
#ifndef SOAP_TYPE_ns1__DocumentLineType1Choice
#define SOAP_TYPE_ns1__DocumentLineType1Choice (50)
#endif

/* ns1__DocumentLineType1 has binding name 'ns1__DocumentLineType1' for type 'ns1:DocumentLineType1' */
#ifndef SOAP_TYPE_ns1__DocumentLineType1
#define SOAP_TYPE_ns1__DocumentLineType1 (49)
#endif

/* ns1__DocumentLineInformation1 has binding name 'ns1__DocumentLineInformation1' for type 'ns1:DocumentLineInformation1' */
#ifndef SOAP_TYPE_ns1__DocumentLineInformation1
#define SOAP_TYPE_ns1__DocumentLineInformation1 (48)
#endif

/* ns1__DocumentLineIdentification1 has binding name 'ns1__DocumentLineIdentification1' for type 'ns1:DocumentLineIdentification1' */
#ifndef SOAP_TYPE_ns1__DocumentLineIdentification1
#define SOAP_TYPE_ns1__DocumentLineIdentification1 (47)
#endif

/* ns1__DocumentAdjustment1 has binding name 'ns1__DocumentAdjustment1' for type 'ns1:DocumentAdjustment1' */
#ifndef SOAP_TYPE_ns1__DocumentAdjustment1
#define SOAP_TYPE_ns1__DocumentAdjustment1 (46)
#endif

/* ns1__Document has binding name 'ns1__Document' for type 'ns1:Document' */
#ifndef SOAP_TYPE_ns1__Document
#define SOAP_TYPE_ns1__Document (45)
#endif

/* ns1__DiscountAmountType1Choice has binding name 'ns1__DiscountAmountType1Choice' for type 'ns1:DiscountAmountType1Choice' */
#ifndef SOAP_TYPE_ns1__DiscountAmountType1Choice
#define SOAP_TYPE_ns1__DiscountAmountType1Choice (44)
#endif

/* ns1__DiscountAmountAndType1 has binding name 'ns1__DiscountAmountAndType1' for type 'ns1:DiscountAmountAndType1' */
#ifndef SOAP_TYPE_ns1__DiscountAmountAndType1
#define SOAP_TYPE_ns1__DiscountAmountAndType1 (43)
#endif

/* ns1__DatePeriod2 has binding name 'ns1__DatePeriod2' for type 'ns1:DatePeriod2' */
#ifndef SOAP_TYPE_ns1__DatePeriod2
#define SOAP_TYPE_ns1__DatePeriod2 (42)
#endif

/* ns1__DateAndPlaceOfBirth1 has binding name 'ns1__DateAndPlaceOfBirth1' for type 'ns1:DateAndPlaceOfBirth1' */
#ifndef SOAP_TYPE_ns1__DateAndPlaceOfBirth1
#define SOAP_TYPE_ns1__DateAndPlaceOfBirth1 (41)
#endif

/* ns1__DateAndDateTime2Choice has binding name 'ns1__DateAndDateTime2Choice' for type 'ns1:DateAndDateTime2Choice' */
#ifndef SOAP_TYPE_ns1__DateAndDateTime2Choice
#define SOAP_TYPE_ns1__DateAndDateTime2Choice (40)
#endif

/* ns1__CustomerCreditTransferInitiationV11 has binding name 'ns1__CustomerCreditTransferInitiationV11' for type 'ns1:CustomerCreditTransferInitiationV11' */
#ifndef SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11
#define SOAP_TYPE_ns1__CustomerCreditTransferInitiationV11 (39)
#endif

/* ns1__CreditorReferenceType2 has binding name 'ns1__CreditorReferenceType2' for type 'ns1:CreditorReferenceType2' */
#ifndef SOAP_TYPE_ns1__CreditorReferenceType2
#define SOAP_TYPE_ns1__CreditorReferenceType2 (38)
#endif

/* ns1__CreditorReferenceType1Choice has binding name 'ns1__CreditorReferenceType1Choice' for type 'ns1:CreditorReferenceType1Choice' */
#ifndef SOAP_TYPE_ns1__CreditorReferenceType1Choice
#define SOAP_TYPE_ns1__CreditorReferenceType1Choice (37)
#endif

/* ns1__CreditorReferenceInformation2 has binding name 'ns1__CreditorReferenceInformation2' for type 'ns1:CreditorReferenceInformation2' */
#ifndef SOAP_TYPE_ns1__CreditorReferenceInformation2
#define SOAP_TYPE_ns1__CreditorReferenceInformation2 (36)
#endif

/* ns1__CreditTransferTransaction54 has binding name 'ns1__CreditTransferTransaction54' for type 'ns1:CreditTransferTransaction54' */
#ifndef SOAP_TYPE_ns1__CreditTransferTransaction54
#define SOAP_TYPE_ns1__CreditTransferTransaction54 (35)
#endif

/* ns1__CreditTransferMandateData1 has binding name 'ns1__CreditTransferMandateData1' for type 'ns1:CreditTransferMandateData1' */
#ifndef SOAP_TYPE_ns1__CreditTransferMandateData1
#define SOAP_TYPE_ns1__CreditTransferMandateData1 (34)
#endif

/* ns1__Contact4 has binding name 'ns1__Contact4' for type 'ns1:Contact4' */
#ifndef SOAP_TYPE_ns1__Contact4
#define SOAP_TYPE_ns1__Contact4 (33)
#endif

/* ns1__ClearingSystemMemberIdentification2 has binding name 'ns1__ClearingSystemMemberIdentification2' for type 'ns1:ClearingSystemMemberIdentification2' */
#ifndef SOAP_TYPE_ns1__ClearingSystemMemberIdentification2
#define SOAP_TYPE_ns1__ClearingSystemMemberIdentification2 (32)
#endif

/* ns1__ClearingSystemIdentification2Choice has binding name 'ns1__ClearingSystemIdentification2Choice' for type 'ns1:ClearingSystemIdentification2Choice' */
#ifndef SOAP_TYPE_ns1__ClearingSystemIdentification2Choice
#define SOAP_TYPE_ns1__ClearingSystemIdentification2Choice (31)
#endif

/* ns1__ChequeDeliveryMethod1Choice has binding name 'ns1__ChequeDeliveryMethod1Choice' for type 'ns1:ChequeDeliveryMethod1Choice' */
#ifndef SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice
#define SOAP_TYPE_ns1__ChequeDeliveryMethod1Choice (30)
#endif

/* ns1__Cheque11 has binding name 'ns1__Cheque11' for type 'ns1:Cheque11' */
#ifndef SOAP_TYPE_ns1__Cheque11
#define SOAP_TYPE_ns1__Cheque11 (29)
#endif

/* ns1__CategoryPurpose1Choice has binding name 'ns1__CategoryPurpose1Choice' for type 'ns1:CategoryPurpose1Choice' */
#ifndef SOAP_TYPE_ns1__CategoryPurpose1Choice
#define SOAP_TYPE_ns1__CategoryPurpose1Choice (28)
#endif

/* ns1__CashAccountType2Choice has binding name 'ns1__CashAccountType2Choice' for type 'ns1:CashAccountType2Choice' */
#ifndef SOAP_TYPE_ns1__CashAccountType2Choice
#define SOAP_TYPE_ns1__CashAccountType2Choice (27)
#endif

/* ns1__CashAccount40 has binding name 'ns1__CashAccount40' for type 'ns1:CashAccount40' */
#ifndef SOAP_TYPE_ns1__CashAccount40
#define SOAP_TYPE_ns1__CashAccount40 (26)
#endif

/* ns1__BranchData3 has binding name 'ns1__BranchData3' for type 'ns1:BranchData3' */
#ifndef SOAP_TYPE_ns1__BranchData3
#define SOAP_TYPE_ns1__BranchData3 (25)
#endif

/* ns1__BranchAndFinancialInstitutionIdentification6 has binding name 'ns1__BranchAndFinancialInstitutionIdentification6' for type 'ns1:BranchAndFinancialInstitutionIdentification6' */
#ifndef SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6
#define SOAP_TYPE_ns1__BranchAndFinancialInstitutionIdentification6 (24)
#endif

/* ns1__Authorisation1Choice has binding name 'ns1__Authorisation1Choice' for type 'ns1:Authorisation1Choice' */
#ifndef SOAP_TYPE_ns1__Authorisation1Choice
#define SOAP_TYPE_ns1__Authorisation1Choice (23)
#endif

/* ns1__AmountType4Choice has binding name 'ns1__AmountType4Choice' for type 'ns1:AmountType4Choice' */
#ifndef SOAP_TYPE_ns1__AmountType4Choice
#define SOAP_TYPE_ns1__AmountType4Choice (22)
#endif

/* ns1__AdviceType1Choice has binding name 'ns1__AdviceType1Choice' for type 'ns1:AdviceType1Choice' */
#ifndef SOAP_TYPE_ns1__AdviceType1Choice
#define SOAP_TYPE_ns1__AdviceType1Choice (21)
#endif

/* ns1__AdviceType1 has binding name 'ns1__AdviceType1' for type 'ns1:AdviceType1' */
#ifndef SOAP_TYPE_ns1__AdviceType1
#define SOAP_TYPE_ns1__AdviceType1 (20)
#endif

/* ns1__AddressType3Choice has binding name 'ns1__AddressType3Choice' for type 'ns1:AddressType3Choice' */
#ifndef SOAP_TYPE_ns1__AddressType3Choice
#define SOAP_TYPE_ns1__AddressType3Choice (19)
#endif

/* ns1__ActiveOrHistoricCurrencyAndAmount has binding name 'ns1__ActiveOrHistoricCurrencyAndAmount' for type 'ns1:ActiveOrHistoricCurrencyAndAmount' */
#ifndef SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount
#define SOAP_TYPE_ns1__ActiveOrHistoricCurrencyAndAmount (18)
#endif

/* ns1__AccountSchemeName1Choice has binding name 'ns1__AccountSchemeName1Choice' for type 'ns1:AccountSchemeName1Choice' */
#ifndef SOAP_TYPE_ns1__AccountSchemeName1Choice
#define SOAP_TYPE_ns1__AccountSchemeName1Choice (17)
#endif

/* ns1__AccountIdentification4Choice has binding name 'ns1__AccountIdentification4Choice' for type 'ns1:AccountIdentification4Choice' */
#ifndef SOAP_TYPE_ns1__AccountIdentification4Choice
#define SOAP_TYPE_ns1__AccountIdentification4Choice (16)
#endif

/* xsd__gYear has binding name 'xsd__gYear' for type 'xsd:gYear' */
#ifndef SOAP_TYPE_xsd__gYear
#define SOAP_TYPE_xsd__gYear (15)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (14)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (13)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (12)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (400)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (399)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (396)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (394)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (393)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (402)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (401)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (395)
#endif

/* ns1__TaxAmount3 * has binding name 'PointerTons1__TaxAmount3' for type 'ns1:TaxAmount3' */
#ifndef SOAP_TYPE_PointerTons1__TaxAmount3
#define SOAP_TYPE_PointerTons1__TaxAmount3 (392)
#endif

/* ns1__TaxPeriod3 * has binding name 'PointerTons1__TaxPeriod3' for type 'ns1:TaxPeriod3' */
#ifndef SOAP_TYPE_PointerTons1__TaxPeriod3
#define SOAP_TYPE_PointerTons1__TaxPeriod3 (391)
#endif

/* ns1__DatePeriod2 * has binding name 'PointerTons1__DatePeriod2' for type 'ns1:DatePeriod2' */
#ifndef SOAP_TYPE_PointerTons1__DatePeriod2
#define SOAP_TYPE_PointerTons1__DatePeriod2 (390)
#endif

/* enum ns1__TaxRecordPeriod1Code * has binding name 'PointerTons1__TaxRecordPeriod1Code' for type 'ns1:TaxRecordPeriod1Code' */
#ifndef SOAP_TYPE_PointerTons1__TaxRecordPeriod1Code
#define SOAP_TYPE_PointerTons1__TaxRecordPeriod1Code (389)
#endif

/* std::string * has binding name 'PointerTons1__ISOYear' for type 'ns1:ISOYear' */
#ifndef SOAP_TYPE_PointerTons1__ISOYear
#define SOAP_TYPE_PointerTons1__ISOYear (388)
#endif

/* ns1__TaxAuthorisation1 * has binding name 'PointerTons1__TaxAuthorisation1' for type 'ns1:TaxAuthorisation1' */
#ifndef SOAP_TYPE_PointerTons1__TaxAuthorisation1
#define SOAP_TYPE_PointerTons1__TaxAuthorisation1 (387)
#endif

/* ns1__TaxRecord3 * has binding name 'PointerTons1__TaxRecord3' for type 'ns1:TaxRecord3' */
#ifndef SOAP_TYPE_PointerTons1__TaxRecord3
#define SOAP_TYPE_PointerTons1__TaxRecord3 (385)
#endif

/* std::string * has binding name 'PointerTons1__Number' for type 'ns1:Number' */
#ifndef SOAP_TYPE_PointerTons1__Number
#define SOAP_TYPE_PointerTons1__Number (384)
#endif

/* ns1__TaxParty2 * has binding name 'PointerTons1__TaxParty2' for type 'ns1:TaxParty2' */
#ifndef SOAP_TYPE_PointerTons1__TaxParty2
#define SOAP_TYPE_PointerTons1__TaxParty2 (383)
#endif

/* ns1__TaxParty1 * has binding name 'PointerTons1__TaxParty1' for type 'ns1:TaxParty1' */
#ifndef SOAP_TYPE_PointerTons1__TaxParty1
#define SOAP_TYPE_PointerTons1__TaxParty1 (382)
#endif

/* std::string * has binding name 'PointerTons1__ExternalTaxAmountType1Code' for type 'ns1:ExternalTaxAmountType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalTaxAmountType1Code
#define SOAP_TYPE_PointerTons1__ExternalTaxAmountType1Code (381)
#endif

/* ns1__TaxAmountType1Choice * has binding name 'PointerTons1__TaxAmountType1Choice' for type 'ns1:TaxAmountType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__TaxAmountType1Choice
#define SOAP_TYPE_PointerTons1__TaxAmountType1Choice (379)
#endif

/* ns1__TaxRecordDetails3 * has binding name 'PointerTons1__TaxRecordDetails3' for type 'ns1:TaxRecordDetails3' */
#ifndef SOAP_TYPE_PointerTons1__TaxRecordDetails3
#define SOAP_TYPE_PointerTons1__TaxRecordDetails3 (377)
#endif

/* std::string * has binding name 'PointerTons1__PercentageRate' for type 'ns1:PercentageRate' */
#ifndef SOAP_TYPE_PointerTons1__PercentageRate
#define SOAP_TYPE_PointerTons1__PercentageRate (376)
#endif

/* ns1__SupplementaryDataEnvelope1 * has binding name 'PointerTons1__SupplementaryDataEnvelope1' for type 'ns1:SupplementaryDataEnvelope1' */
#ifndef SOAP_TYPE_PointerTons1__SupplementaryDataEnvelope1
#define SOAP_TYPE_PointerTons1__SupplementaryDataEnvelope1 (375)
#endif

/* std::string * has binding name 'PointerTons1__Max350Text' for type 'ns1:Max350Text' */
#ifndef SOAP_TYPE_PointerTons1__Max350Text
#define SOAP_TYPE_PointerTons1__Max350Text (374)
#endif

/* ns1__Garnishment3 * has binding name 'PointerTons1__Garnishment3' for type 'ns1:Garnishment3' */
#ifndef SOAP_TYPE_PointerTons1__Garnishment3
#define SOAP_TYPE_PointerTons1__Garnishment3 (373)
#endif

/* ns1__TaxData1 * has binding name 'PointerTons1__TaxData1' for type 'ns1:TaxData1' */
#ifndef SOAP_TYPE_PointerTons1__TaxData1
#define SOAP_TYPE_PointerTons1__TaxData1 (372)
#endif

/* ns1__CreditorReferenceInformation2 * has binding name 'PointerTons1__CreditorReferenceInformation2' for type 'ns1:CreditorReferenceInformation2' */
#ifndef SOAP_TYPE_PointerTons1__CreditorReferenceInformation2
#define SOAP_TYPE_PointerTons1__CreditorReferenceInformation2 (371)
#endif

/* ns1__RemittanceAmount2 * has binding name 'PointerTons1__RemittanceAmount2' for type 'ns1:RemittanceAmount2' */
#ifndef SOAP_TYPE_PointerTons1__RemittanceAmount2
#define SOAP_TYPE_PointerTons1__RemittanceAmount2 (370)
#endif

/* ns1__ReferredDocumentInformation7 * has binding name 'PointerTons1__ReferredDocumentInformation7' for type 'ns1:ReferredDocumentInformation7' */
#ifndef SOAP_TYPE_PointerTons1__ReferredDocumentInformation7
#define SOAP_TYPE_PointerTons1__ReferredDocumentInformation7 (368)
#endif

/* std::string * has binding name 'PointerTons1__Max10Text' for type 'ns1:Max10Text' */
#ifndef SOAP_TYPE_PointerTons1__Max10Text
#define SOAP_TYPE_PointerTons1__Max10Text (367)
#endif

/* std::string * has binding name 'PointerTons1__ExternalServiceLevel1Code' for type 'ns1:ExternalServiceLevel1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalServiceLevel1Code
#define SOAP_TYPE_PointerTons1__ExternalServiceLevel1Code (366)
#endif

/* ns1__RemittanceLocationData1 * has binding name 'PointerTons1__RemittanceLocationData1' for type 'ns1:RemittanceLocationData1' */
#ifndef SOAP_TYPE_PointerTons1__RemittanceLocationData1
#define SOAP_TYPE_PointerTons1__RemittanceLocationData1 (363)
#endif

/* ns1__StructuredRemittanceInformation17 * has binding name 'PointerTons1__StructuredRemittanceInformation17' for type 'ns1:StructuredRemittanceInformation17' */
#ifndef SOAP_TYPE_PointerTons1__StructuredRemittanceInformation17
#define SOAP_TYPE_PointerTons1__StructuredRemittanceInformation17 (361)
#endif

/* ns1__DocumentAdjustment1 * has binding name 'PointerTons1__DocumentAdjustment1' for type 'ns1:DocumentAdjustment1' */
#ifndef SOAP_TYPE_PointerTons1__DocumentAdjustment1
#define SOAP_TYPE_PointerTons1__DocumentAdjustment1 (358)
#endif

/* ns1__TaxAmountAndType1 * has binding name 'PointerTons1__TaxAmountAndType1' for type 'ns1:TaxAmountAndType1' */
#ifndef SOAP_TYPE_PointerTons1__TaxAmountAndType1
#define SOAP_TYPE_PointerTons1__TaxAmountAndType1 (356)
#endif

/* ns1__DiscountAmountAndType1 * has binding name 'PointerTons1__DiscountAmountAndType1' for type 'ns1:DiscountAmountAndType1' */
#ifndef SOAP_TYPE_PointerTons1__DiscountAmountAndType1
#define SOAP_TYPE_PointerTons1__DiscountAmountAndType1 (354)
#endif

/* ns1__StructuredRegulatoryReporting3 * has binding name 'PointerTons1__StructuredRegulatoryReporting3' for type 'ns1:StructuredRegulatoryReporting3' */
#ifndef SOAP_TYPE_PointerTons1__StructuredRegulatoryReporting3
#define SOAP_TYPE_PointerTons1__StructuredRegulatoryReporting3 (352)
#endif

/* ns1__RegulatoryAuthority2 * has binding name 'PointerTons1__RegulatoryAuthority2' for type 'ns1:RegulatoryAuthority2' */
#ifndef SOAP_TYPE_PointerTons1__RegulatoryAuthority2
#define SOAP_TYPE_PointerTons1__RegulatoryAuthority2 (351)
#endif

/* enum ns1__RegulatoryReportingType1Code * has binding name 'PointerTons1__RegulatoryReportingType1Code' for type 'ns1:RegulatoryReportingType1Code' */
#ifndef SOAP_TYPE_PointerTons1__RegulatoryReportingType1Code
#define SOAP_TYPE_PointerTons1__RegulatoryReportingType1Code (350)
#endif

/* ns1__ReferredDocumentType3Choice * has binding name 'PointerTons1__ReferredDocumentType3Choice' for type 'ns1:ReferredDocumentType3Choice' */
#ifndef SOAP_TYPE_PointerTons1__ReferredDocumentType3Choice
#define SOAP_TYPE_PointerTons1__ReferredDocumentType3Choice (349)
#endif

/* ns1__DocumentLineInformation1 * has binding name 'PointerTons1__DocumentLineInformation1' for type 'ns1:DocumentLineInformation1' */
#ifndef SOAP_TYPE_PointerTons1__DocumentLineInformation1
#define SOAP_TYPE_PointerTons1__DocumentLineInformation1 (346)
#endif

/* ns1__ReferredDocumentType4 * has binding name 'PointerTons1__ReferredDocumentType4' for type 'ns1:ReferredDocumentType4' */
#ifndef SOAP_TYPE_PointerTons1__ReferredDocumentType4
#define SOAP_TYPE_PointerTons1__ReferredDocumentType4 (345)
#endif

/* std::string * has binding name 'PointerTons1__ExternalPurpose1Code' for type 'ns1:ExternalPurpose1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalPurpose1Code
#define SOAP_TYPE_PointerTons1__ExternalPurpose1Code (344)
#endif

/* std::string * has binding name 'PointerTons1__ExternalProxyAccountType1Code' for type 'ns1:ExternalProxyAccountType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalProxyAccountType1Code
#define SOAP_TYPE_PointerTons1__ExternalProxyAccountType1Code (342)
#endif

/* ns1__ProxyAccountType1Choice * has binding name 'PointerTons1__ProxyAccountType1Choice' for type 'ns1:ProxyAccountType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__ProxyAccountType1Choice
#define SOAP_TYPE_PointerTons1__ProxyAccountType1Choice (340)
#endif

/* std::string * has binding name 'PointerTons1__Max16Text' for type 'ns1:Max16Text' */
#ifndef SOAP_TYPE_PointerTons1__Max16Text
#define SOAP_TYPE_PointerTons1__Max16Text (339)
#endif

/* ns1__AddressType3Choice * has binding name 'PointerTons1__AddressType3Choice' for type 'ns1:AddressType3Choice' */
#ifndef SOAP_TYPE_PointerTons1__AddressType3Choice
#define SOAP_TYPE_PointerTons1__AddressType3Choice (338)
#endif

/* std::string * has binding name 'PointerTons1__ExternalPersonIdentification1Code' for type 'ns1:ExternalPersonIdentification1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalPersonIdentification1Code
#define SOAP_TYPE_PointerTons1__ExternalPersonIdentification1Code (337)
#endif

/* ns1__GenericPersonIdentification1 * has binding name 'PointerTons1__GenericPersonIdentification1' for type 'ns1:GenericPersonIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__GenericPersonIdentification1
#define SOAP_TYPE_PointerTons1__GenericPersonIdentification1 (334)
#endif

/* ns1__DateAndPlaceOfBirth1 * has binding name 'PointerTons1__DateAndPlaceOfBirth1' for type 'ns1:DateAndPlaceOfBirth1' */
#ifndef SOAP_TYPE_PointerTons1__DateAndPlaceOfBirth1
#define SOAP_TYPE_PointerTons1__DateAndPlaceOfBirth1 (333)
#endif

/* ns1__CreditTransferTransaction54 * has binding name 'PointerTons1__CreditTransferTransaction54' for type 'ns1:CreditTransferTransaction54' */
#ifndef SOAP_TYPE_PointerTons1__CreditTransferTransaction54
#define SOAP_TYPE_PointerTons1__CreditTransferTransaction54 (330)
#endif

/* ns1__DateAndDateTime2Choice * has binding name 'PointerTons1__DateAndDateTime2Choice' for type 'ns1:DateAndDateTime2Choice' */
#ifndef SOAP_TYPE_PointerTons1__DateAndDateTime2Choice
#define SOAP_TYPE_PointerTons1__DateAndDateTime2Choice (329)
#endif

/* std::string * has binding name 'PointerTons1__Max15NumericText' for type 'ns1:Max15NumericText' */
#ifndef SOAP_TYPE_PointerTons1__Max15NumericText
#define SOAP_TYPE_PointerTons1__Max15NumericText (328)
#endif

/* bool * has binding name 'PointerTons1__BatchBookingIndicator' for type 'ns1:BatchBookingIndicator' */
#ifndef SOAP_TYPE_PointerTons1__BatchBookingIndicator
#define SOAP_TYPE_PointerTons1__BatchBookingIndicator (327)
#endif

/* ns1__AdviceType1 * has binding name 'PointerTons1__AdviceType1' for type 'ns1:AdviceType1' */
#ifndef SOAP_TYPE_PointerTons1__AdviceType1
#define SOAP_TYPE_PointerTons1__AdviceType1 (326)
#endif

/* std::string * has binding name 'PointerTons1__UUIDv4Identifier' for type 'ns1:UUIDv4Identifier' */
#ifndef SOAP_TYPE_PointerTons1__UUIDv4Identifier
#define SOAP_TYPE_PointerTons1__UUIDv4Identifier (325)
#endif

/* ns1__Contact4 * has binding name 'PointerTons1__Contact4' for type 'ns1:Contact4' */
#ifndef SOAP_TYPE_PointerTons1__Contact4
#define SOAP_TYPE_PointerTons1__Contact4 (324)
#endif

/* std::string * has binding name 'PointerTons1__CountryCode' for type 'ns1:CountryCode' */
#ifndef SOAP_TYPE_PointerTons1__CountryCode
#define SOAP_TYPE_PointerTons1__CountryCode (323)
#endif

/* ns1__Party38Choice * has binding name 'PointerTons1__Party38Choice' for type 'ns1:Party38Choice' */
#ifndef SOAP_TYPE_PointerTons1__Party38Choice
#define SOAP_TYPE_PointerTons1__Party38Choice (322)
#endif

/* ns1__PersonIdentification13 * has binding name 'PointerTons1__PersonIdentification13' for type 'ns1:PersonIdentification13' */
#ifndef SOAP_TYPE_PointerTons1__PersonIdentification13
#define SOAP_TYPE_PointerTons1__PersonIdentification13 (321)
#endif

/* ns1__OrganisationIdentification29 * has binding name 'PointerTons1__OrganisationIdentification29' for type 'ns1:OrganisationIdentification29' */
#ifndef SOAP_TYPE_PointerTons1__OrganisationIdentification29
#define SOAP_TYPE_PointerTons1__OrganisationIdentification29 (320)
#endif

/* std::string * has binding name 'PointerTons1__ExternalOrganisationIdentification1Code' for type 'ns1:ExternalOrganisationIdentification1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalOrganisationIdentification1Code
#define SOAP_TYPE_PointerTons1__ExternalOrganisationIdentification1Code (318)
#endif

/* ns1__GenericOrganisationIdentification1 * has binding name 'PointerTons1__GenericOrganisationIdentification1' for type 'ns1:GenericOrganisationIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__GenericOrganisationIdentification1
#define SOAP_TYPE_PointerTons1__GenericOrganisationIdentification1 (315)
#endif

/* std::string * has binding name 'PointerTons1__AnyBICDec2014Identifier' for type 'ns1:AnyBICDec2014Identifier' */
#ifndef SOAP_TYPE_PointerTons1__AnyBICDec2014Identifier
#define SOAP_TYPE_PointerTons1__AnyBICDec2014Identifier (314)
#endif

/* ns1__MandateClassification1Choice * has binding name 'PointerTons1__MandateClassification1Choice' for type 'ns1:MandateClassification1Choice' */
#ifndef SOAP_TYPE_PointerTons1__MandateClassification1Choice
#define SOAP_TYPE_PointerTons1__MandateClassification1Choice (313)
#endif

/* ns1__CategoryPurpose1Choice * has binding name 'PointerTons1__CategoryPurpose1Choice' for type 'ns1:CategoryPurpose1Choice' */
#ifndef SOAP_TYPE_PointerTons1__CategoryPurpose1Choice
#define SOAP_TYPE_PointerTons1__CategoryPurpose1Choice (312)
#endif

/* ns1__LocalInstrument2Choice * has binding name 'PointerTons1__LocalInstrument2Choice' for type 'ns1:LocalInstrument2Choice' */
#ifndef SOAP_TYPE_PointerTons1__LocalInstrument2Choice
#define SOAP_TYPE_PointerTons1__LocalInstrument2Choice (311)
#endif

/* ns1__ServiceLevel8Choice * has binding name 'PointerTons1__ServiceLevel8Choice' for type 'ns1:ServiceLevel8Choice' */
#ifndef SOAP_TYPE_PointerTons1__ServiceLevel8Choice
#define SOAP_TYPE_PointerTons1__ServiceLevel8Choice (310)
#endif

/* std::string * has binding name 'PointerTons1__ExternalMandateSetupReason1Code' for type 'ns1:ExternalMandateSetupReason1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalMandateSetupReason1Code
#define SOAP_TYPE_PointerTons1__ExternalMandateSetupReason1Code (309)
#endif

/* std::string * has binding name 'PointerTons1__ExternalLocalInstrument1Code' for type 'ns1:ExternalLocalInstrument1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalLocalInstrument1Code
#define SOAP_TYPE_PointerTons1__ExternalLocalInstrument1Code (306)
#endif

/* std::string * has binding name 'PointerTons1__ExternalDebtorAgentInstruction1Code' for type 'ns1:ExternalDebtorAgentInstruction1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalDebtorAgentInstruction1Code
#define SOAP_TYPE_PointerTons1__ExternalDebtorAgentInstruction1Code (304)
#endif

/* std::string * has binding name 'PointerTons1__ExternalCreditorAgentInstruction1Code' for type 'ns1:ExternalCreditorAgentInstruction1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalCreditorAgentInstruction1Code
#define SOAP_TYPE_PointerTons1__ExternalCreditorAgentInstruction1Code (303)
#endif

/* ns1__PaymentInitiationSource1 * has binding name 'PointerTons1__PaymentInitiationSource1' for type 'ns1:PaymentInitiationSource1' */
#ifndef SOAP_TYPE_PointerTons1__PaymentInitiationSource1
#define SOAP_TYPE_PointerTons1__PaymentInitiationSource1 (302)
#endif

/* std::string * has binding name 'PointerTons1__DecimalNumber' for type 'ns1:DecimalNumber' */
#ifndef SOAP_TYPE_PointerTons1__DecimalNumber
#define SOAP_TYPE_PointerTons1__DecimalNumber (301)
#endif

/* ns1__Authorisation1Choice * has binding name 'PointerTons1__Authorisation1Choice' for type 'ns1:Authorisation1Choice' */
#ifndef SOAP_TYPE_PointerTons1__Authorisation1Choice
#define SOAP_TYPE_PointerTons1__Authorisation1Choice (299)
#endif

/* ns1__PersonIdentificationSchemeName1Choice * has binding name 'PointerTons1__PersonIdentificationSchemeName1Choice' for type 'ns1:PersonIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_PointerTons1__PersonIdentificationSchemeName1Choice
#define SOAP_TYPE_PointerTons1__PersonIdentificationSchemeName1Choice (298)
#endif

/* ns1__OrganisationIdentificationSchemeName1Choice * has binding name 'PointerTons1__OrganisationIdentificationSchemeName1Choice' for type 'ns1:OrganisationIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_PointerTons1__OrganisationIdentificationSchemeName1Choice
#define SOAP_TYPE_PointerTons1__OrganisationIdentificationSchemeName1Choice (297)
#endif

/* ns1__FinancialIdentificationSchemeName1Choice * has binding name 'PointerTons1__FinancialIdentificationSchemeName1Choice' for type 'ns1:FinancialIdentificationSchemeName1Choice' */
#ifndef SOAP_TYPE_PointerTons1__FinancialIdentificationSchemeName1Choice
#define SOAP_TYPE_PointerTons1__FinancialIdentificationSchemeName1Choice (296)
#endif

/* ns1__AccountSchemeName1Choice * has binding name 'PointerTons1__AccountSchemeName1Choice' for type 'ns1:AccountSchemeName1Choice' */
#ifndef SOAP_TYPE_PointerTons1__AccountSchemeName1Choice
#define SOAP_TYPE_PointerTons1__AccountSchemeName1Choice (295)
#endif

/* std::string * has binding name 'PointerTons1__ExternalGarnishmentType1Code' for type 'ns1:ExternalGarnishmentType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalGarnishmentType1Code
#define SOAP_TYPE_PointerTons1__ExternalGarnishmentType1Code (294)
#endif

/* ns1__GarnishmentType1Choice * has binding name 'PointerTons1__GarnishmentType1Choice' for type 'ns1:GarnishmentType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__GarnishmentType1Choice
#define SOAP_TYPE_PointerTons1__GarnishmentType1Choice (292)
#endif

/* bool * has binding name 'PointerTons1__TrueFalseIndicator' for type 'ns1:TrueFalseIndicator' */
#ifndef SOAP_TYPE_PointerTons1__TrueFalseIndicator
#define SOAP_TYPE_PointerTons1__TrueFalseIndicator (291)
#endif

/* ns1__GarnishmentType1 * has binding name 'PointerTons1__GarnishmentType1' for type 'ns1:GarnishmentType1' */
#ifndef SOAP_TYPE_PointerTons1__GarnishmentType1
#define SOAP_TYPE_PointerTons1__GarnishmentType1 (290)
#endif

/* ns1__FrequencyAndMoment1 * has binding name 'PointerTons1__FrequencyAndMoment1' for type 'ns1:FrequencyAndMoment1' */
#ifndef SOAP_TYPE_PointerTons1__FrequencyAndMoment1
#define SOAP_TYPE_PointerTons1__FrequencyAndMoment1 (289)
#endif

/* ns1__FrequencyPeriod1 * has binding name 'PointerTons1__FrequencyPeriod1' for type 'ns1:FrequencyPeriod1' */
#ifndef SOAP_TYPE_PointerTons1__FrequencyPeriod1
#define SOAP_TYPE_PointerTons1__FrequencyPeriod1 (288)
#endif

/* ns1__GenericFinancialIdentification1 * has binding name 'PointerTons1__GenericFinancialIdentification1' for type 'ns1:GenericFinancialIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__GenericFinancialIdentification1
#define SOAP_TYPE_PointerTons1__GenericFinancialIdentification1 (286)
#endif

/* ns1__ClearingSystemMemberIdentification2 * has binding name 'PointerTons1__ClearingSystemMemberIdentification2' for type 'ns1:ClearingSystemMemberIdentification2' */
#ifndef SOAP_TYPE_PointerTons1__ClearingSystemMemberIdentification2
#define SOAP_TYPE_PointerTons1__ClearingSystemMemberIdentification2 (285)
#endif

/* std::string * has binding name 'PointerTons1__BICFIDec2014Identifier' for type 'ns1:BICFIDec2014Identifier' */
#ifndef SOAP_TYPE_PointerTons1__BICFIDec2014Identifier
#define SOAP_TYPE_PointerTons1__BICFIDec2014Identifier (284)
#endif

/* std::string * has binding name 'PointerTons1__ExternalFinancialInstitutionIdentification1Code' for type 'ns1:ExternalFinancialInstitutionIdentification1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalFinancialInstitutionIdentification1Code
#define SOAP_TYPE_PointerTons1__ExternalFinancialInstitutionIdentification1Code (283)
#endif

/* enum ns1__ExchangeRateType1Code * has binding name 'PointerTons1__ExchangeRateType1Code' for type 'ns1:ExchangeRateType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExchangeRateType1Code
#define SOAP_TYPE_PointerTons1__ExchangeRateType1Code (281)
#endif

/* std::string * has binding name 'PointerTons1__BaseOneRate' for type 'ns1:BaseOneRate' */
#ifndef SOAP_TYPE_PointerTons1__BaseOneRate
#define SOAP_TYPE_PointerTons1__BaseOneRate (280)
#endif

/* std::string * has binding name 'PointerTons1__ExternalDocumentLineType1Code' for type 'ns1:ExternalDocumentLineType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalDocumentLineType1Code
#define SOAP_TYPE_PointerTons1__ExternalDocumentLineType1Code (279)
#endif

/* ns1__DocumentLineType1Choice * has binding name 'PointerTons1__DocumentLineType1Choice' for type 'ns1:DocumentLineType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__DocumentLineType1Choice
#define SOAP_TYPE_PointerTons1__DocumentLineType1Choice (277)
#endif

/* ns1__RemittanceAmount3 * has binding name 'PointerTons1__RemittanceAmount3' for type 'ns1:RemittanceAmount3' */
#ifndef SOAP_TYPE_PointerTons1__RemittanceAmount3
#define SOAP_TYPE_PointerTons1__RemittanceAmount3 (276)
#endif

/* ns1__DocumentLineIdentification1 * has binding name 'PointerTons1__DocumentLineIdentification1' for type 'ns1:DocumentLineIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__DocumentLineIdentification1
#define SOAP_TYPE_PointerTons1__DocumentLineIdentification1 (274)
#endif

/* ns1__DocumentLineType1 * has binding name 'PointerTons1__DocumentLineType1' for type 'ns1:DocumentLineType1' */
#ifndef SOAP_TYPE_PointerTons1__DocumentLineType1
#define SOAP_TYPE_PointerTons1__DocumentLineType1 (273)
#endif

/* std::string * has binding name 'PointerTons1__Max4Text' for type 'ns1:Max4Text' */
#ifndef SOAP_TYPE_PointerTons1__Max4Text
#define SOAP_TYPE_PointerTons1__Max4Text (272)
#endif

/* enum ns1__CreditDebitCode * has binding name 'PointerTons1__CreditDebitCode' for type 'ns1:CreditDebitCode' */
#ifndef SOAP_TYPE_PointerTons1__CreditDebitCode
#define SOAP_TYPE_PointerTons1__CreditDebitCode (271)
#endif

/* ns1__CustomerCreditTransferInitiationV11 * has binding name 'PointerTons1__CustomerCreditTransferInitiationV11' for type 'ns1:CustomerCreditTransferInitiationV11' */
#ifndef SOAP_TYPE_PointerTons1__CustomerCreditTransferInitiationV11
#define SOAP_TYPE_PointerTons1__CustomerCreditTransferInitiationV11 (270)
#endif

/* std::string * has binding name 'PointerTons1__ExternalDiscountAmountType1Code' for type 'ns1:ExternalDiscountAmountType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalDiscountAmountType1Code
#define SOAP_TYPE_PointerTons1__ExternalDiscountAmountType1Code (269)
#endif

/* ns1__DiscountAmountType1Choice * has binding name 'PointerTons1__DiscountAmountType1Choice' for type 'ns1:DiscountAmountType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__DiscountAmountType1Choice
#define SOAP_TYPE_PointerTons1__DiscountAmountType1Choice (267)
#endif

/* ns1__PaymentInstruction40 * has binding name 'PointerTons1__PaymentInstruction40' for type 'ns1:PaymentInstruction40' */
#ifndef SOAP_TYPE_PointerTons1__PaymentInstruction40
#define SOAP_TYPE_PointerTons1__PaymentInstruction40 (264)
#endif

/* ns1__GroupHeader95 * has binding name 'PointerTons1__GroupHeader95' for type 'ns1:GroupHeader95' */
#ifndef SOAP_TYPE_PointerTons1__GroupHeader95
#define SOAP_TYPE_PointerTons1__GroupHeader95 (263)
#endif

/* ns1__CreditorReferenceType1Choice * has binding name 'PointerTons1__CreditorReferenceType1Choice' for type 'ns1:CreditorReferenceType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__CreditorReferenceType1Choice
#define SOAP_TYPE_PointerTons1__CreditorReferenceType1Choice (262)
#endif

/* ns1__CreditorReferenceType2 * has binding name 'PointerTons1__CreditorReferenceType2' for type 'ns1:CreditorReferenceType2' */
#ifndef SOAP_TYPE_PointerTons1__CreditorReferenceType2
#define SOAP_TYPE_PointerTons1__CreditorReferenceType2 (260)
#endif

/* ns1__SupplementaryData1 * has binding name 'PointerTons1__SupplementaryData1' for type 'ns1:SupplementaryData1' */
#ifndef SOAP_TYPE_PointerTons1__SupplementaryData1
#define SOAP_TYPE_PointerTons1__SupplementaryData1 (258)
#endif

/* ns1__RemittanceInformation21 * has binding name 'PointerTons1__RemittanceInformation21' for type 'ns1:RemittanceInformation21' */
#ifndef SOAP_TYPE_PointerTons1__RemittanceInformation21
#define SOAP_TYPE_PointerTons1__RemittanceInformation21 (257)
#endif

/* ns1__RemittanceLocation7 * has binding name 'PointerTons1__RemittanceLocation7' for type 'ns1:RemittanceLocation7' */
#ifndef SOAP_TYPE_PointerTons1__RemittanceLocation7
#define SOAP_TYPE_PointerTons1__RemittanceLocation7 (255)
#endif

/* ns1__TaxInformation10 * has binding name 'PointerTons1__TaxInformation10' for type 'ns1:TaxInformation10' */
#ifndef SOAP_TYPE_PointerTons1__TaxInformation10
#define SOAP_TYPE_PointerTons1__TaxInformation10 (254)
#endif

/* ns1__RegulatoryReporting3 * has binding name 'PointerTons1__RegulatoryReporting3' for type 'ns1:RegulatoryReporting3' */
#ifndef SOAP_TYPE_PointerTons1__RegulatoryReporting3
#define SOAP_TYPE_PointerTons1__RegulatoryReporting3 (252)
#endif

/* ns1__Purpose2Choice * has binding name 'PointerTons1__Purpose2Choice' for type 'ns1:Purpose2Choice' */
#ifndef SOAP_TYPE_PointerTons1__Purpose2Choice
#define SOAP_TYPE_PointerTons1__Purpose2Choice (251)
#endif

/* ns1__InstructionForDebtorAgent1 * has binding name 'PointerTons1__InstructionForDebtorAgent1' for type 'ns1:InstructionForDebtorAgent1' */
#ifndef SOAP_TYPE_PointerTons1__InstructionForDebtorAgent1
#define SOAP_TYPE_PointerTons1__InstructionForDebtorAgent1 (250)
#endif

/* ns1__InstructionForCreditorAgent3 * has binding name 'PointerTons1__InstructionForCreditorAgent3' for type 'ns1:InstructionForCreditorAgent3' */
#ifndef SOAP_TYPE_PointerTons1__InstructionForCreditorAgent3
#define SOAP_TYPE_PointerTons1__InstructionForCreditorAgent3 (248)
#endif

/* ns1__CashAccount40 * has binding name 'PointerTons1__CashAccount40' for type 'ns1:CashAccount40' */
#ifndef SOAP_TYPE_PointerTons1__CashAccount40
#define SOAP_TYPE_PointerTons1__CashAccount40 (247)
#endif

/* ns1__BranchAndFinancialInstitutionIdentification6 * has binding name 'PointerTons1__BranchAndFinancialInstitutionIdentification6' for type 'ns1:BranchAndFinancialInstitutionIdentification6' */
#ifndef SOAP_TYPE_PointerTons1__BranchAndFinancialInstitutionIdentification6
#define SOAP_TYPE_PointerTons1__BranchAndFinancialInstitutionIdentification6 (246)
#endif

/* ns1__PartyIdentification135 * has binding name 'PointerTons1__PartyIdentification135' for type 'ns1:PartyIdentification135' */
#ifndef SOAP_TYPE_PointerTons1__PartyIdentification135
#define SOAP_TYPE_PointerTons1__PartyIdentification135 (245)
#endif

/* ns1__Cheque11 * has binding name 'PointerTons1__Cheque11' for type 'ns1:Cheque11' */
#ifndef SOAP_TYPE_PointerTons1__Cheque11
#define SOAP_TYPE_PointerTons1__Cheque11 (244)
#endif

/* ns1__CreditTransferMandateData1 * has binding name 'PointerTons1__CreditTransferMandateData1' for type 'ns1:CreditTransferMandateData1' */
#ifndef SOAP_TYPE_PointerTons1__CreditTransferMandateData1
#define SOAP_TYPE_PointerTons1__CreditTransferMandateData1 (243)
#endif

/* enum ns1__ChargeBearerType1Code * has binding name 'PointerTons1__ChargeBearerType1Code' for type 'ns1:ChargeBearerType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ChargeBearerType1Code
#define SOAP_TYPE_PointerTons1__ChargeBearerType1Code (242)
#endif

/* ns1__ExchangeRate1 * has binding name 'PointerTons1__ExchangeRate1' for type 'ns1:ExchangeRate1' */
#ifndef SOAP_TYPE_PointerTons1__ExchangeRate1
#define SOAP_TYPE_PointerTons1__ExchangeRate1 (241)
#endif

/* ns1__AmountType4Choice * has binding name 'PointerTons1__AmountType4Choice' for type 'ns1:AmountType4Choice' */
#ifndef SOAP_TYPE_PointerTons1__AmountType4Choice
#define SOAP_TYPE_PointerTons1__AmountType4Choice (240)
#endif

/* ns1__PaymentTypeInformation26 * has binding name 'PointerTons1__PaymentTypeInformation26' for type 'ns1:PaymentTypeInformation26' */
#ifndef SOAP_TYPE_PointerTons1__PaymentTypeInformation26
#define SOAP_TYPE_PointerTons1__PaymentTypeInformation26 (239)
#endif

/* ns1__PaymentIdentification6 * has binding name 'PointerTons1__PaymentIdentification6' for type 'ns1:PaymentIdentification6' */
#ifndef SOAP_TYPE_PointerTons1__PaymentIdentification6
#define SOAP_TYPE_PointerTons1__PaymentIdentification6 (238)
#endif

/* ns1__MandateSetupReason1Choice * has binding name 'PointerTons1__MandateSetupReason1Choice' for type 'ns1:MandateSetupReason1Choice' */
#ifndef SOAP_TYPE_PointerTons1__MandateSetupReason1Choice
#define SOAP_TYPE_PointerTons1__MandateSetupReason1Choice (237)
#endif

/* ns1__Frequency36Choice * has binding name 'PointerTons1__Frequency36Choice' for type 'ns1:Frequency36Choice' */
#ifndef SOAP_TYPE_PointerTons1__Frequency36Choice
#define SOAP_TYPE_PointerTons1__Frequency36Choice (236)
#endif

/* xsd__base64Binary * has binding name 'PointerTons1__Max10KBinary' for type 'ns1:Max10KBinary' */
#ifndef SOAP_TYPE_PointerTons1__Max10KBinary
#define SOAP_TYPE_PointerTons1__Max10KBinary (235)
#endif

/* time_t * has binding name 'PointerTons1__ISODateTime' for type 'ns1:ISODateTime' */
#ifndef SOAP_TYPE_PointerTons1__ISODateTime
#define SOAP_TYPE_PointerTons1__ISODateTime (234)
#endif

/* ns1__MandateTypeInformation2 * has binding name 'PointerTons1__MandateTypeInformation2' for type 'ns1:MandateTypeInformation2' */
#ifndef SOAP_TYPE_PointerTons1__MandateTypeInformation2
#define SOAP_TYPE_PointerTons1__MandateTypeInformation2 (233)
#endif

/* enum ns1__PreferredContactMethod1Code * has binding name 'PointerTons1__PreferredContactMethod1Code' for type 'ns1:PreferredContactMethod1Code' */
#ifndef SOAP_TYPE_PointerTons1__PreferredContactMethod1Code
#define SOAP_TYPE_PointerTons1__PreferredContactMethod1Code (232)
#endif

/* ns1__OtherContact1 * has binding name 'PointerTons1__OtherContact1' for type 'ns1:OtherContact1' */
#ifndef SOAP_TYPE_PointerTons1__OtherContact1
#define SOAP_TYPE_PointerTons1__OtherContact1 (230)
#endif

/* std::string * has binding name 'PointerTons1__Max2048Text' for type 'ns1:Max2048Text' */
#ifndef SOAP_TYPE_PointerTons1__Max2048Text
#define SOAP_TYPE_PointerTons1__Max2048Text (229)
#endif

/* std::string * has binding name 'PointerTons1__PhoneNumber' for type 'ns1:PhoneNumber' */
#ifndef SOAP_TYPE_PointerTons1__PhoneNumber
#define SOAP_TYPE_PointerTons1__PhoneNumber (228)
#endif

/* enum ns1__NamePrefix2Code * has binding name 'PointerTons1__NamePrefix2Code' for type 'ns1:NamePrefix2Code' */
#ifndef SOAP_TYPE_PointerTons1__NamePrefix2Code
#define SOAP_TYPE_PointerTons1__NamePrefix2Code (227)
#endif

/* ns1__ClearingSystemIdentification2Choice * has binding name 'PointerTons1__ClearingSystemIdentification2Choice' for type 'ns1:ClearingSystemIdentification2Choice' */
#ifndef SOAP_TYPE_PointerTons1__ClearingSystemIdentification2Choice
#define SOAP_TYPE_PointerTons1__ClearingSystemIdentification2Choice (226)
#endif

/* std::string * has binding name 'PointerTons1__ExternalClearingSystemIdentification1Code' for type 'ns1:ExternalClearingSystemIdentification1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalClearingSystemIdentification1Code
#define SOAP_TYPE_PointerTons1__ExternalClearingSystemIdentification1Code (225)
#endif

/* std::string * has binding name 'PointerTons1__ISODate' for type 'ns1:ISODate' */
#ifndef SOAP_TYPE_PointerTons1__ISODate
#define SOAP_TYPE_PointerTons1__ISODate (220)
#endif

/* enum ns1__Priority2Code * has binding name 'PointerTons1__Priority2Code' for type 'ns1:Priority2Code' */
#ifndef SOAP_TYPE_PointerTons1__Priority2Code
#define SOAP_TYPE_PointerTons1__Priority2Code (219)
#endif

/* ns1__ChequeDeliveryMethod1Choice * has binding name 'PointerTons1__ChequeDeliveryMethod1Choice' for type 'ns1:ChequeDeliveryMethod1Choice' */
#ifndef SOAP_TYPE_PointerTons1__ChequeDeliveryMethod1Choice
#define SOAP_TYPE_PointerTons1__ChequeDeliveryMethod1Choice (218)
#endif

/* ns1__NameAndAddress16 * has binding name 'PointerTons1__NameAndAddress16' for type 'ns1:NameAndAddress16' */
#ifndef SOAP_TYPE_PointerTons1__NameAndAddress16
#define SOAP_TYPE_PointerTons1__NameAndAddress16 (217)
#endif

/* enum ns1__ChequeType2Code * has binding name 'PointerTons1__ChequeType2Code' for type 'ns1:ChequeType2Code' */
#ifndef SOAP_TYPE_PointerTons1__ChequeType2Code
#define SOAP_TYPE_PointerTons1__ChequeType2Code (216)
#endif

/* std::string * has binding name 'PointerTons1__ExternalCategoryPurpose1Code' for type 'ns1:ExternalCategoryPurpose1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalCategoryPurpose1Code
#define SOAP_TYPE_PointerTons1__ExternalCategoryPurpose1Code (215)
#endif

/* std::string * has binding name 'PointerTons1__ExternalCashAccountType1Code' for type 'ns1:ExternalCashAccountType1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalCashAccountType1Code
#define SOAP_TYPE_PointerTons1__ExternalCashAccountType1Code (213)
#endif

/* ns1__ProxyAccountIdentification1 * has binding name 'PointerTons1__ProxyAccountIdentification1' for type 'ns1:ProxyAccountIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__ProxyAccountIdentification1
#define SOAP_TYPE_PointerTons1__ProxyAccountIdentification1 (211)
#endif

/* std::string * has binding name 'PointerTons1__Max70Text' for type 'ns1:Max70Text' */
#ifndef SOAP_TYPE_PointerTons1__Max70Text
#define SOAP_TYPE_PointerTons1__Max70Text (210)
#endif

/* std::string * has binding name 'PointerTons1__ActiveOrHistoricCurrencyCode' for type 'ns1:ActiveOrHistoricCurrencyCode' */
#ifndef SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyCode
#define SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyCode (209)
#endif

/* ns1__CashAccountType2Choice * has binding name 'PointerTons1__CashAccountType2Choice' for type 'ns1:CashAccountType2Choice' */
#ifndef SOAP_TYPE_PointerTons1__CashAccountType2Choice
#define SOAP_TYPE_PointerTons1__CashAccountType2Choice (208)
#endif

/* ns1__AccountIdentification4Choice * has binding name 'PointerTons1__AccountIdentification4Choice' for type 'ns1:AccountIdentification4Choice' */
#ifndef SOAP_TYPE_PointerTons1__AccountIdentification4Choice
#define SOAP_TYPE_PointerTons1__AccountIdentification4Choice (207)
#endif

/* ns1__PostalAddress24 * has binding name 'PointerTons1__PostalAddress24' for type 'ns1:PostalAddress24' */
#ifndef SOAP_TYPE_PointerTons1__PostalAddress24
#define SOAP_TYPE_PointerTons1__PostalAddress24 (206)
#endif

/* std::string * has binding name 'PointerTons1__Max140Text' for type 'ns1:Max140Text' */
#ifndef SOAP_TYPE_PointerTons1__Max140Text
#define SOAP_TYPE_PointerTons1__Max140Text (205)
#endif

/* std::string * has binding name 'PointerTons1__LEIIdentifier' for type 'ns1:LEIIdentifier' */
#ifndef SOAP_TYPE_PointerTons1__LEIIdentifier
#define SOAP_TYPE_PointerTons1__LEIIdentifier (204)
#endif

/* ns1__BranchData3 * has binding name 'PointerTons1__BranchData3' for type 'ns1:BranchData3' */
#ifndef SOAP_TYPE_PointerTons1__BranchData3
#define SOAP_TYPE_PointerTons1__BranchData3 (203)
#endif

/* ns1__FinancialInstitutionIdentification18 * has binding name 'PointerTons1__FinancialInstitutionIdentification18' for type 'ns1:FinancialInstitutionIdentification18' */
#ifndef SOAP_TYPE_PointerTons1__FinancialInstitutionIdentification18
#define SOAP_TYPE_PointerTons1__FinancialInstitutionIdentification18 (202)
#endif

/* std::string * has binding name 'PointerTons1__Max128Text' for type 'ns1:Max128Text' */
#ifndef SOAP_TYPE_PointerTons1__Max128Text
#define SOAP_TYPE_PointerTons1__Max128Text (201)
#endif

/* ns1__EquivalentAmount2 * has binding name 'PointerTons1__EquivalentAmount2' for type 'ns1:EquivalentAmount2' */
#ifndef SOAP_TYPE_PointerTons1__EquivalentAmount2
#define SOAP_TYPE_PointerTons1__EquivalentAmount2 (199)
#endif

/* ns1__ActiveOrHistoricCurrencyAndAmount * has binding name 'PointerTons1__ActiveOrHistoricCurrencyAndAmount' for type 'ns1:ActiveOrHistoricCurrencyAndAmount' */
#ifndef SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyAndAmount
#define SOAP_TYPE_PointerTons1__ActiveOrHistoricCurrencyAndAmount (198)
#endif

/* ns1__AdviceType1Choice * has binding name 'PointerTons1__AdviceType1Choice' for type 'ns1:AdviceType1Choice' */
#ifndef SOAP_TYPE_PointerTons1__AdviceType1Choice
#define SOAP_TYPE_PointerTons1__AdviceType1Choice (195)
#endif

/* ns1__GenericIdentification30 * has binding name 'PointerTons1__GenericIdentification30' for type 'ns1:GenericIdentification30' */
#ifndef SOAP_TYPE_PointerTons1__GenericIdentification30
#define SOAP_TYPE_PointerTons1__GenericIdentification30 (194)
#endif

/* std::string * has binding name 'PointerTons1__Max35Text' for type 'ns1:Max35Text' */
#ifndef SOAP_TYPE_PointerTons1__Max35Text
#define SOAP_TYPE_PointerTons1__Max35Text (192)
#endif

/* std::string * has binding name 'PointerTons1__ExternalAccountIdentification1Code' for type 'ns1:ExternalAccountIdentification1Code' */
#ifndef SOAP_TYPE_PointerTons1__ExternalAccountIdentification1Code
#define SOAP_TYPE_PointerTons1__ExternalAccountIdentification1Code (191)
#endif

/* ns1__GenericAccountIdentification1 * has binding name 'PointerTons1__GenericAccountIdentification1' for type 'ns1:GenericAccountIdentification1' */
#ifndef SOAP_TYPE_PointerTons1__GenericAccountIdentification1
#define SOAP_TYPE_PointerTons1__GenericAccountIdentification1 (188)
#endif

/* std::string * has binding name 'PointerTons1__IBAN2007Identifier' for type 'ns1:IBAN2007Identifier' */
#ifndef SOAP_TYPE_PointerTons1__IBAN2007Identifier
#define SOAP_TYPE_PointerTons1__IBAN2007Identifier (187)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__TaxRecord3 *>  has binding name 'std__vectorTemplateOfPointerTons1__TaxRecord3' for type 'ns1:TaxRecord3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecord3 (386)
#endif

/* std::vector<ns1__TaxRecordDetails3 *>  has binding name 'std__vectorTemplateOfPointerTons1__TaxRecordDetails3' for type 'ns1:TaxRecordDetails3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxRecordDetails3 (378)
#endif

/* std::vector<ns1__ReferredDocumentInformation7 *>  has binding name 'std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7' for type 'ns1:ReferredDocumentInformation7' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReferredDocumentInformation7 (369)
#endif

/* std::vector<ns1__RemittanceLocationData1 *>  has binding name 'std__vectorTemplateOfPointerTons1__RemittanceLocationData1' for type 'ns1:RemittanceLocationData1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocationData1 (364)
#endif

/* std::vector<ns1__StructuredRemittanceInformation17 *>  has binding name 'std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17' for type 'ns1:StructuredRemittanceInformation17' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRemittanceInformation17 (362)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns1__Max140Text' for type 'ns1:Max140Text' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__Max140Text
#define SOAP_TYPE_std__vectorTemplateOfns1__Max140Text (360)
#endif

/* std::vector<ns1__DocumentAdjustment1 *>  has binding name 'std__vectorTemplateOfPointerTons1__DocumentAdjustment1' for type 'ns1:DocumentAdjustment1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentAdjustment1 (359)
#endif

/* std::vector<ns1__TaxAmountAndType1 *>  has binding name 'std__vectorTemplateOfPointerTons1__TaxAmountAndType1' for type 'ns1:TaxAmountAndType1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaxAmountAndType1 (357)
#endif

/* std::vector<ns1__DiscountAmountAndType1 *>  has binding name 'std__vectorTemplateOfPointerTons1__DiscountAmountAndType1' for type 'ns1:DiscountAmountAndType1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DiscountAmountAndType1 (355)
#endif

/* std::vector<ns1__StructuredRegulatoryReporting3 *>  has binding name 'std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3' for type 'ns1:StructuredRegulatoryReporting3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__StructuredRegulatoryReporting3 (353)
#endif

/* std::vector<ns1__DocumentLineInformation1 *>  has binding name 'std__vectorTemplateOfPointerTons1__DocumentLineInformation1' for type 'ns1:DocumentLineInformation1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineInformation1 (347)
#endif

/* std::vector<ns1__GenericPersonIdentification1 *>  has binding name 'std__vectorTemplateOfPointerTons1__GenericPersonIdentification1' for type 'ns1:GenericPersonIdentification1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericPersonIdentification1 (335)
#endif

/* std::vector<ns1__ServiceLevel8Choice *>  has binding name 'std__vectorTemplateOfPointerTons1__ServiceLevel8Choice' for type 'ns1:ServiceLevel8Choice' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ServiceLevel8Choice (332)
#endif

/* std::vector<ns1__CreditTransferTransaction54 *>  has binding name 'std__vectorTemplateOfPointerTons1__CreditTransferTransaction54' for type 'ns1:CreditTransferTransaction54' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__CreditTransferTransaction54 (331)
#endif

/* std::vector<ns1__GenericOrganisationIdentification1 *>  has binding name 'std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1' for type 'ns1:GenericOrganisationIdentification1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenericOrganisationIdentification1 (316)
#endif

/* std::vector<ns1__Authorisation1Choice *>  has binding name 'std__vectorTemplateOfPointerTons1__Authorisation1Choice' for type 'ns1:Authorisation1Choice' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Authorisation1Choice (300)
#endif

/* std::vector<ns1__DocumentLineIdentification1 *>  has binding name 'std__vectorTemplateOfPointerTons1__DocumentLineIdentification1' for type 'ns1:DocumentLineIdentification1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DocumentLineIdentification1 (275)
#endif

/* std::vector<ns1__PaymentInstruction40 *>  has binding name 'std__vectorTemplateOfPointerTons1__PaymentInstruction40' for type 'ns1:PaymentInstruction40' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__PaymentInstruction40 (265)
#endif

/* std::vector<ns1__SupplementaryData1 *>  has binding name 'std__vectorTemplateOfPointerTons1__SupplementaryData1' for type 'ns1:SupplementaryData1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__SupplementaryData1 (259)
#endif

/* std::vector<ns1__RemittanceLocation7 *>  has binding name 'std__vectorTemplateOfPointerTons1__RemittanceLocation7' for type 'ns1:RemittanceLocation7' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RemittanceLocation7 (256)
#endif

/* std::vector<ns1__RegulatoryReporting3 *>  has binding name 'std__vectorTemplateOfPointerTons1__RegulatoryReporting3' for type 'ns1:RegulatoryReporting3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RegulatoryReporting3 (253)
#endif

/* std::vector<ns1__InstructionForCreditorAgent3 *>  has binding name 'std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3' for type 'ns1:InstructionForCreditorAgent3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstructionForCreditorAgent3 (249)
#endif

/* std::vector<ns1__OtherContact1 *>  has binding name 'std__vectorTemplateOfPointerTons1__OtherContact1' for type 'ns1:OtherContact1' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtherContact1 (231)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns1__Max70Text' for type 'ns1:Max70Text' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__Max70Text
#define SOAP_TYPE_std__vectorTemplateOfns1__Max70Text (222)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns1__Max35Text' for type 'ns1:Max35Text' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__Max35Text
#define SOAP_TYPE_std__vectorTemplateOfns1__Max35Text (221)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
